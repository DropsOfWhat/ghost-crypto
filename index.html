<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ghost — Crypto AI Command Center</title>
  <script>
    // Restore theme instantly to prevent flash
    (function(){try{var t=localStorage.getItem('ghost-theme');if(t)document.documentElement.setAttribute('data-theme',t);}catch(e){}})();
  </script>
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&family=Fira+Code:wght@400;500;600;700&display=swap');


    /* ═══════ WALLET SELECTOR MODAL ═══════ */
    .wallet-modal-overlay {
      display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6);
      backdrop-filter: blur(8px); z-index: 9999; align-items: center; justify-content: center;
    }
    .wallet-modal-overlay.open { display: flex; }
    .wallet-modal {
      background: var(--bg-elevated); border: 1px solid var(--border-tertiary);
      border-radius: 16px; padding: 24px; width: 340px; max-width: 90vw;
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    }
    .wallet-modal-title {
      font-size: 16px; font-weight: 700; color: var(--text-primary);
      margin-bottom: 4px; text-align: center;
    }
    .wallet-modal-sub {
      font-size: 11px; color: var(--text-muted); text-align: center;
      margin-bottom: 16px;
    }
    .wallet-option {
      display: flex; align-items: center; gap: 12px; padding: 14px 16px;
      border-radius: 12px; border: 1px solid var(--border-primary);
      background: var(--bg-glass); cursor: pointer; margin-bottom: 8px;
      transition: all 0.2s;
    }
    .wallet-option:hover { border-color: var(--accent); background: var(--accent-dim); }
    .wallet-option.detected { }
    .wallet-option.not-detected { opacity: 0.45; }
    .wallet-option .wo-icon { font-size: 28px; flex-shrink: 0; width: 36px; text-align: center; }
    .wallet-option .wo-info { flex: 1; }
    .wallet-option .wo-name { font-size: 13px; font-weight: 700; color: var(--text-primary); }
    .wallet-option .wo-status {
      font-size: 10px; margin-top: 2px; font-weight: 600; letter-spacing: 0.04em;
    }
    .wallet-option .wo-status.ok { color: var(--green); }
    .wallet-option .wo-status.missing { color: var(--text-faint); }
    .wallet-option .wo-chains {
      display: flex; gap: 4px; margin-top: 4px;
    }
    .wallet-option .wo-chain-tag {
      font-size: 9px; padding: 1px 6px; border-radius: 4px;
      font-weight: 600; letter-spacing: 0.03em;
      background: var(--bg-secondary); color: var(--text-muted); border: 1px solid var(--border-primary);
    }
    .wallet-option .wo-chain-tag.active {
      color: var(--accent); border-color: var(--accent); background: var(--accent-dim);
    }
    .wallet-modal-close {
      display: block; width: 100%; margin-top: 8px; padding: 10px;
      background: none; border: 1px solid var(--border-primary); border-radius: 10px;
      color: var(--text-muted); font-size: 12px; font-weight: 600; cursor: pointer;
      transition: all 0.15s;
    }
    .wallet-modal-close:hover { color: var(--text-secondary); border-color: var(--border-tertiary); }

    /* ═══════ CHAIN SELECTOR ═══════ */
    .chain-bar {
      display: flex; gap: 4px; padding: 8px 12px; border-bottom: 1px solid var(--border-primary);
      background: var(--bg-secondary); flex-shrink: 0;
    }
    .chain-btn {
      flex: 1; display: flex; align-items: center; justify-content: center; gap: 5px;
      padding: 6px 8px; border-radius: 8px; border: 1px solid var(--border-primary);
      background: var(--bg-glass); color: var(--text-muted); cursor: pointer;
      font-size: 11px; font-weight: 600; font-family: 'Fira Code', monospace;
      transition: all 0.2s; letter-spacing: 0.03em;
    }
    .chain-btn:hover { border-color: var(--border-tertiary); color: var(--text-secondary); }
    .chain-btn.active {
      border-color: var(--chain-color, var(--accent)); color: var(--chain-color, var(--accent));
      background: var(--chain-bg, var(--accent-dim)); box-shadow: 0 0 12px var(--chain-glow, rgba(34,209,238,0.1));
    }
    .chain-btn .chain-dot {
      width: 6px; height: 6px; border-radius: 50%; background: currentColor; flex-shrink: 0;
    }
    .chain-btn[data-chain="solana"] { --chain-color: #9945FF; --chain-bg: rgba(153,69,255,0.1); --chain-glow: rgba(153,69,255,0.15); }
    .chain-btn[data-chain="ethereum"] { --chain-color: #627EEA; --chain-bg: rgba(98,126,234,0.1); --chain-glow: rgba(98,126,234,0.15); }
    .chain-btn[data-chain="base"] { --chain-color: #0052FF; --chain-bg: rgba(0,82,255,0.1); --chain-glow: rgba(0,82,255,0.15); }
    .chain-btn[data-chain="bsc"] { --chain-color: #F0B90B; --chain-bg: rgba(240,185,11,0.1); --chain-glow: rgba(240,185,11,0.15); }
    .evm-settings-row {
      display: flex; flex-direction: column; gap: 6px; margin-top: 8px; padding: 10px 12px;
      background: var(--bg-glass); border: 1px solid var(--border-primary); border-radius: 10px;
    }
    .evm-settings-row .fl { font-size: 10px; }

    /* ═══════ OBSIDIAN TERMINAL — DARK ═══════ */
    :root {
      --bg-primary: #060910;
      --bg-secondary: #080c14;
      --bg-surface: rgba(12,17,28,0.65);
      --bg-elevated: #0e1420;
      --bg-overlay: rgba(6,9,16,0.8);
      --bg-sidebar: rgba(8,12,20,0.85);
      --bg-glass: rgba(14,20,32,0.55);
      --border-primary: rgba(100,120,160,0.08);
      --border-secondary: rgba(100,120,160,0.06);
      --border-tertiary: rgba(100,120,160,0.12);
      --border-glow: rgba(34,209,238,0.2);
      --text-primary: #f8fafc;
      --text-secondary: #d1dae6;
      --text-tertiary: #a8b8cc;
      --text-muted: #8a9bb3;
      --text-faint: #6a7d96;
      --text-ghost: #4a5f78;
      --accent: #22d1ee;
      --accent-dim: rgba(34,209,238,0.1);
      --accent-glow: rgba(34,209,238,0.06);
      --accent-gradient: linear-gradient(135deg, #06b6d4, #22d1ee, #67e8f9);
      --accent-gradient-btn: linear-gradient(135deg, #0891b2, #22d1ee);
      --green: #34d399;
      --green-dim: rgba(52,211,153,0.12);
      --green-bg: rgba(52,211,153,0.08);
      --green-border: rgba(52,211,153,0.25);
      --red: #f87171;
      --red-dim: rgba(248,113,113,0.12);
      --red-bg: rgba(248,113,113,0.08);
      --red-border: rgba(248,113,113,0.25);
      --yellow: #fbbf24;
      --yellow-dim: rgba(251,191,36,0.12);
      --yellow-bg: rgba(251,191,36,0.06);
      --yellow-border: rgba(251,191,36,0.15);
      --msg-user: rgba(14,20,32,0.6);
      --msg-ai-bg: linear-gradient(135deg, rgba(34,209,238,0.04) 0%, rgba(6,182,212,0.02) 100%);
      --msg-ai-border: rgba(34,209,238,0.12);
      --msg-system-bg: rgba(251,191,36,0.04);
      --msg-system-border: rgba(251,191,36,0.12);
      --msg-success-bg: rgba(52,211,153,0.04);
      --msg-success-border: rgba(52,211,153,0.12);
      --scrollbar: rgba(100,120,160,0.12);
      --shadow: 0 0 120px rgba(34,209,238,0.03);
      --glass-blur: 16px;
      --noise: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.03'/%3E%3C/svg%3E");
    }

    [data-theme="light"] {
      --bg-primary: #f1f5f9;
      --bg-secondary: #e8ecf2;
      --bg-surface: rgba(255,255,255,0.7);
      --bg-elevated: #f8fafc;
      --bg-overlay: rgba(241,245,249,0.9);
      --bg-sidebar: rgba(248,250,252,0.9);
      --bg-glass: rgba(255,255,255,0.6);
      --border-primary: rgba(51,65,85,0.08);
      --border-secondary: rgba(51,65,85,0.06);
      --border-tertiary: rgba(51,65,85,0.12);
      --border-glow: rgba(6,182,212,0.3);
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-tertiary: #64748b;
      --text-muted: #94a3b8;
      --text-faint: #cbd5e1;
      --text-ghost: #e2e8f0;
      --accent: #0891b2;
      --accent-dim: rgba(8,145,178,0.08);
      --accent-glow: rgba(8,145,178,0.04);
      --accent-gradient: linear-gradient(135deg, #0e7490, #0891b2, #22d1ee);
      --accent-gradient-btn: linear-gradient(135deg, #0e7490, #0891b2);
      --green: #059669;
      --green-dim: rgba(5,150,105,0.08);
      --green-bg: rgba(5,150,105,0.06);
      --green-border: rgba(5,150,105,0.2);
      --red: #dc2626;
      --red-dim: rgba(220,38,38,0.08);
      --red-bg: rgba(220,38,38,0.05);
      --red-border: rgba(220,38,38,0.18);
      --yellow: #d97706;
      --yellow-dim: rgba(217,119,6,0.08);
      --yellow-bg: rgba(217,119,6,0.05);
      --yellow-border: rgba(217,119,6,0.15);
      --msg-user: rgba(241,245,249,0.8);
      --msg-ai-bg: linear-gradient(135deg, rgba(8,145,178,0.04) 0%, rgba(6,182,212,0.02) 100%);
      --msg-ai-border: rgba(8,145,178,0.12);
      --msg-system-bg: rgba(217,119,6,0.04);
      --msg-system-border: rgba(217,119,6,0.12);
      --msg-success-bg: rgba(5,150,105,0.04);
      --msg-success-border: rgba(5,150,105,0.12);
      --scrollbar: rgba(51,65,85,0.1);
      --shadow: 0 4px 24px rgba(0,0,0,0.04);
      --glass-blur: 12px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Plus Jakarta Sans', -apple-system, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary); height: 100vh; overflow: hidden;
    }

    /* Noise texture overlay */
    body::before {
      content: ''; position: fixed; inset: 0; z-index: 0; pointer-events: none;
      background-image: var(--noise); background-repeat: repeat; opacity: 0.4;
    }

    /* Mesh gradient background */
    body::after {
      content: ''; position: fixed; inset: 0; z-index: 0; pointer-events: none;
      background:
        radial-gradient(ellipse 60% 40% at 20% 10%, rgba(34,209,238,0.04) 0%, transparent 60%),
        radial-gradient(ellipse 50% 50% at 80% 80%, rgba(99,102,241,0.03) 0%, transparent 60%),
        radial-gradient(ellipse 40% 30% at 50% 50%, rgba(52,211,153,0.02) 0%, transparent 50%);
    }

    /* Smooth theme transitions */
    *, *::before, *::after {
      transition: background-color 0.4s ease, border-color 0.4s ease, color 0.3s ease, box-shadow 0.4s ease;
    }

    ::-webkit-scrollbar { width: 5px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--scrollbar); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-faint); }

    #app { display: flex; flex-direction: column; height: 100vh; position: relative; z-index: 1; }

    .glow {
      position: absolute; top: -100px; left: 50%; transform: translateX(-50%);
      width: 60%; height: 260px;
      background: radial-gradient(ellipse, var(--accent-glow) 0%, transparent 70%);
      pointer-events: none; animation: glow 6s ease-in-out infinite; z-index: 0;
    }

    @keyframes glow { 0%, 100% { opacity: 0.4; transform: translateX(-50%) scale(1); } 50% { opacity: 0.8; transform: translateX(-50%) scale(1.05); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
    @keyframes breathe { 0%, 100% { box-shadow: 0 0 0 0 rgba(34,209,238,0); } 50% { box-shadow: 0 0 16px 2px rgba(34,209,238,0.08); } }
    @keyframes slideIn { from { opacity: 0; transform: translateX(-8px); } to { opacity: 1; transform: translateX(0); } }

    /* ═══════ HEADER ═══════ */
    .header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 20px; height: 56px;
      background: var(--bg-glass);
      backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
      border-bottom: 1px solid var(--border-primary);
      position: relative; z-index: 10;
    }

    .logo-area { display: flex; align-items: center; gap: 12px; }
    .logo-icon {
      font-size: 22px; color: var(--accent);
      filter: drop-shadow(0 0 8px rgba(34,209,238,0.3));
      animation: breathe 4s ease-in-out infinite;
    }
    .logo-text {
      font-size: 15px; font-weight: 800; letter-spacing: 0.25em;
      background: var(--accent-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .logo-sub {
      font-size: 10px; color: var(--text-muted); letter-spacing: 0.15em;
      font-weight: 600; text-transform: uppercase;
    }

    .mode-bar {
      display: flex; gap: 1px; background: var(--bg-glass);
      backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
      padding: 3px; border-radius: 10px; border: 1px solid var(--border-primary);
    }
    .mode-btn {
      display: flex; align-items: center; gap: 6px;
      padding: 6px 14px; background: transparent; border: none;
      border-radius: 8px; font-size: 12px; font-weight: 600;
      color: var(--text-muted); cursor: pointer; font-family: inherit;
      letter-spacing: 0.02em; position: relative;
    }
    .mode-btn:hover { color: var(--text-secondary); }
    .mode-btn.active {
      background: var(--bg-elevated); color: var(--text-primary);
      box-shadow: 0 0 0 1.5px var(--accent), 0 0 12px rgba(34,209,238,0.25), 0 1px 4px rgba(0,0,0,0.15);
    }
    .mode-btn .ic { color: var(--accent); font-size: 13px; }

    .header-right { display: flex; align-items: center; gap: 6px; }

    .theme-toggle {
      width: 34px; height: 34px; border-radius: 8px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
      color: var(--text-tertiary); font-size: 15px;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      font-family: inherit;
    }
    .theme-toggle:hover { border-color: var(--border-glow); color: var(--accent); }

    .model-select {
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
      border-radius: 8px; padding: 6px 10px; color: var(--text-primary);
      font-family: 'Fira Code', monospace; font-size: 11px; cursor: pointer;
      font-weight: 500;
    }
    .model-select option { background: var(--bg-elevated); }

    .wallet-btn {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 7px 14px; border-radius: 10px; font-size: 12px; font-weight: 700;
      cursor: pointer; font-family: inherit; border: 1px solid;
      letter-spacing: 0.02em;
    }
    .wallet-btn.off {
      background: linear-gradient(135deg, #9b8ce8, #ab9ff1, #bdb4f5); border-color: transparent; color: #fff;
      box-shadow: 0 2px 12px rgba(171,159,241,0.3);
    }
    .wallet-btn.off:hover { box-shadow: 0 2px 20px rgba(171,159,241,0.45); }
    .wallet-btn.on { background: var(--green-bg); border-color: var(--green-border); color: var(--green); }
    .wallet-btn:hover { opacity: 0.9; }

    /* ═══════ WALLET PANEL ═══════ */
    .wp-header {
      padding: 20px 16px; text-align: center;
      background: linear-gradient(180deg, rgba(0,255,204,0.04) 0%, transparent 100%);
      border-bottom: 1px solid var(--border);
    }
    .wp-avatar {
      width: 48px; height: 48px; border-radius: 50%; margin: 0 auto 10px;
      background: linear-gradient(135deg, #9b8ce8, #00ffc8); display: flex;
      align-items: center; justify-content: center; font-size: 22px;
    }
    .wp-balance { font-size: 28px; font-weight: 800; color: var(--text); letter-spacing: -0.02em; }
    .wp-balance-label { font-size: 11px; color: var(--text-muted); margin-top: 2px; letter-spacing: 0.08em; }
    .wp-addr {
      display: flex; align-items: center; justify-content: center; gap: 6px;
      margin-top: 10px; padding: 6px 12px; border-radius: 20px;
      background: var(--card-bg); border: 1px solid var(--border);
      font-size: 11px; color: var(--text-muted); font-family: 'SF Mono', 'Fira Code', monospace;
      max-width: 260px; margin-left: auto; margin-right: auto;
    }
    .wp-addr-copy {
      background: none; border: none; color: var(--accent); cursor: pointer;
      font-size: 12px; padding: 0; flex-shrink: 0;
    }
    .wp-addr-copy:hover { opacity: 0.7; }
    .wp-actions {
      display: flex; gap: 8px; padding: 14px 16px; justify-content: center;
    }
    .wp-action {
      flex: 1; max-width: 130px; padding: 10px 0; border-radius: 10px; border: 1px solid var(--border);
      background: var(--card-bg); color: var(--text); cursor: pointer;
      font-size: 11px; font-weight: 600; font-family: inherit; text-align: center;
      transition: all 0.15s;
    }
    .wp-action:hover { border-color: var(--accent); color: var(--accent); }
    .wp-action.danger { color: var(--red); }
    .wp-action.danger:hover { border-color: var(--red); background: var(--red-bg); }
    .wp-action-icon { font-size: 16px; display: block; margin-bottom: 3px; }
    .wp-section {
      padding: 0 16px;
    }
    .wp-stitle {
      font-size: 10px; font-weight: 700; letter-spacing: 0.1em; color: var(--text-muted);
      text-transform: uppercase; padding: 12px 0 8px; border-bottom: 1px solid var(--border);
      margin-bottom: 2px;
    }
    .wp-holding {
      display: flex; align-items: center; gap: 10px; padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.04);
    }
    .wp-holding:last-child { border-bottom: none; }
    .wp-holding-icon {
      width: 32px; height: 32px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 12px; font-weight: 700; color: #fff; flex-shrink: 0;
    }
    .wp-holding-info { flex: 1; min-width: 0; }
    .wp-holding-name { font-size: 13px; font-weight: 600; color: var(--text); }
    .wp-holding-amt { font-size: 11px; color: var(--text-muted); }
    .wp-holding-val { text-align: right; }
    .wp-holding-usd { font-size: 13px; font-weight: 600; color: var(--text); }
    .wp-holding-price { font-size: 10px; color: var(--text-faint); }
    .wp-empty {
      text-align: center; padding: 24px; color: var(--text-faint); font-size: 12px;
    }
    .wp-loading {
      text-align: center; padding: 16px; color: var(--text-muted); font-size: 11px;
    }

    /* ═══════ TOKEN CARD (Rick-style) ═══════ */
    .tk-card {
      background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px;
      overflow: hidden; margin: 4px 0; max-width: 420px;
    }
    .tk-head {
      padding: 12px 14px; display: flex; align-items: center; gap: 10px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(135deg, rgba(0,255,204,0.04), transparent);
    }
    .tk-icon {
      width: 36px; height: 36px; border-radius: 50%; display: flex;
      align-items: center; justify-content: center; font-weight: 800;
      font-size: 14px; color: #fff; flex-shrink: 0;
    }
    .tk-title { flex: 1; min-width: 0; }
    .tk-name { font-size: 14px; font-weight: 700; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .tk-ticker { font-size: 11px; color: var(--accent); font-weight: 600; }
    .tk-price-big { font-size: 18px; font-weight: 800; color: var(--text); }
    .tk-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 0;
      padding: 0;
    }
    .tk-cell {
      padding: 8px 14px; border-bottom: 1px solid rgba(255,255,255,0.03);
      border-right: 1px solid rgba(255,255,255,0.03);
    }
    .tk-cell:nth-child(2n) { border-right: none; }
    .tk-label { font-size: 9px; color: var(--text-faint); text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 2px; }
    .tk-val { font-size: 13px; font-weight: 600; color: var(--text); }
    .tk-val.green { color: var(--green); }
    .tk-val.red { color: var(--red); }
    .tk-changes {
      display: flex; gap: 0; padding: 0; border-bottom: 1px solid var(--border);
    }
    .tk-chg {
      flex: 1; text-align: center; padding: 6px 4px;
      border-right: 1px solid rgba(255,255,255,0.03);
    }
    .tk-chg:last-child { border-right: none; }
    .tk-chg-label { font-size: 8px; color: var(--text-faint); text-transform: uppercase; }
    .tk-chg-val { font-size: 12px; font-weight: 700; }
    .tk-chg-val.up { color: var(--green); }
    .tk-chg-val.down { color: var(--red); }
    .tk-actions {
      display: flex; gap: 6px; padding: 10px 14px;
      border-top: 1px solid var(--border);
    }
    .tk-btn {
      flex: 1; padding: 7px 0; border-radius: 8px; border: 1px solid var(--border);
      background: var(--card-bg); color: var(--text); cursor: pointer;
      font-size: 10px; font-weight: 700; font-family: inherit; text-align: center;
      transition: all 0.15s; letter-spacing: 0.04em;
    }
    .tk-btn:hover { border-color: var(--accent); color: var(--accent); }
    .tk-btn.buy { background: rgba(0,255,204,0.08); border-color: rgba(0,255,204,0.3); color: var(--green); }
    .tk-btn.buy:hover { background: rgba(0,255,204,0.15); }

    /* ═══════ QUICK-TRADE (Axiom-style) ═══════ */
    .qt-section {
      border-top: 1px solid var(--border-secondary); padding: 10px 14px;
    }
    .qt-label {
      font-size: 8px; font-weight: 800; color: var(--text-faint);
      letter-spacing: 0.12em; text-transform: uppercase; margin-bottom: 6px;
      display: flex; align-items: center; gap: 4px;
    }
    .qt-row { display: flex; gap: 5px; }
    .qt-buy-btn {
      flex: 1; padding: 8px 2px; border-radius: 8px; border: 1px solid rgba(34,197,94,0.3);
      background: linear-gradient(135deg, rgba(34,197,94,0.12), rgba(34,197,94,0.04));
      color: #22c55e; font-size: 11px; font-weight: 800; cursor: pointer;
      font-family: 'Fira Code', monospace; letter-spacing: 0.02em;
      transition: all 0.15s;
    }
    .qt-buy-btn:hover { background: rgba(34,197,94,0.22); border-color: #22c55e; box-shadow: 0 2px 10px rgba(34,197,94,0.15); }
    .qt-buy-btn:active { transform: scale(0.96); }
    .qt-buy-btn.loading { opacity: 0.5; pointer-events: none; }
    .qt-sell-btn {
      flex: 1; padding: 8px 2px; border-radius: 8px; border: 1px solid rgba(239,68,68,0.3);
      background: linear-gradient(135deg, rgba(239,68,68,0.12), rgba(239,68,68,0.04));
      color: #ef4444; font-size: 11px; font-weight: 800; cursor: pointer;
      font-family: 'Fira Code', monospace; letter-spacing: 0.02em;
      transition: all 0.15s;
    }
    .qt-sell-btn:hover { background: rgba(239,68,68,0.22); border-color: #ef4444; box-shadow: 0 2px 10px rgba(239,68,68,0.15); }
    .qt-sell-btn:active { transform: scale(0.96); }
    .qt-sell-btn.loading { opacity: 0.5; pointer-events: none; }
    .qt-divider { width: 1px; background: var(--border-secondary); margin: 0 2px; }
    .qt-status {
      margin-top: 6px; font-size: 10px; font-weight: 600; text-align: center;
      padding: 6px 8px; border-radius: 6px; display: none;
    }
    .qt-status.active { display: block; }
    .qt-status.pending { background: rgba(251,191,36,0.1); color: #fbbf24; }
    .qt-status.success { background: rgba(34,197,94,0.1); color: #22c55e; }
    .qt-status.error { background: rgba(239,68,68,0.1); color: #ef4444; }
    .tk-addr {
      padding: 0 14px 10px; font-size: 10px; color: var(--text-faint);
      font-family: 'SF Mono', 'Fira Code', monospace; word-break: break-all;
      cursor: pointer;
    }
    .tk-addr:hover { color: var(--accent); }

    .sbadge {
      display: flex; align-items: center; gap: 5px;
      padding: 4px 10px; border: 1px solid; border-radius: 20px;
      font-size: 11px; font-weight: 600; letter-spacing: 0.04em;
    }
    .sbadge.on { background: var(--green-bg); border-color: var(--green-border); color: var(--green); }
    .sbadge.off { background: var(--red-bg); border-color: var(--red-border); color: var(--red); }
    .sdot { width: 5px; height: 5px; border-radius: 50%; animation: pulse 2s infinite; }
    .sbadge.on .sdot { background: var(--green); }
    .sbadge.off .sdot { background: var(--red); }

    /* ═══════ LAYOUT ═══════ */
    .main-layout { flex: 1; display: flex; overflow: hidden; }
    .sidebar {
      width: 0; overflow: hidden;
      border-right: 1px solid var(--border-primary);
      background: var(--bg-sidebar);
      backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      transition: width 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .sidebar.open { width: 340px; }
    .sidebar-inner { width: 340px; height: 100%; overflow-y: auto; padding-bottom: 20px; }
    .sidebar-close-mobile {
      display: none; position: absolute; top: 10px; right: 10px; z-index: 110;
      width: 32px; height: 32px; border-radius: 8px;
      background: var(--bg-elevated); border: 1px solid var(--border-primary);
      color: var(--text-primary); font-size: 16px; cursor: pointer;
      align-items: center; justify-content: center;
    }

    .ph {
      padding: 16px 18px; font-size: 11px; font-weight: 700;
      letter-spacing: 0.14em; color: var(--text-muted);
      border-bottom: 1px solid var(--border-secondary);
      display: flex; justify-content: space-between; align-items: center;
      text-transform: uppercase;
    }

    /* ═══════ LAUNCH ═══════ */
    .lsection { padding: 14px; }
    .lplatform {
      padding: 14px 16px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 12px; margin-bottom: 8px; cursor: pointer;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    .lplatform:hover { border-color: var(--border-glow); }
    .lplatform.sel {
      border-color: var(--accent); background: var(--accent-dim);
      box-shadow: 0 0 16px rgba(34,209,238,0.06);
    }
    .lp-head { display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px; }
    .lp-name { font-size: 14px; font-weight: 700; }
    .lp-tag {
      font-size: 9px; padding: 3px 8px; border-radius: 6px;
      background: var(--accent-dim); color: var(--accent);
      font-weight: 700; letter-spacing: 0.06em;
    }
    .lp-desc { font-size: 12px; color: var(--text-muted); }

    .lform { padding: 14px; }
    .fg { margin-bottom: 14px; }
    .fl {
      font-size: 10px; color: var(--text-tertiary); margin-bottom: 7px; display: block;
      font-weight: 700; letter-spacing: 0.1em; text-transform: uppercase;
    }
    .fi {
      width: 100%; padding: 11px 14px;
      background: var(--bg-glass); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border: 1px solid var(--border-primary); border-radius: 10px;
      color: var(--text-primary); font-family: 'Fira Code', monospace; font-size: 13px;
    }
    .fi:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
    .fi::placeholder { color: var(--text-faint); }
    .fi-ta { resize: vertical; min-height: 60px; font-family: 'Plus Jakarta Sans', sans-serif; }
    .frow { display: flex; gap: 10px; }
    .frow .fg { flex: 1; }

    .file-upload {
      display: flex; align-items: center; justify-content: center; gap: 8px;
      width: 100%; padding: 26px 16px; background: var(--bg-glass);
      border: 2px dashed var(--border-tertiary); border-radius: 12px;
      color: var(--text-muted); font-size: 13px; text-align: center;
      cursor: pointer; font-family: inherit; box-sizing: border-box;
    }
    .file-upload:hover { border-color: var(--accent); background: var(--accent-dim); }
    .file-upload.has-file {
      border-color: var(--green); color: var(--green); border-style: solid;
      word-break: break-all; font-size: 12px;
    }
    .file-upload input { display: none; }

    .lbtn {
      width: 100%; padding: 14px; border: none; border-radius: 12px;
      font-family: inherit; font-size: 14px; font-weight: 700;
      cursor: pointer; letter-spacing: 0.06em;
    }
    .lbtn.dis { background: var(--bg-elevated); color: var(--text-muted); cursor: not-allowed; }
    .lbtn.ready {
      background: var(--accent-gradient-btn); color: #fff;
      box-shadow: 0 4px 16px rgba(34,209,238,0.2);
    }
    .lbtn.ready:hover { box-shadow: 0 4px 24px rgba(34,209,238,0.35); transform: translateY(-1px); }
    .lbtn.loading {
      background: var(--accent-gradient-btn); color: #fff; opacity: 0.7;
      animation: pulse 1.5s infinite;
    }
    .lwarn {
      margin-top: 14px; padding: 12px; background: var(--yellow-bg);
      border: 1px solid var(--yellow-border); border-radius: 10px;
      font-size: 11px; color: var(--yellow); line-height: 1.6;
    }

    .launch-steps { padding: 14px; }
    .launch-step {
      display: flex; align-items: center; gap: 12px;
      padding: 11px 14px; margin-bottom: 4px; border-radius: 10px; font-size: 13px;
    }
    .launch-step .step-num {
      width: 26px; height: 26px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 11px; font-weight: 700; flex-shrink: 0;
    }
    .launch-step .step-label { flex: 1; }
    .launch-step .step-status { font-size: 12px; font-weight: 600; margin-left: auto; }
    .launch-step.pending { color: var(--text-muted); }
    .launch-step.pending .step-num { background: var(--bg-elevated); color: var(--text-muted); }
    .launch-step.active { color: var(--accent); background: var(--accent-dim); }
    .launch-step.active .step-num { background: var(--accent); color: #fff; }
    .launch-step.done { color: var(--green); }
    .launch-step.done .step-num { background: var(--green-dim); color: var(--green); }
    .launch-step.error { color: var(--red); }
    .launch-step.error .step-num { background: var(--red-dim); color: var(--red); }

    /* ═══════ TOOLS / PLUGINS ═══════ */
    .tcard {
      margin: 8px 14px; padding: 16px;
      background: var(--bg-glass); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border: 1px solid var(--border-primary); border-radius: 12px;
      cursor: pointer;
    }
    .tcard:hover {
      border-color: var(--border-glow);
      box-shadow: 0 4px 16px rgba(34,209,238,0.06);
      transform: translateY(-1px);
    }
    .tcard.disabled { opacity: 0.45; cursor: not-allowed; }
    .tcard.disabled:hover { transform: none; border-color: var(--border-primary); box-shadow: none; }
    .tcard-h { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .tcard-n { font-size: 14px; font-weight: 700; }
    .tcard-s {
      font-size: 9px; font-weight: 800; padding: 3px 8px; border-radius: 6px;
      letter-spacing: 0.06em;
    }
    .tcard-d { font-size: 12px; color: var(--text-muted); line-height: 1.4; }

    /* ═══════ PERPS TERMINAL — FULLSCREEN ═══════ */
    .perps-fullscreen {
      flex: 1; display: flex; flex-direction: column; overflow: hidden;
      background: var(--bg-primary);
    }

    /* Top Bar */
    .perps-topbar {
      display: flex; align-items: center; gap: 12px;
      padding: 8px 16px; min-height: 52px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-primary);
    }
    .perps-topbar-left {
      display: flex; align-items: center; gap: 10px; flex-shrink: 0;
    }
    .perps-back-btn {
      padding: 5px 10px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 6px; font-size: 11px; font-weight: 600; color: var(--text-muted);
      cursor: pointer; font-family: 'Plus Jakarta Sans', sans-serif; transition: all 0.15s;
    }
    .perps-back-btn:hover { border-color: var(--border-glow); color: var(--accent); }
    .perps-title {
      font-size: 13px; font-weight: 800; letter-spacing: 0.04em;
      background: linear-gradient(135deg, #f59e0b, #fbbf24, #f59e0b);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .perps-badge {
      font-size: 7px; font-weight: 800; padding: 2px 6px; border-radius: 4px;
      background: linear-gradient(135deg, rgba(245,158,11,0.2), rgba(251,191,36,0.15));
      color: #fbbf24; letter-spacing: 0.08em; border: 1px solid rgba(251,191,36,0.2);
    }
    .perps-topbar-markets {
      display: flex; gap: 2px; margin-left: 8px;
    }
    .perps-market-btn {
      padding: 6px 14px; background: none; border: 1px solid transparent;
      border-radius: 6px; cursor: pointer; font-family: 'Plus Jakarta Sans', sans-serif;
      transition: all 0.2s; display: flex; align-items: center; gap: 8px;
    }
    .perps-market-btn:hover { background: var(--bg-glass); }
    .perps-market-btn.active {
      background: rgba(251,191,36,0.06); border-color: rgba(251,191,36,0.2);
    }
    .perps-market-sym {
      font-size: 12px; font-weight: 800; color: var(--text-primary);
      display: flex; align-items: center; gap: 5px;
    }
    .perps-market-sym .dot { width: 6px; height: 6px; border-radius: 50%; }
    .perps-market-price {
      font-size: 10px; font-weight: 600; font-family: 'Fira Code', monospace; color: var(--text-muted);
    }
    .perps-market-price.up { color: var(--green); }
    .perps-market-price.down { color: var(--red); }
    .perps-topbar-right {
      margin-left: auto; display: flex; align-items: center; gap: 16px;
    }
    .perps-topbar-price {
      display: flex; align-items: baseline; gap: 8px;
    }
    .perps-big-price {
      font-size: 22px; font-weight: 800; font-family: 'Fira Code', monospace;
      color: var(--text-primary); letter-spacing: -0.02em; transition: color 0.3s;
    }
    .perps-big-price.flash-green { color: var(--green); }
    .perps-big-price.flash-red { color: var(--red); }
    .perps-topbar-stats {
      display: flex; gap: 14px;
    }
    .perps-stat {
      display: flex; flex-direction: column; align-items: flex-end; gap: 1px;
    }
    .perps-stat-label {
      font-size: 8px; font-weight: 700; color: var(--text-ghost);
      letter-spacing: 0.1em; text-transform: uppercase;
    }
    .perps-stat-val {
      font-size: 11px; font-weight: 600; font-family: 'Fira Code', monospace; color: var(--text-secondary);
    }

    /* 2-Column Body */
    .perps-body {
      flex: 1; display: flex; overflow: hidden;
    }

    /* Left Column: Chart + Positions */
    .perps-left {
      flex: 1; display: flex; flex-direction: column; overflow: hidden;
      border-right: 1px solid var(--border-primary);
      min-width: 0;
    }
    .perps-chart-section {
      flex: 1; display: flex; flex-direction: column; min-height: 0;
    }
    .perps-chart-toolbar {
      display: flex; justify-content: space-between; align-items: center;
      padding: 6px 12px; background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-primary);
    }
    .perps-tf-group { display: flex; gap: 2px; }
    .perps-tf-btn {
      padding: 4px 10px; font-size: 10px; font-weight: 700; border-radius: 4px;
      background: transparent; border: 1px solid transparent;
      color: var(--text-muted); cursor: pointer; font-family: 'Fira Code', monospace;
      transition: all 0.15s;
    }
    .perps-tf-btn:hover { color: var(--text-primary); background: var(--bg-glass); }
    .perps-tf-btn.active { color: #fbbf24; border-color: rgba(251,191,36,0.3); background: rgba(251,191,36,0.08); }
    .perps-rate-chips { display: flex; gap: 6px; }
    .perps-rate-chip {
      padding: 3px 8px; border-radius: 5px; font-size: 10px; font-weight: 600;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      font-family: 'Fira Code', monospace; color: var(--text-muted);
    }
    .perps-chart-wrap {
      flex: 1; position: relative; overflow: hidden; background: var(--bg-primary); min-height: 300px;
    }

    /* Positions (in right column) */
    .perps-positions-section {
      border-top: 1px solid var(--border-primary); margin-top: 14px;
    }
    .perps-pos-header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 8px 14px; font-size: 10px; font-weight: 700;
      color: var(--text-muted); letter-spacing: 0.1em;
      border-bottom: 1px solid var(--border-primary);
      position: sticky; top: 0; background: var(--bg-secondary); z-index: 1;
    }
    .perps-pos-header button {
      background: none; border: none; color: var(--text-tertiary);
      cursor: pointer; font-family: 'Fira Code', monospace; font-size: 11px;
    }
    .perps-pos-header button:hover { color: #fbbf24; }
    .perps-pos-card {
      margin: 6px 12px; padding: 12px 14px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; font-size: 12px; transition: all 0.2s;
    }
    .perps-pos-card:hover { border-color: var(--border-glow); }
    .perps-pos-top {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;
    }
    .perps-pos-sym {
      font-size: 13px; font-weight: 800; display: flex; align-items: center; gap: 6px;
    }
    .perps-pos-side {
      font-size: 9px; font-weight: 800; padding: 2px 6px; border-radius: 4px; letter-spacing: 0.06em;
    }
    .perps-pos-side.long { background: var(--green-dim); color: var(--green); }
    .perps-pos-side.short { background: var(--red-dim); color: var(--red); }
    .perps-pos-lev {
      font-size: 9px; font-weight: 800; padding: 2px 6px; border-radius: 4px;
      background: rgba(251,191,36,0.1); color: #fbbf24;
    }
    .perps-pos-grid {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px;
    }
    .perps-pos-stat { display: flex; flex-direction: column; gap: 1px; }
    .perps-pos-stat-label {
      font-size: 8px; font-weight: 700; color: var(--text-ghost); letter-spacing: 0.08em; text-transform: uppercase;
    }
    .perps-pos-stat-val {
      font-size: 11px; font-weight: 700; font-family: 'Fira Code', monospace; color: var(--text-secondary);
    }
    .perps-pos-close {
      margin-top: 8px; width: 100%; padding: 7px; background: var(--bg-elevated);
      border: 1px solid var(--border-primary); border-radius: 8px;
      font-size: 10px; font-weight: 700; color: var(--text-muted);
      cursor: pointer; font-family: 'Plus Jakarta Sans', sans-serif; transition: all 0.15s;
    }
    .perps-pos-close:hover {
      border-color: var(--red-border); color: var(--red); background: var(--red-bg);
    }
    .perps-pos-empty {
      padding: 16px; text-align: center; color: var(--text-ghost); font-size: 12px;
    }

    /* Right Column: Order Form */
    .perps-right {
      width: 340px; flex-shrink: 0; overflow-y: auto;
      background: var(--bg-secondary);
    }
    .perps-order-panel { padding: 14px 16px; }

    /* Long/Short Toggle */
    .perps-side-toggle {
      display: flex; gap: 0; margin-bottom: 14px; border-radius: 10px; overflow: hidden;
      border: 1px solid var(--border-primary); background: var(--bg-primary);
    }
    .perps-side-btn {
      flex: 1; padding: 11px; border: none; cursor: pointer;
      font-family: 'Plus Jakarta Sans', sans-serif;
      font-size: 13px; font-weight: 800; letter-spacing: 0.06em;
      transition: all 0.25s; color: var(--text-muted); background: transparent;
    }
    .perps-side-btn.long-active {
      background: linear-gradient(135deg, rgba(52,211,153,0.15), rgba(52,211,153,0.08));
      color: var(--green); box-shadow: inset 0 -2px 0 var(--green);
    }
    .perps-side-btn.short-active {
      background: linear-gradient(135deg, rgba(248,113,113,0.15), rgba(248,113,113,0.08));
      color: var(--red); box-shadow: inset 0 -2px 0 var(--red);
    }
    .perps-side-btn:hover:not(.long-active):not(.short-active) {
      background: var(--bg-glass); color: var(--text-secondary);
    }

    /* Order Type */
    .perps-order-type { display: flex; gap: 4px; margin-bottom: 14px; }
    .perps-otype-btn {
      flex: 1; padding: 7px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 8px; font-size: 11px; font-weight: 700; color: var(--text-muted);
      cursor: pointer; font-family: 'Plus Jakarta Sans', sans-serif; transition: all 0.2s;
    }
    .perps-otype-btn:hover { border-color: var(--border-glow); color: var(--text-secondary); }
    .perps-otype-btn.active {
      background: rgba(251,191,36,0.08); border-color: rgba(251,191,36,0.3); color: #fbbf24;
    }

    /* Leverage Slider */
    .perps-leverage-section { margin-bottom: 14px; }
    .perps-lev-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;
    }
    .perps-lev-label { font-size: 10px; font-weight: 700; color: var(--text-muted); letter-spacing: 0.08em; }
    .perps-lev-val {
      font-size: 16px; font-weight: 800; font-family: 'Fira Code', monospace;
      color: #fbbf24; min-width: 50px; text-align: right;
    }
    .perps-lev-slider-wrap { position: relative; height: 32px; display: flex; align-items: center; }
    .perps-lev-slider {
      -webkit-appearance: none; appearance: none; width: 100%; height: 6px;
      border-radius: 3px; outline: none; cursor: pointer;
      background: linear-gradient(90deg, var(--green) 0%, var(--green) 10%, #fbbf24 10%, #fbbf24 40%, var(--red) 40%, var(--red) 100%);
    }
    .perps-lev-slider::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%;
      background: var(--bg-elevated); border: 3px solid #fbbf24;
      box-shadow: 0 0 10px rgba(251,191,36,0.4), 0 2px 8px rgba(0,0,0,0.4);
      cursor: grab; transition: box-shadow 0.2s;
    }
    .perps-lev-slider::-webkit-slider-thumb:hover {
      box-shadow: 0 0 16px rgba(251,191,36,0.6), 0 2px 12px rgba(0,0,0,0.5);
    }
    .perps-lev-slider::-moz-range-thumb {
      width: 20px; height: 20px; border-radius: 50%;
      background: var(--bg-elevated); border: 3px solid #fbbf24;
      box-shadow: 0 0 10px rgba(251,191,36,0.4); cursor: grab;
    }
    .perps-lev-presets { display: flex; gap: 4px; margin-top: 6px; }
    .perps-lev-preset {
      flex: 1; padding: 5px; font-size: 10px; font-weight: 700; border-radius: 6px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      color: var(--text-muted); cursor: pointer; font-family: 'Fira Code', monospace;
      text-align: center; transition: all 0.15s;
    }
    .perps-lev-preset:hover { border-color: rgba(251,191,36,0.3); color: #fbbf24; }
    .perps-lev-preset.active { background: rgba(251,191,36,0.1); border-color: rgba(251,191,36,0.4); color: #fbbf24; }

    /* Collateral Input */
    .perps-input-section { margin-bottom: 12px; }
    .perps-input-label {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;
    }
    .perps-input-label span { font-size: 10px; font-weight: 700; color: var(--text-muted); letter-spacing: 0.08em; }
    .perps-input-label .bal { font-size: 10px; color: var(--text-faint); font-family: 'Fira Code', monospace; }
    .perps-input-wrap {
      position: relative; display: flex; align-items: center;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; overflow: hidden; transition: border-color 0.2s;
    }
    .perps-input-wrap:focus-within { border-color: rgba(251,191,36,0.3); }
    .perps-input-wrap input {
      flex: 1; padding: 12px 14px; background: none; border: none; outline: none;
      font-size: 16px; font-weight: 700; font-family: 'Fira Code', monospace;
      color: var(--text-primary);
    }
    .perps-input-wrap input::placeholder { color: var(--text-ghost); }
    .perps-input-token {
      padding: 6px 12px; margin-right: 6px; background: var(--bg-elevated);
      border-radius: 8px; font-size: 11px; font-weight: 800; color: var(--text-secondary);
      display: flex; align-items: center; gap: 4px;
    }
    .perps-collat-selector {
      position: relative; margin-right: 6px;
    }
    .perps-collat-selected {
      padding: 8px 10px; background: var(--accent-dim); border-radius: 8px;
      font-size: 12px; font-weight: 800; color: var(--text-primary);
      display: flex; align-items: center; gap: 6px; cursor: pointer;
      border: 1px solid var(--border-glow); transition: all 0.15s;
      user-select: none; white-space: nowrap;
    }
    .perps-collat-selected:hover { background: rgba(34,209,238,0.15); border-color: var(--accent); }
    .perps-collat-selected.open { background: rgba(34,209,238,0.15); border-color: var(--accent); }
    .perps-collat-arrow { font-size: 9px; opacity: 0.7; transition: transform 0.2s; }
    .perps-collat-selected.open .perps-collat-arrow { transform: rotate(180deg); }
    .perps-collat-dropdown {
      position: absolute; top: calc(100% + 4px); right: 0; z-index: 100;
      background: var(--bg-elevated); border: 1px solid var(--border-tertiary);
      border-radius: 10px; padding: 4px; min-width: 130px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5); display: none;
      backdrop-filter: blur(16px);
    }
    .perps-collat-dropdown.open { display: block; }
    .perps-collat-option {
      display: flex; align-items: center; gap: 8px; padding: 9px 12px;
      border-radius: 7px; cursor: pointer; font-size: 12px; font-weight: 700;
      color: var(--text-tertiary); transition: all 0.12s; white-space: nowrap;
    }
    .perps-collat-option:hover { background: var(--accent-dim); color: var(--text-primary); }
    .perps-collat-option.active { background: var(--accent-dim); color: var(--accent); }
    .perps-collat-option .collat-dot {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
    }
    .perps-token-row {
      display: flex; gap: 4px; margin-top: 6px;
    }
    .perps-token-btn {
      flex: 1; padding: 7px 4px; font-size: 10px; font-weight: 700; border-radius: 6px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      color: var(--text-muted); cursor: pointer; font-family: 'Plus Jakarta Sans', sans-serif;
      text-align: center; transition: all 0.15s; display: flex; align-items: center;
      justify-content: center; gap: 4px;
    }
    .perps-token-btn:hover { border-color: var(--border-glow); color: var(--text-secondary); }
    .perps-token-btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent-dim); }
    .perps-token-btn .collat-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
    .perps-collat-presets { display: flex; gap: 4px; margin-top: 6px; }
    .perps-collat-preset {
      flex: 1; padding: 6px; font-size: 10px; font-weight: 600; border-radius: 6px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      color: var(--text-muted); cursor: pointer; font-family: 'Fira Code', monospace;
      text-align: center; transition: all 0.15s;
    }
    .perps-collat-preset:hover { border-color: var(--border-glow); color: var(--text-secondary); }

    /* Limit Price Row */
    .perps-limit-row { margin-bottom: 12px; display: none; }
    .perps-limit-row.visible { display: block; }

    /* Order Summary */
    .perps-summary {
      padding: 12px 14px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; margin-bottom: 14px;
    }
    .perps-summary-row {
      display: flex; justify-content: space-between; padding: 5px 0;
      border-bottom: 1px solid var(--border-secondary);
    }
    .perps-summary-row:last-child { border-bottom: none; }
    .perps-summary-row span:first-child { font-size: 11px; color: var(--text-muted); }
    .perps-summary-row span:last-child {
      font-size: 11px; font-weight: 700; font-family: 'Fira Code', monospace; color: var(--text-primary);
    }
    .perps-summary-row .liq-price { color: var(--red); }
    .perps-summary-row .pos-size { color: #fbbf24; }

    /* Execute Button */
    .perps-exec {
      width: 100%; padding: 14px; border: none; border-radius: 10px;
      font-size: 14px; font-weight: 800; cursor: pointer;
      font-family: 'Plus Jakarta Sans', sans-serif;
      letter-spacing: 0.04em; transition: all 0.2s;
      margin-bottom: 12px; position: relative; overflow: hidden; z-index: 5;
    }
    .perps-exec::before {
      content: ''; position: absolute; inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), transparent);
      opacity: 0; transition: opacity 0.2s; pointer-events: none;
    }
    .perps-exec:hover::before { opacity: 1; }
    .perps-exec:disabled { opacity: 0.35; cursor: not-allowed; }
    .perps-exec.long-btn {
      background: linear-gradient(135deg, #059669, #34d399); color: #fff;
      box-shadow: 0 4px 16px rgba(52,211,153,0.15);
    }
    .perps-exec.long-btn:hover:not(:disabled) { box-shadow: 0 6px 24px rgba(52,211,153,0.3); }
    .perps-exec.short-btn {
      background: linear-gradient(135deg, #dc2626, #f87171); color: #fff;
      box-shadow: 0 4px 16px rgba(248,113,113,0.15);
    }
    .perps-exec.short-btn:hover:not(:disabled) { box-shadow: 0 6px 24px rgba(248,113,113,0.3); }

    /* Info Banner */
    .perps-info {
      padding: 10px 12px; border-radius: 8px;
      background: rgba(251,191,36,0.04); border: 1px solid rgba(251,191,36,0.12);
      font-size: 10px; color: var(--text-muted); line-height: 1.5;
    }
    .perps-info a { color: #fbbf24; text-decoration: none; }
    .perps-info a:hover { text-decoration: underline; }

    /* ═══════ JUPITER BROWSER MODAL ═══════ */
    .jup-overlay {
      position: fixed; inset: 0; z-index: 9999;
      background: rgba(0,0,0,0.7); backdrop-filter: blur(8px);
      display: flex; align-items: center; justify-content: center;
      animation: fadeIn 0.2s ease;
    }
    .jup-win {
      width: 92%; max-width: 520px; 
      background: var(--bg-secondary); border-radius: 16px;
      border: 1px solid var(--border-tertiary);
      box-shadow: 0 24px 80px rgba(0,0,0,0.5), 0 0 0 1px rgba(34,209,238,0.08);
      display: flex; flex-direction: column; overflow: hidden;
      animation: jupIn 0.25s ease;
    }
    @keyframes jupIn {
      from { opacity: 0; transform: scale(0.95) translateY(12px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }
    .jup-bar {
      display: flex; align-items: center; gap: 10px;
      padding: 12px 16px; background: var(--bg-elevated);
      border-bottom: 1px solid var(--border-primary);
    }
    .jup-dot { width: 10px; height: 10px; border-radius: 50%; }
    .jup-dot.r { background: #f87171; cursor: pointer; transition: background 0.15s; }
    .jup-dot.r:hover { background: #ef4444; }
    .jup-dot.y { background: #fbbf24; }
    .jup-dot.g { background: #34d399; }
    .jup-url {
      flex: 1; padding: 6px 12px; background: var(--bg-primary);
      border: 1px solid var(--border-primary); border-radius: 8px;
      font-size: 11px; font-family: 'Fira Code', monospace;
      color: var(--text-muted); overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
    }
    .jup-url .lk { font-size: 9px; opacity: 0.5; margin-right: 4px; }
    .jup-body { padding: 24px 20px; }
    
    /* Order Briefing Card */
    .jup-brief { text-align: center; }
    .jup-brief-icon { font-size: 36px; margin-bottom: 12px; }
    .jup-brief-title {
      font-size: 11px; font-weight: 800; letter-spacing: 0.1em;
      color: var(--text-muted); margin-bottom: 16px;
    }
    .jup-order-card {
      background: var(--bg-primary); border: 1px solid var(--border-tertiary);
      border-radius: 14px; padding: 20px; margin-bottom: 16px;
    }
    .jup-order-header {
      display: flex; align-items: center; justify-content: center; gap: 10px;
      margin-bottom: 16px; padding-bottom: 14px;
      border-bottom: 1px solid var(--border-primary);
    }
    .jup-order-side {
      font-size: 13px; font-weight: 800; letter-spacing: 0.06em;
      padding: 4px 14px; border-radius: 6px;
    }
    .jup-order-side.long { background: var(--green-dim); color: var(--green); border: 1px solid var(--green-border); }
    .jup-order-side.short { background: var(--red-dim); color: var(--red); border: 1px solid var(--red-border); }
    .jup-order-market {
      font-size: 18px; font-weight: 800; color: var(--text-primary);
      font-family: 'Fira Code', monospace;
    }
    .jup-order-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
    }
    .jup-order-item {
      background: var(--bg-elevated); border-radius: 10px; padding: 12px;
      text-align: center;
    }
    .jup-order-item.full { grid-column: 1 / -1; }
    .jup-order-label {
      font-size: 9px; font-weight: 700; letter-spacing: 0.08em;
      color: var(--text-ghost); margin-bottom: 4px;
    }
    .jup-order-val {
      font-size: 18px; font-weight: 800; color: var(--text-primary);
      font-family: 'Fira Code', monospace;
    }
    .jup-order-val.accent { color: var(--accent); }
    .jup-order-val.green { color: var(--green); }
    .jup-order-unit {
      font-size: 10px; font-weight: 600; color: var(--text-muted); margin-left: 4px;
    }
    .jup-steps {
      display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;
      text-align: left;
    }
    .jup-step {
      display: flex; align-items: center; gap: 10px;
      font-size: 12px; color: var(--text-secondary); line-height: 1.4;
    }
    .jup-step-num {
      width: 22px; height: 22px; border-radius: 50%; flex-shrink: 0;
      display: flex; align-items: center; justify-content: center;
      font-size: 10px; font-weight: 800;
      background: var(--accent-dim); color: var(--accent); border: 1px solid rgba(34,209,238,0.2);
    }
    .jup-go-btn {
      width: 100%; padding: 14px; border: none; border-radius: 12px;
      font-size: 14px; font-weight: 800; cursor: pointer;
      font-family: 'Plus Jakarta Sans', sans-serif;
      letter-spacing: 0.04em; transition: all 0.2s;
      display: flex; align-items: center; justify-content: center; gap: 8px;
      position: relative; overflow: hidden;
    }
    .jup-go-btn.long {
      background: linear-gradient(135deg, #059669, #34d399); color: #fff;
      box-shadow: 0 4px 20px rgba(52,211,153,0.25);
    }
    .jup-go-btn.short {
      background: linear-gradient(135deg, #dc2626, #f87171); color: #fff;
      box-shadow: 0 4px 20px rgba(248,113,113,0.25);
    }
    .jup-go-btn:hover { transform: translateY(-1px); filter: brightness(1.1); }
    .jup-go-btn:active { transform: translateY(0); }
    .jup-footer {
      padding: 10px 16px; background: var(--bg-elevated);
      border-top: 1px solid var(--border-primary);
      display: flex; align-items: center; justify-content: space-between;
      font-size: 10px; color: var(--text-ghost);
    }
    .jup-footer .live { color: var(--green); font-weight: 600; }

    /* Responsive: stack on small screens */
    @media (max-width: 768px) {
      .perps-body { flex-direction: column; }
      .perps-right { width: 100%; border-top: 1px solid var(--border-primary); }
      .perps-left { border-right: none; }
      .perps-chart-wrap { min-height: 250px; }
      .perps-topbar { flex-wrap: wrap; gap: 8px; }
      .perps-topbar-markets { order: 10; width: 100%; }
      .perps-topbar-right { gap: 10px; }
      .perps-topbar-stats { display: none; }
      .perps-pos-grid { grid-template-columns: repeat(3, 1fr); }

      /* ═══ MOBILE: HEADER ═══ */
      .header {
        flex-wrap: wrap; height: auto; padding: 8px 10px; gap: 6px;
      }
      .logo-area { gap: 6px; }
      .logo-text { font-size: 13px; }
      .logo-sub { display: none; }
      .logo-icon { font-size: 18px; }
      .sbadge { font-size: 8px; padding: 3px 8px; }

      /* ═══ MOBILE: MODE BAR — scrollable ═══ */
      .mode-bar {
        order: 10; width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch;
        scrollbar-width: none; gap: 0; flex-shrink: 0;
      }
      .mode-bar::-webkit-scrollbar { display: none; }
      .mode-btn { padding: 5px 10px; font-size: 11px; white-space: nowrap; flex-shrink: 0; }
      .mode-btn .ic { font-size: 11px; }
      .new-chat-btn { padding: 5px 8px; font-size: 12px; }

      /* ═══ MOBILE: HEADER RIGHT ═══ */
      .header-right { gap: 4px; }
      .header-right .theme-toggle { width: 28px; height: 28px; font-size: 14px; }
      .ws-toggle { padding: 4px 8px; font-size: 10px; }
      #ws-label { font-size: 11px; }
      .model-select { font-size: 10px; padding: 4px 6px; max-width: 80px; }
      .wallet-btn { padding: 6px 10px; font-size: 10px; gap: 4px; }
      #wbtn-t { max-width: 70px; overflow: hidden; text-overflow: ellipsis; }

      /* ═══ MOBILE: CHAIN BAR ═══ */
      .chain-bar { padding: 6px 8px; gap: 4px; }
      .chain-btn { font-size: 10px; padding: 5px 10px; }

      /* ═══ MOBILE: SIDEBAR — full width overlay ═══ */
      .sidebar {
        position: fixed !important; top: 0; left: 0; bottom: 0;
        z-index: 100; width: 0 !important;
        transition: width 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .sidebar.open { width: 100vw !important; }
      .sidebar-inner { width: 100vw; position: relative; }
      .sidebar-close-mobile { display: flex; }

      /* ═══ MOBILE: SIDEBAR PANELS ═══ */
      .ph { padding: 12px 14px; font-size: 10px; }
      .ph-back { font-size: 16px; padding: 4px 8px; }
      .lsection { padding: 10px; }
      .lplatform { padding: 10px 12px; }
      .lp-name { font-size: 13px; }
      .lp-desc { font-size: 10px; }
      .lp-tag { font-size: 9px; padding: 2px 6px; }
      .lform { padding: 10px; }
      .fg { margin-bottom: 10px; }
      .fl { font-size: 9px; }
      .fi { font-size: 13px; padding: 10px; }
      .lbtn { font-size: 12px; padding: 12px; }
      .lwarn { font-size: 9px; padding: 10px; }

      /* ═══ MOBILE: TRADE PANEL ═══ */
      .trade-pair { padding: 10px; }
      .tp-name { font-size: 16px; }
      .tp-price { font-size: 14px; }
      .trade-info { padding: 8px; }
      .ti-item { font-size: 10px; }
      .trade-section { padding: 8px 10px; }
      .trade-section .fl { font-size: 9px; }
      .trade-form { padding: 10px; }
      .tslippage-btn { font-size: 10px; padding: 4px 8px; }
      .qbox { padding: 8px 10px; }
      .qrow { font-size: 10px; }
      .qval { font-size: 11px; }

      /* ═══ MOBILE: WALLET PANEL ═══ */
      .wp-avatar { width: 44px; height: 44px; font-size: 18px; }
      .wp-balance { font-size: 22px; }
      .wp-actions { gap: 6px; }
      .wp-action-btn { padding: 8px 14px; font-size: 11px; }
      .wp-holding { padding: 10px 12px; }
      .wp-holding-icon { width: 32px; height: 32px; font-size: 14px; }
      .wp-holding-name { font-size: 12px; }
      .wp-holding-amt { font-size: 12px; }
      .wp-holding-val { font-size: 10px; }

      /* ═══ MOBILE: TOOLS CARDS ═══ */
      .tcard { padding: 12px; margin: 6px 10px; }
      .tcard-n { font-size: 13px; }
      .tcard-d { font-size: 10px; }
      .tcard-s { font-size: 8px; padding: 2px 6px; }

      /* ═══ MOBILE: CHAT AREA ═══ */
      .messages { padding: 12px 10px; }
      .message { max-width: 95%; padding: 10px 12px; font-size: 13px; }

      /* ═══ MOBILE: QUICK TRADE ═══ */
      .qt-section { padding: 8px 10px; }
      .qt-buy-btn, .qt-sell-btn { font-size: 9px; padding: 7px 1px; }
      .qt-label { font-size: 7px; }
      .mh { margin-bottom: 4px; }
      .mr { font-size: 9px; }
      .mt { font-size: 8px; }
      .edesc { font-size: 12px; max-width: 100%; }
      .etitle { font-size: 22px; }
      .eicon { font-size: 36px; }
      .empty-state { padding: 40px 16px; }

      /* ═══ MOBILE: INPUT AREA ═══ */
      .input-area { padding: 8px 10px; }
      .input-box { padding: 8px 10px; border-radius: 12px; }
      #input { font-size: 13px; }
      .pc { font-size: 14px; }
      .send-btn { width: 34px; height: 34px; font-size: 14px; }
      .mode-toggle { padding: 4px 8px; font-size: 10px; }

      /* ═══ MOBILE: FOOTER ═══ */
      .footer { font-size: 8px; padding: 6px 10px; }

      /* ═══ MOBILE: MODALS ═══ */
      .wallet-modal { width: 95vw; padding: 18px; }
      .wallet-option { padding: 12px; }
      .wo-name { font-size: 14px; }
      .wo-status { font-size: 10px; }
      .wo-chains { gap: 4px; }
      .wo-chain-tag { font-size: 8px; padding: 2px 5px; }

      /* ═══ MOBILE: TOAST ═══ */
      .toast { left: 10px; right: 10px; transform: none; max-width: none; font-size: 11px; }

      /* ═══ MOBILE: PORTFOLIO ═══ */
      .portfolio-header { padding: 10px 12px; }
      .portfolio-total-val { font-size: 22px; }
      .portfolio-holding { padding: 10px 12px; }

      /* ═══ MOBILE: ALPHA BOT ═══ */
      .alpha-wallet { padding: 10px 12px; }
      .alpha-log { font-size: 9px; }

      /* ═══ MOBILE: LAUNCH STEPS ═══ */
      .launch-steps { padding: 10px; }
      .launch-step { padding: 8px 10px; font-size: 11px; }
      .step-num { width: 22px; height: 22px; font-size: 10px; }
    }

    /* ═══════ BUNDLE CHECKER ═══════ */
    .bundle-search { padding: 14px; }
    .bundle-search-row { display: flex; gap: 6px; }
    .bundle-search-btn {
      padding: 10px 16px; background: linear-gradient(135deg, rgba(239,68,68,0.2), rgba(220,38,38,0.15));
      border: 1px solid rgba(239,68,68,0.3); border-radius: 10px;
      color: #f87171; font-size: 11px; font-weight: 800; cursor: pointer;
      font-family: 'Plus Jakarta Sans', sans-serif; letter-spacing: 0.06em;
      transition: all 0.2s; white-space: nowrap;
    }
    .bundle-search-btn:hover { background: rgba(239,68,68,0.25); box-shadow: 0 0 12px rgba(239,68,68,0.15); }
    .bundle-search-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .bundle-empty {
      text-align: center; padding: 40px 20px;
    }
    .bundle-empty-icon { font-size: 36px; margin-bottom: 10px; opacity: 0.4; }
    .bundle-empty-text { font-size: 11px; color: var(--text-muted); line-height: 1.6; }
    .bundle-log {
      padding: 10px 14px; font-size: 10px; color: var(--text-muted);
      font-family: 'Fira Code', monospace; line-height: 1.7;
      max-height: 120px; overflow-y: auto; background: var(--bg-primary);
      border-bottom: 1px solid var(--border-primary);
    }
    .bundle-log-line { display: flex; gap: 6px; align-items: flex-start; }
    .bundle-log-dot {
      width: 5px; height: 5px; border-radius: 50%; margin-top: 5px; flex-shrink: 0;
    }
    .bundle-card {
      margin: 12px 14px; padding: 16px; background: var(--bg-glass);
      border: 1px solid var(--border-primary); border-radius: 12px;
    }
    .bundle-card-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;
    }
    .bundle-token-name { font-size: 14px; font-weight: 800; color: var(--text-primary); }
    .bundle-token-ticker { font-size: 11px; color: var(--text-muted); font-weight: 600; }
    .bundle-score-wrap { text-align: center; }
    .bundle-score {
      width: 56px; height: 56px; border-radius: 50%; display: flex; align-items: center;
      justify-content: center; font-size: 18px; font-weight: 900;
      font-family: 'Fira Code', monospace; margin: 0 auto 4px;
    }
    .bundle-score.safe { background: var(--green-dim); color: var(--green); border: 2px solid var(--green-border); }
    .bundle-score.warn { background: var(--yellow-dim); color: var(--yellow); border: 2px solid var(--yellow-border); }
    .bundle-score.danger { background: var(--red-dim); color: var(--red); border: 2px solid var(--red-border); }
    .bundle-score-label {
      font-size: 9px; font-weight: 800; letter-spacing: 0.1em;
    }
    .bundle-score-label.safe { color: var(--green); }
    .bundle-score-label.warn { color: var(--yellow); }
    .bundle-score-label.danger { color: var(--red); }

    .bundle-section {
      margin: 12px 14px; padding: 12px;
      background: var(--bg-glass); border: 1px solid var(--border-primary); border-radius: 10px;
    }
    .bundle-stitle {
      font-size: 9px; font-weight: 800; color: var(--text-muted);
      letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 8px;
      display: flex; align-items: center; gap: 6px;
    }
    .bundle-flag {
      display: flex; align-items: flex-start; gap: 8px; padding: 7px 0;
      border-bottom: 1px solid var(--border-secondary); font-size: 11px;
    }
    .bundle-flag:last-child { border-bottom: none; }
    .bundle-flag-icon { font-size: 14px; flex-shrink: 0; margin-top: -1px; }
    .bundle-flag-text { color: var(--text-secondary); line-height: 1.4; }
    .bundle-flag-text strong { color: var(--text-primary); }

    .bundle-stat-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
    }
    .bundle-stat {
      padding: 8px 10px; background: var(--bg-elevated); border-radius: 8px;
      border: 1px solid var(--border-secondary);
    }
    .bundle-stat-label {
      font-size: 8px; font-weight: 700; color: var(--text-ghost);
      letter-spacing: 0.08em; text-transform: uppercase; margin-bottom: 2px;
    }
    .bundle-stat-val {
      font-size: 13px; font-weight: 800; font-family: 'Fira Code', monospace; color: var(--text-primary);
    }

    .bundle-wallet-row {
      display: flex; align-items: center; gap: 6px; padding: 5px 0;
      border-bottom: 1px solid var(--border-secondary); font-size: 10px;
    }
    .bundle-wallet-row:last-child { border-bottom: none; }
    .bundle-wallet-addr {
      font-family: 'Fira Code', monospace; color: var(--text-secondary);
      cursor: pointer; flex: 1;
    }
    .bundle-wallet-addr:hover { color: var(--accent); }
    .bundle-wallet-pct {
      font-weight: 800; font-family: 'Fira Code', monospace; min-width: 45px; text-align: right;
    }
    .bundle-wallet-tag {
      font-size: 7px; font-weight: 800; padding: 1px 4px; border-radius: 3px;
      letter-spacing: 0.06em;
    }
    .bundle-wallet-tag.new { background: var(--red-dim); color: var(--red); }
    .bundle-wallet-tag.old { background: var(--green-dim); color: var(--green); }
    .bundle-wallet-tag.bundled { background: rgba(251,191,36,0.1); color: #fbbf24; }

    .bundle-verdict {
      margin: 12px 14px; padding: 14px 16px; border-radius: 10px;
      font-size: 12px; line-height: 1.6; font-weight: 600;
    }
    .bundle-verdict.safe {
      background: var(--green-dim); border: 1px solid var(--green-border); color: var(--green);
    }
    .bundle-verdict.warn {
      background: var(--yellow-dim); border: 1px solid var(--yellow-border); color: var(--yellow);
    }
    .bundle-verdict.danger {
      background: var(--red-dim); border: 1px solid var(--red-border); color: var(--red);
    }

    /* ═══════ TRADE PANEL ═══════ */
    .trade-section { padding: 14px; }
    .trade-amt-row {
      display: flex; gap: 4px; margin-bottom: 14px;
    }
    .trade-preset {
      flex: 1; padding: 8px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 8px; font-size: 12px; font-weight: 600; color: var(--text-secondary);
      cursor: pointer; font-family: 'Fira Code', monospace;
    }
    .trade-preset:hover { border-color: var(--border-glow); color: var(--accent); }
    .trade-preset.sel { background: var(--accent-dim); border-color: var(--accent); color: var(--accent); }
    .trade-settings { display: flex; gap: 8px; margin-bottom: 12px; }
    .trade-settings .fg { flex: 1; margin-bottom: 0; }
    .trade-quote {
      padding: 12px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; margin-bottom: 12px; font-size: 12px;
    }
    .tq-row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border-secondary); }
    .tq-row:last-child { border-bottom: none; }
    .tq-row span:first-child { color: var(--text-muted); }
    .tq-val { color: var(--text-primary); font-weight: 600; font-family: 'Fira Code', monospace; font-size: 11px; }
    .trade-exec {
      width: 100%; padding: 13px; border: none; border-radius: 10px;
      font-size: 14px; font-weight: 700; cursor: pointer; font-family: inherit;
      margin-bottom: 6px; letter-spacing: 0.03em;
    }
    .trade-exec:disabled { opacity: 0.35; cursor: not-allowed; }
    .trade-buy { background: linear-gradient(135deg, #059669, #34d399); color: #fff; }
    .trade-buy:hover:not(:disabled) { box-shadow: 0 4px 16px rgba(52,211,153,0.25); }
    .trade-sell { background: linear-gradient(135deg, #dc2626, #f87171); color: #fff; }
    .trade-sell:hover:not(:disabled) { box-shadow: 0 4px 16px rgba(248,113,113,0.25); }
    .trade-divider { border: none; border-top: 1px solid var(--border-secondary); margin: 0; }
    .pos-header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 14px; font-size: 10px; font-weight: 700; color: var(--text-muted);
      letter-spacing: 0.1em;
    }
    .pos-header button {
      background: none; border: none; color: var(--text-tertiary);
      cursor: pointer; font-family: 'Fira Code', monospace; font-size: 11px;
    }
    .pos-header button:hover { color: var(--accent); }
    .pos-card {
      margin: 0 14px 6px; padding: 10px 12px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; font-size: 12px;
    }
    .pos-card:hover { border-color: var(--border-glow); }
    .pos-top { display: flex; justify-content: space-between; align-items: center; }
    .pos-sym { font-weight: 700; font-size: 13px; }
    .pos-bottom { display: flex; justify-content: space-between; margin-top: 4px; font-size: 11px; color: var(--text-muted); }
    .pos-empty { padding: 24px 14px; text-align: center; color: var(--text-muted); font-size: 12px; }
    .trade-history { max-height: 180px; overflow-y: auto; }
    .th-item {
      display: flex; align-items: center; gap: 8px; padding: 8px 14px;
      font-size: 12px; border-bottom: 1px solid var(--border-secondary);
    }
    .th-action { font-weight: 700; font-size: 10px; letter-spacing: 0.05em; padding: 2px 6px; border-radius: 4px; }
    .th-buy { background: var(--green-dim); color: var(--green); }
    .th-sell { background: var(--red-dim); color: var(--red); }
    .th-details { flex: 1; color: var(--text-secondary); font-family: 'Fira Code', monospace; font-size: 11px; }
    .th-time { color: var(--text-muted); font-size: 10px; }

    /* ═══════ CHAT AREA ═══════ */
    .chat-area { flex: 1; overflow-y: auto; padding: 20px 0; display: flex; flex-direction: column; }
    .messages { flex: 1; overflow-y: auto; padding: 16px 20px; scroll-behavior: smooth; }

    .empty-state {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 100%; text-align: center; animation: fadeIn 0.6s ease;
    }
    .eicon {
      font-size: 48px; color: var(--accent); margin-bottom: 16px;
      filter: drop-shadow(0 0 20px rgba(34,209,238,0.3));
      animation: breathe 4s ease-in-out infinite;
    }
    .etitle {
      font-size: 28px; font-weight: 800; margin-bottom: 10px;
      background: var(--accent-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; letter-spacing: 0.02em;
    }
    .edesc { font-size: 14px; color: var(--text-muted); max-width: 420px; line-height: 1.6; }

    .message {
      padding: 14px 18px; border-radius: 14px; margin-bottom: 10px;
      animation: slideIn 0.25s ease; line-height: 1.65; font-size: 14px;
      max-width: 85%;
    }
    .message.user {
      background: var(--msg-user); border: 1px solid var(--border-primary);
      margin-left: auto; border-radius: 14px 14px 4px 14px;
    }
    .message.assistant {
      background: var(--msg-ai-bg); border: 1px solid var(--msg-ai-border);
      border-left: 3px solid var(--accent); border-radius: 4px 14px 14px 14px;
    }
    .message.system {
      background: var(--msg-system-bg); border: 1px solid var(--msg-system-border);
      border-left: 3px solid var(--yellow); font-size: 13px;
    }
    .message.success {
      background: var(--msg-success-bg); border: 1px solid var(--msg-success-border);
      border-left: 3px solid var(--green); font-size: 13px;
    }
    .message.error {
      background: var(--red-bg); border: 1px solid var(--red-border);
      border-left: 3px solid var(--red); font-size: 13px;
    }

    .mh {
      display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
      font-size: 11px; font-weight: 700; letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .mt { color: var(--text-faint); font-weight: 500; font-size: 10px; letter-spacing: 0; text-transform: none; }
    .mr { font-family: 'Fira Code', monospace; }

    .message a { color: var(--accent); text-decoration: none; font-weight: 600; }
    .message a:hover { text-decoration: underline; }
    .message code {
      background: rgba(34,209,238,0.08); padding: 2px 6px; border-radius: 4px;
      font-family: 'Fira Code', monospace; font-size: 0.9em; color: var(--accent);
    }
    .message strong { color: var(--text-primary); font-weight: 700; }
    .message .streaming-cursor { animation: blink 0.8s infinite; color: var(--accent); font-weight: 300; }

    /* ═══════ INPUT AREA ═══════ */
    .input-area {
      padding: 14px 20px; border-top: 1px solid var(--border-primary);
      background: var(--bg-glass);
      backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
    }
    .input-box {
      display: flex; align-items: center; gap: 10px;
      padding: 10px 14px;
      background: var(--bg-glass); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border: 1px solid var(--border-primary); border-radius: 14px;
    }
    .input-box:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-dim), 0 4px 20px rgba(34,209,238,0.06);
    }
    .pc { font-size: 16px; color: var(--accent); font-weight: 700; }
    #input {
      flex: 1; background: none; border: none; outline: none;
      font-size: 14px; color: var(--text-primary); font-family: inherit;
      font-weight: 500;
    }
    #input::placeholder { color: var(--text-faint); font-weight: 400; }
    .send-btn {
      padding: 8px 14px;
      background: var(--accent-gradient-btn); border: none;
      border-radius: 8px; color: #fff; font-weight: 700;
      font-size: 16px; cursor: pointer; font-family: inherit;
      box-shadow: 0 2px 8px rgba(34,209,238,0.15);
    }
    .send-btn:hover { box-shadow: 0 2px 16px rgba(34,209,238,0.3); }
    .send-btn:disabled { opacity: 0.3; cursor: not-allowed; box-shadow: none; }

    .chat-mode-toggle {
      display: flex; background: var(--bg-elevated); border-radius: 8px;
      padding: 2px; gap: 2px; flex-shrink: 0;
      border: 1px solid var(--border-primary);
    }
    .cmt-btn {
      padding: 5px 12px; border: none; border-radius: 7px;
      font-size: 11px; font-weight: 700; cursor: pointer;
      font-family: inherit; letter-spacing: 0.04em;
      background: transparent; color: var(--text-muted);
      display: flex; align-items: center; gap: 5px;
      white-space: nowrap;
    }
    .cmt-btn.active {
      background: var(--bg-surface); color: var(--text-primary);
      box-shadow: 0 1px 4px rgba(0,0,0,0.12);
    }
    .cmt-btn:hover:not(.active) { color: var(--text-secondary); }
    .cmt-dot { width: 5px; height: 5px; border-radius: 50%; }
    .cmt-btn.active .cmt-dot.agent-dot { background: var(--accent); animation: pulse 2s infinite; }
    .cmt-btn.active .cmt-dot.chat-dot { background: var(--green); }

    .lb { display: flex; align-items: center; gap: 5px; font-size: 11px; font-weight: 600; color: var(--green); letter-spacing: 0.08em; }
    .ld { width: 5px; height: 5px; border-radius: 50%; background: var(--green); }

    /* ═══════ FOOTER ═══════ */
    .footer {
      padding: 8px 20px; text-align: center;
      font-size: 10px; color: var(--text-faint); font-weight: 500;
      letter-spacing: 0.06em; border-top: 1px solid var(--border-secondary);
    }
    .footer .g { color: var(--accent); font-weight: 600; }

    /* ═══════ TOAST ═══════ */
    .toast {
      position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%) translateY(20px);
      padding: 10px 20px;
      background: var(--bg-glass); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-tertiary);
      border-radius: 12px; font-size: 13px; font-weight: 600; color: var(--text-primary);
      opacity: 0; z-index: 999;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

    /* ═══════ KEY MODAL ═══════ */
    .key-overlay {
      position: fixed; inset: 0; z-index: 100;
      display: flex; align-items: center; justify-content: center;
      background: rgba(6,9,16,0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      animation: fadeIn 0.25s ease;
    }
    .key-modal {
      background: var(--bg-elevated); border: 1px solid var(--border-tertiary);
      border-radius: 20px; padding: 32px; width: 420px; max-width: 90vw;
      box-shadow: 0 24px 64px rgba(0,0,0,0.5), 0 0 40px rgba(34,209,238,0.04);
      animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .key-modal-icon {
      width: 48px; height: 48px; border-radius: 14px;
      background: var(--accent-dim); border: 1px solid rgba(34,209,238,0.15);
      display: flex; align-items: center; justify-content: center;
      font-size: 22px; margin-bottom: 18px;
    }
    .key-modal h3 {
      font-size: 18px; font-weight: 800; margin-bottom: 8px; letter-spacing: 0.01em;
      color: var(--text-primary);
    }
    .key-modal p {
      font-size: 13px; color: var(--text-tertiary); margin-bottom: 20px;
      line-height: 1.6;
    }
    .key-modal input {
      width: 100%; padding: 12px 14px;
      background: var(--bg-glass); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      border: 1px solid var(--border-primary); border-radius: 10px;
      color: var(--text-primary); font-family: 'Fira Code', monospace; font-size: 13px;
    }
    .key-modal input:focus {
      outline: none; border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-dim);
    }
    .key-modal input::placeholder { color: var(--text-faint); }
    .key-btns { display: flex; gap: 10px; margin-top: 20px; }
    .key-cancel {
      padding: 11px 20px; background: var(--bg-glass);
      border: 1px solid var(--border-tertiary); border-radius: 10px;
      color: var(--text-secondary); cursor: pointer; font-family: inherit;
      font-size: 13px; font-weight: 600;
    }
    .key-cancel:hover { border-color: var(--border-glow); color: var(--text-primary); }
    .key-save {
      flex: 1; padding: 11px; background: var(--accent-gradient-btn);
      border: none; border-radius: 10px; color: #fff; font-weight: 700;
      cursor: pointer; font-family: inherit; font-size: 13px;
      box-shadow: 0 2px 12px rgba(34,209,238,0.2);
    }
    .key-save:hover { box-shadow: 0 4px 20px rgba(34,209,238,0.35); }

    /* ═══════ WEB SEARCH TOGGLE ═══════ */
    .ws-toggle {
      display: flex; align-items: center; gap: 5px;
      padding: 6px 10px; border-radius: 8px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
      cursor: pointer; font-family: inherit; font-size: 11px; font-weight: 600;
      color: var(--text-muted); white-space: nowrap;
    }
    .ws-toggle:hover { border-color: var(--border-glow); color: var(--text-secondary); }
    .ws-toggle.on { background: var(--green-bg); border-color: var(--green-border); color: var(--green); }
    .ws-toggle .ws-dot {
      width: 5px; height: 5px; border-radius: 50%;
      background: var(--text-muted);
    }
    .ws-toggle.on .ws-dot { background: var(--green); animation: pulse 2s infinite; }

    /* ═══════ NEW CHAT BUTTON ═══════ */
    .new-chat-btn {
      background: none; border: 1px solid var(--border-primary); color: var(--text-muted);
      width: 32px; height: 32px; border-radius: 8px; cursor: pointer; font-size: 18px;
      display: flex; align-items: center; justify-content: center;
    }
    .new-chat-btn:hover { border-color: var(--border-glow); color: var(--accent); background: var(--accent-dim); }

    /* ═══════ HISTORY PANEL ═══════ */
    .hist-tabs {
      display: flex; gap: 0; margin: 12px 14px; border-radius: 10px; overflow: hidden;
      border: 1px solid var(--border-primary);
    }
    .hist-tab {
      flex: 1; padding: 10px 0; text-align: center; font-size: 11px; font-weight: 700;
      font-family: inherit; letter-spacing: 0.06em; cursor: pointer;
      background: var(--bg-glass); color: var(--text-muted); border: none;
    }
    .hist-tab:first-child { border-right: 1px solid var(--border-primary); }
    .hist-tab:nth-child(2) { border-right: 1px solid var(--border-primary); }
    .hist-tab.active {
      background: var(--accent-gradient-btn); color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    .hist-tab:hover:not(.active) { color: var(--text-primary); }

    .hist-list { padding: 0 14px; }

    .chat-card {
      padding: 14px; background: var(--bg-glass); border-radius: 12px;
      border: 1px solid var(--border-primary); margin-bottom: 8px; cursor: pointer;
      position: relative; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    .chat-card:hover { border-color: var(--border-glow); box-shadow: 0 2px 12px rgba(34,209,238,0.04); }
    .chat-card.active-session { border-color: var(--accent); background: var(--accent-dim); }
    .chat-card-title {
      font-size: 13px; font-weight: 700; color: var(--text-primary);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      padding-right: 24px;
    }
    .chat-card-meta {
      font-size: 10px; color: var(--text-muted); margin-top: 5px;
      display: flex; justify-content: space-between; align-items: center;
      font-family: 'Fira Code', monospace;
    }
    .chat-card-del {
      position: absolute; top: 12px; right: 12px;
      background: none; border: none; color: var(--text-faint); cursor: pointer;
      font-size: 13px; padding: 2px 5px; border-radius: 4px;
      opacity: 0;
    }
    .chat-card:hover .chat-card-del { opacity: 1; }
    .chat-card-del:hover { color: var(--red); background: var(--red-dim); }

    .tx-card {
      padding: 12px 14px; background: var(--bg-glass); border-radius: 10px;
      border: 1px solid var(--border-primary); margin-bottom: 6px;
    }
    .tx-card-top {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;
    }
    .tx-badge {
      font-size: 9px; font-weight: 800; padding: 3px 8px; border-radius: 5px;
      letter-spacing: 0.06em;
    }
    .tx-buy { background: var(--green-dim); color: var(--green); }
    .tx-sell { background: var(--red-dim); color: var(--red); }
    .tx-time { font-size: 10px; color: var(--text-muted); font-family: 'Fira Code', monospace; }
    .tx-detail { font-size: 12px; color: var(--text-secondary); font-family: 'Fira Code', monospace; }
    .tx-sig {
      font-size: 10px; color: var(--accent); cursor: pointer; margin-top: 4px;
      display: inline-block; opacity: 0.8; font-family: 'Fira Code', monospace;
    }
    .tx-sig:hover { opacity: 1; text-decoration: underline; }

    .hist-empty {
      text-align: center; padding: 40px 20px; color: var(--text-muted); font-size: 13px;
    }
    .hist-empty-icon { font-size: 28px; margin-bottom: 10px; }

    /* ═══════ SNIPER BOT ═══════ */
    .sniper-toggle-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 14px; margin: 12px 14px; background: var(--bg-glass);
      border: 1px solid var(--border-primary); border-radius: 12px;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    .sniper-toggle-label { font-size: 13px; font-weight: 700; color: var(--text-primary); }
    .sniper-toggle-sub { font-size: 11px; color: var(--text-muted); margin-top: 3px; }
    .sniper-switch {
      width: 44px; height: 24px; border-radius: 12px; border: none;
      background: var(--border-tertiary); cursor: pointer; position: relative;
    }
    .sniper-switch.on { background: var(--green); box-shadow: 0 0 12px rgba(52,211,153,0.3); }
    .sniper-switch::after {
      content: ''; position: absolute; top: 2px; left: 2px;
      width: 20px; height: 20px; border-radius: 50%;
      background: #fff; transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .sniper-switch.on::after { transform: translateX(20px); }

    .sniper-wallets { padding: 0 14px; }
    .sniper-wallet {
      padding: 14px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 12px; margin-bottom: 8px; position: relative;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    .sw-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .sw-label { font-size: 11px; font-weight: 700; color: var(--accent); letter-spacing: 0.06em; }
    .sw-remove {
      background: none; border: none; color: var(--text-faint); cursor: pointer;
      font-size: 13px; padding: 2px 6px; border-radius: 4px;
    }
    .sw-remove:hover { color: var(--red); background: var(--red-dim); }
    .sw-addr {
      font-size: 10px; color: var(--text-muted); font-family: 'Fira Code', monospace;
      margin-bottom: 8px; word-break: break-all;
    }
    .sw-bal-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .sw-bal { font-size: 12px; font-weight: 600; color: var(--text-secondary); font-family: 'Fira Code', monospace; }
    .sw-bal-refresh {
      background: none; border: none; color: var(--text-faint); cursor: pointer; font-size: 12px;
    }
    .sw-amt-row { display: flex; gap: 6px; align-items: center; }
    .sw-amt-row .fi { font-size: 12px; padding: 8px 10px; }
    .sw-amt-label { font-size: 10px; color: var(--text-muted); white-space: nowrap; font-weight: 600; }
    .sw-status {
      font-size: 11px; margin-top: 8px; padding: 5px 10px; border-radius: 6px; display: none;
    }
    .sw-status.show { display: block; }
    .sw-status.success { background: var(--green-dim); color: var(--green); }
    .sw-status.error { background: var(--red-dim); color: var(--red); }
    .sw-status.pending { background: var(--yellow-bg); color: var(--yellow); }

    .sniper-add {
      width: calc(100% - 28px); margin: 0 14px 12px; padding: 12px;
      background: var(--bg-glass); border: 2px dashed var(--border-tertiary);
      border-radius: 12px; color: var(--text-muted); font-size: 13px; font-weight: 700;
      cursor: pointer; font-family: inherit; text-align: center;
    }
    .sniper-add:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-dim); }
    .sniper-add:disabled { opacity: 0.3; cursor: not-allowed; }
    .sniper-add:disabled:hover { border-color: var(--border-tertiary); color: var(--text-muted); background: transparent; }

    .sniper-import {
      padding: 14px; margin: 0 14px 12px; background: var(--bg-glass);
      border: 1px solid var(--border-primary); border-radius: 12px; display: none;
    }
    .sniper-import.show { display: block; }
    .sniper-import .fi { font-size: 11px; margin-bottom: 10px; }
    .sniper-import-btns { display: flex; gap: 6px; }
    .sniper-import-btns button {
      flex: 1; padding: 9px; border: none; border-radius: 8px; font-size: 11px;
      font-weight: 700; cursor: pointer; font-family: inherit;
    }
    .si-gen { background: var(--accent-gradient-btn); color: #fff; }
    .si-gen:hover { box-shadow: 0 2px 12px rgba(34,209,238,0.2); }
    .si-import {
      background: var(--bg-elevated); color: var(--text-secondary);
      border: 1px solid var(--border-tertiary) !important;
    }
    .si-cancel {
      background: var(--bg-elevated); color: var(--text-muted);
      border: 1px solid var(--border-tertiary) !important;
    }

    .sniper-warn {
      margin: 0 14px 12px; padding: 12px; background: var(--yellow-bg);
      border: 1px solid var(--yellow-border); border-radius: 10px;
      font-size: 11px; color: var(--yellow); line-height: 1.6;
    }

    /* ═══════ TOKEN INTEL PANEL ═══════ */
    .intel-search { padding: 14px; }
    .intel-search-row { display: flex; gap: 8px; }
    .intel-search-row .fi { flex: 1; }
    .intel-search-btn {
      padding: 0 16px; background: var(--accent-gradient-btn); border: none;
      border-radius: 10px; color: #fff; font-weight: 700; cursor: pointer;
      font-family: inherit; font-size: 12px; white-space: nowrap;
    }
    .intel-search-btn:hover { box-shadow: 0 2px 12px rgba(34,209,238,0.25); }
    .intel-card {
      margin: 0 14px 10px; padding: 14px; background: var(--bg-glass);
      border: 1px solid var(--border-primary); border-radius: 12px;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    .intel-card-title {
      font-size: 9px; font-weight: 700; letter-spacing: 0.1em;
      color: var(--text-muted); margin-bottom: 10px; text-transform: uppercase;
    }
    .intel-hero { text-align: center; padding: 4px 0 8px; }
    .intel-hero-name { font-size: 18px; font-weight: 800; margin-bottom: 2px; }
    .intel-hero-ticker { font-size: 12px; color: var(--accent); font-weight: 600; }
    .intel-hero-price {
      font-size: 24px; font-weight: 800; margin: 8px 0 4px;
      font-family: 'Fira Code', monospace;
    }
    .intel-hero-change { font-size: 12px; font-weight: 700; }
    .intel-hero-change.up { color: var(--green); }
    .intel-hero-change.down { color: var(--red); }
    .intel-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .intel-stat {
      padding: 8px; background: var(--bg-elevated); border-radius: 8px;
      border: 1px solid var(--border-secondary);
    }
    .intel-stat-label {
      font-size: 8px; font-weight: 700; letter-spacing: 0.08em;
      color: var(--text-muted); text-transform: uppercase; margin-bottom: 3px;
    }
    .intel-stat-val {
      font-size: 13px; font-weight: 700; color: var(--text-primary);
      font-family: 'Fira Code', monospace;
    }
    .intel-risk {
      display: flex; align-items: center; gap: 12px; padding: 12px;
      background: var(--bg-elevated); border-radius: 10px;
      border: 1px solid var(--border-secondary);
    }
    .intel-risk-score {
      width: 48px; height: 48px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 16px; font-weight: 800; font-family: 'Fira Code', monospace; flex-shrink: 0;
    }
    .risk-low { background: var(--green-dim); color: var(--green); border: 2px solid var(--green-border); }
    .risk-med { background: var(--yellow-dim); color: var(--yellow); border: 2px solid var(--yellow-border); }
    .risk-high { background: var(--red-dim); color: var(--red); border: 2px solid var(--red-border); }
    .intel-risk-label { font-size: 13px; font-weight: 700; }
    .intel-risk-desc { font-size: 11px; color: var(--text-muted); margin-top: 2px; }
    .intel-holder {
      display: flex; align-items: center; padding: 6px 0;
      border-bottom: 1px solid var(--border-secondary); font-size: 11px;
    }
    .intel-holder:last-child { border-bottom: none; }
    .intel-holder-rank { width: 18px; font-size: 10px; font-weight: 700; color: var(--text-muted); }
    .intel-holder-addr {
      flex: 1; font-family: 'Fira Code', monospace; font-size: 10px;
      color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis;
    }
    .intel-holder-pct {
      font-weight: 700; font-family: 'Fira Code', monospace;
      font-size: 11px; margin-left: 8px;
    }
    .intel-links { display: flex; gap: 6px; flex-wrap: wrap; }
    .intel-link {
      padding: 5px 10px; background: var(--bg-elevated); border: 1px solid var(--border-secondary);
      border-radius: 8px; font-size: 10px; font-weight: 600; color: var(--text-secondary);
      cursor: pointer; text-decoration: none; font-family: inherit;
    }
    .intel-link:hover { border-color: var(--border-glow); color: var(--accent); }
    .intel-empty { text-align: center; padding: 40px 20px; color: var(--text-muted); }
    .intel-empty-icon { font-size: 28px; margin-bottom: 10px; }
    .intel-empty-text { font-size: 12px; line-height: 1.5; }

    /* ═══════ PORTFOLIO DASHBOARD ═══════ */
    .portfolio-summary {
      margin: 14px; padding: 18px; background: var(--bg-glass);
      border: 1px solid var(--border-primary); border-radius: 14px;
      backdrop-filter: blur(8px); text-align: center;
    }
    .portfolio-total-label {
      font-size: 9px; font-weight: 700; letter-spacing: 0.1em;
      color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px;
    }
    .portfolio-total {
      font-size: 28px; font-weight: 800; font-family: 'Fira Code', monospace;
      background: var(--accent-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .portfolio-sol {
      font-size: 13px; color: var(--text-secondary); margin-top: 2px;
      font-family: 'Fira Code', monospace;
    }
    .portfolio-row { display: flex; gap: 8px; margin: 0 14px 8px; }
    .portfolio-stat-card {
      flex: 1; padding: 10px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; text-align: center;
    }
    .portfolio-stat-label {
      font-size: 8px; font-weight: 700; letter-spacing: 0.08em;
      color: var(--text-muted); text-transform: uppercase; margin-bottom: 3px;
    }
    .portfolio-stat-val {
      font-size: 14px; font-weight: 700; font-family: 'Fira Code', monospace;
    }
    .portfolio-holding {
      margin: 0 14px 6px; padding: 10px 12px; background: var(--bg-glass);
      border: 1px solid var(--border-primary); border-radius: 10px;
      cursor: pointer; display: flex; align-items: center; gap: 10px;
    }
    .portfolio-holding:hover { border-color: var(--border-glow); }
    .portfolio-holding-icon {
      width: 32px; height: 32px; border-radius: 50%;
      background: var(--accent-dim); display: flex; align-items: center;
      justify-content: center; font-size: 12px; font-weight: 800;
      color: var(--accent); flex-shrink: 0;
    }
    .portfolio-holding-info { flex: 1; min-width: 0; }
    .portfolio-holding-name {
      font-size: 12px; font-weight: 700; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }
    .portfolio-holding-amount {
      font-size: 10px; color: var(--text-muted); font-family: 'Fira Code', monospace;
    }
    .portfolio-holding-right { text-align: right; }
    .portfolio-holding-value {
      font-size: 12px; font-weight: 700; font-family: 'Fira Code', monospace;
    }
    .portfolio-holding-price {
      font-size: 10px; color: var(--text-muted); font-family: 'Fira Code', monospace;
    }

    /* ═══════ PNL ANALYTICS ═══════ */
    .pnl-stats { padding: 14px; }
    .pnl-stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px; }
    .pnl-stat {
      padding: 10px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; text-align: center;
    }
    .pnl-stat-label {
      font-size: 8px; font-weight: 700; letter-spacing: 0.08em;
      color: var(--text-muted); text-transform: uppercase; margin-bottom: 3px;
    }
    .pnl-stat-val {
      font-size: 15px; font-weight: 700; font-family: 'Fira Code', monospace;
    }
    .pnl-stat-big { grid-column: span 2; }
    .pnl-stat-big .pnl-stat-val { font-size: 22px; }
    .pnl-trade {
      padding: 10px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; margin-bottom: 6px; font-size: 11px;
    }
    .pnl-trade-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
    .pnl-trade-pair { font-weight: 700; font-size: 12px; }
    .pnl-trade-side { font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 4px; }
    .pnl-trade-side.buy { background: var(--green-dim); color: var(--green); }
    .pnl-trade-side.sell { background: var(--red-dim); color: var(--red); }
    .pnl-trade-bottom { display: flex; justify-content: space-between; color: var(--text-muted); font-size: 10px; font-family: 'Fira Code', monospace; }

    /* ═══════ ALPHA BOT ═══════ */
    .ph-back {
      background: none; border: none; color: var(--text-muted); cursor: pointer;
      font-size: 14px; padding: 0 6px 0 0; vertical-align: middle; font-family: inherit;
    }
    .ph-back:hover { color: var(--accent); }
    .alpha-status-bar {
      margin: 0 14px 10px; padding: 10px 14px;
      border-radius: 10px; font-size: 12px; font-weight: 600;
      display: flex; align-items: center; gap: 8px;
    }
    .alpha-status-bar.idle { background: var(--bg-glass); border: 1px solid var(--border-primary); color: var(--text-muted); }
    .alpha-status-bar.studying { background: var(--yellow-dim); border: 1px solid var(--yellow-border); color: var(--yellow); }
    .alpha-status-bar.live { background: var(--green-dim); border: 1px solid var(--green-border); color: var(--green); }
    .alpha-status-bar.error { background: var(--red-dim); border: 1px solid var(--red-border); color: var(--red); }
    .alpha-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; background: currentColor; }
    .alpha-status-bar.live .alpha-dot, .alpha-status-bar.studying .alpha-dot { animation: pulse 1.5s infinite; }

    .alpha-section { padding: 0 14px 10px; }
    .alpha-stitle {
      font-size: 9px; font-weight: 700; letter-spacing: 0.1em;
      color: var(--text-muted); text-transform: uppercase; margin-bottom: 8px;
    }
    .alpha-add-row { display: flex; gap: 6px; margin-bottom: 8px; }
    .alpha-add-row .fi { flex: 1; font-size: 11px; }
    .alpha-add-btn {
      padding: 0 12px; background: var(--accent-gradient-btn); border: none;
      border-radius: 8px; color: #fff; font-weight: 700; cursor: pointer;
      font-family: inherit; font-size: 11px;
    }
    .alpha-wallet {
      margin-bottom: 6px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; overflow: hidden; transition: border-color 0.2s;
    }
    .alpha-wallet:hover { border-color: var(--border-glow); }
    .alpha-wallet-head {
      padding: 8px 10px; display: flex; align-items: center; gap: 10px; cursor: pointer;
    }
    .alpha-wallet-icon {
      width: 30px; height: 30px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 13px; flex-shrink: 0; font-weight: 700;
    }
    .alpha-wallet-info { flex: 1; min-width: 0; }
    .alpha-wallet-label { font-size: 11px; font-weight: 700; }
    .alpha-wallet-addr {
      font-size: 9px; color: var(--text-muted); font-family: 'Fira Code', monospace;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .alpha-wallet-stats { font-size: 9px; color: var(--text-tertiary); margin-top: 1px; }
    .alpha-wallet-del {
      background: none; border: none; color: var(--text-faint); cursor: pointer;
      font-size: 14px; padding: 2px 4px;
    }
    .alpha-wallet-del:hover { color: var(--red); }
    .alpha-wallet-expand {
      font-size: 10px; color: var(--text-faint); padding: 0 6px; transition: transform 0.2s;
    }
    .alpha-wallet.open .alpha-wallet-expand { transform: rotate(180deg); }
    .alpha-wallet-body {
      display: none; border-top: 1px solid var(--border-secondary);
      padding: 8px 10px; background: rgba(0,0,0,0.15);
    }
    .alpha-wallet.open .alpha-wallet-body { display: block; }
    .alpha-holdings-title {
      font-size: 8px; font-weight: 700; letter-spacing: 0.08em;
      color: var(--text-faint); text-transform: uppercase; margin-bottom: 5px;
    }
    .alpha-token-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 3px 0; font-size: 10px;
    }
    .alpha-token-row + .alpha-token-row { border-top: 1px solid var(--border-secondary); }
    .alpha-token-name { color: var(--text-secondary); font-weight: 600; }
    .alpha-token-bal { color: var(--text-muted); font-family: 'Fira Code', monospace; font-size: 9px; }
    .alpha-token-val { color: var(--accent); font-family: 'Fira Code', monospace; font-size: 9px; }
    .alpha-stat-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;
    }
    .alpha-stat-pill {
      padding: 3px 6px; background: var(--bg-elevated); border-radius: 6px;
      font-size: 9px; display: flex; justify-content: space-between;
    }
    .alpha-stat-pill span:first-child { color: var(--text-faint); }
    .alpha-stat-pill span:last-child { color: var(--text-secondary); font-family: 'Fira Code', monospace; }
    .alpha-stat-pill.green span:last-child { color: var(--green); }
    .alpha-stat-pill.red span:last-child { color: var(--red); }

    .alpha-settings-toggle {
      padding: 6px 14px; font-size: 9px; color: var(--text-faint); cursor: pointer;
      display: flex; align-items: center; gap: 4px; user-select: none;
    }
    .alpha-settings-toggle:hover { color: var(--text-muted); }
    .alpha-settings-body { display: none; }
    .alpha-settings-body.open { display: block; }

    .alpha-config {
      padding: 10px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; margin-bottom: 8px;
    }
    .alpha-cfg-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 5px 0; border-bottom: 1px solid var(--border-secondary);
    }
    .alpha-cfg-row:last-child { border-bottom: none; }
    .alpha-cfg-label { font-size: 10px; font-weight: 600; color: var(--text-secondary); }
    .alpha-cfg-input {
      width: 65px; padding: 3px 6px; background: var(--bg-elevated);
      border: 1px solid var(--border-secondary); border-radius: 6px;
      color: var(--text-primary); font-family: 'Fira Code', monospace;
      font-size: 10px; text-align: right;
    }
    .alpha-cfg-input:focus { outline: none; border-color: var(--accent); }

    .alpha-btn-row { display: flex; gap: 8px; padding: 0 14px 10px; }
    .alpha-btn {
      flex: 1; padding: 10px; border: none; border-radius: 10px;
      font-weight: 700; cursor: pointer; font-family: inherit; font-size: 12px;
    }
    .alpha-btn.study { background: linear-gradient(135deg, #d97706, #f59e0b); color: #fff; box-shadow: 0 2px 10px rgba(245,158,11,0.2); }
    .alpha-btn.start { background: linear-gradient(135deg, #059669, #34d399); color: #fff; box-shadow: 0 2px 10px rgba(52,211,153,0.2); }
    .alpha-btn.stop { background: linear-gradient(135deg, #dc2626, #f87171); color: #fff; box-shadow: 0 2px 10px rgba(248,113,113,0.2); }
    .alpha-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .alpha-strategy {
      padding: 12px; background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 10px; font-size: 10px; color: var(--text-secondary);
      line-height: 1.6; white-space: pre-wrap; max-height: 180px; overflow-y: auto;
    }
    .alpha-log {
      max-height: 180px; overflow-y: auto; font-size: 10px;
      font-family: 'Fira Code', monospace;
    }
    .alpha-log-entry {
      padding: 5px 8px; margin-bottom: 3px;
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 6px; display: flex; gap: 6px;
    }
    .alpha-log-time { color: var(--text-faint); font-size: 9px; white-space: nowrap; margin-top: 1px; }
    .alpha-log-msg { color: var(--text-secondary); word-break: break-word; }

    /* ═══════ MEV PROTECTION TOGGLE ═══════ */
    .mev-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px 12px; margin: 8px 0;
      background: var(--bg-glass); border: 1px solid var(--border-primary); border-radius: 10px;
    }
    .mev-label { font-size: 11px; font-weight: 600; color: var(--text); }
    .mev-sub { font-size: 9px; color: var(--text-faint); }
    .mev-toggle {
      width: 36px; height: 20px; border-radius: 10px; border: none;
      background: var(--border); cursor: pointer; position: relative; transition: 0.2s;
    }
    .mev-toggle.on { background: var(--green); }
    .mev-toggle::after {
      content: ''; position: absolute; top: 2px; left: 2px;
      width: 16px; height: 16px; border-radius: 50%; background: #fff;
      transition: 0.2s;
    }
    .mev-toggle.on::after { left: 18px; }

    /* ═══════ WATCHLIST ═══════ */
    .watch-card {
      display: flex; align-items: center; gap: 10px; padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.04);
    }
    .watch-icon {
      width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center;
      justify-content: center; font-size: 11px; font-weight: 700; color: #fff; flex-shrink: 0;
    }
    .watch-info { flex: 1; min-width: 0; }
    .watch-name { font-size: 13px; font-weight: 600; color: var(--text); }
    .watch-mint { font-size: 9px; color: var(--text-faint); font-family: 'SF Mono','Fira Code',monospace; }
    .watch-right { text-align: right; flex-shrink: 0; }
    .watch-price { font-size: 12px; font-weight: 600; color: var(--text); }
    .watch-chg { font-size: 11px; font-weight: 700; }
    .watch-chg.up { color: var(--green); }
    .watch-chg.down { color: var(--red); }
    .watch-del {
      background: none; border: none; color: var(--text-faint); cursor: pointer;
      font-size: 14px; padding: 2px 4px; flex-shrink: 0;
    }
    .watch-del:hover { color: var(--red); }
    .watch-add-row { display: flex; gap: 6px; padding: 10px 14px; border-bottom: 1px solid var(--border); }

    /* ═══════ EMBEDDED CHART ═══════ */
    .chart-embed {
      width: 100%; height: 350px; border: none; border-radius: 0;
      background: var(--bg-surface);
    }

    /* ═══════ INLINE CHART CARD ═══════ */
    .fc-card {
      background: var(--bg-glass); border: 1px solid var(--border-primary);
      border-radius: 14px; overflow: hidden; max-width: 520px;
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    }
    .fc-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 14px; border-bottom: 1px solid var(--border-secondary);
    }
    .fc-pair { font-size: 15px; font-weight: 800; color: var(--text-primary); }
    .fc-tf { font-size: 10px; font-weight: 700; color: var(--text-muted);
      background: var(--bg-elevated); padding: 3px 8px; border-radius: 6px;
      letter-spacing: 0.08em; }
    .fc-price-row { display: flex; align-items: baseline; gap: 8px; }
    .fc-price { font-size: 18px; font-weight: 900; color: var(--text-primary);
      font-family: 'Fira Code', monospace; }
    .fc-change { font-size: 12px; font-weight: 800; font-family: 'Fira Code', monospace; }
    .fc-change.up { color: var(--green); }
    .fc-change.down { color: var(--red); }
    .fc-canvas-wrap { padding: 4px; position: relative; }
    .fc-canvas-wrap canvas { width: 100%; display: block; border-radius: 8px; }
    .fc-stats {
      display: flex; gap: 0; border-top: 1px solid var(--border-secondary);
    }
    .fc-stat {
      flex: 1; padding: 8px 10px; text-align: center;
      border-right: 1px solid var(--border-secondary);
    }
    .fc-stat:last-child { border-right: none; }
    .fc-stat-label { font-size: 8px; font-weight: 700; color: var(--text-faint);
      letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 2px; }
    .fc-stat-val { font-size: 11px; font-weight: 800; color: var(--text-secondary);
      font-family: 'Fira Code', monospace; }
    .fc-actions { display: flex; gap: 6px; padding: 8px 12px;
      border-top: 1px solid var(--border-secondary); }
    .fc-btn {
      flex: 1; padding: 7px 0; border-radius: 8px; border: 1px solid var(--border-primary);
      background: var(--bg-glass); color: var(--text-muted); font-size: 10px;
      font-weight: 700; cursor: pointer; font-family: inherit; letter-spacing: 0.04em;
    }
    .fc-btn:hover { border-color: var(--accent); color: var(--accent); }
    .fc-btn.buy { background: linear-gradient(135deg, rgba(34,197,94,0.15), rgba(34,197,94,0.05));
      color: var(--green); border-color: rgba(34,197,94,0.3); }
    .fc-btn.buy:hover { background: rgba(34,197,94,0.25); }
    .fc-loading { padding: 40px 14px; text-align: center; color: var(--text-muted); font-size: 12px; }
    .fc-error { padding: 20px 14px; text-align: center; color: var(--red); font-size: 12px; }
    .fc-embed-chart { width: 100%; height: 320px; border: none; }


  </style>
</head>
<body>
  <div id="app">
    <div class="glow"></div>

    <div class="header">
      <div class="logo-area">
        <span class="logo-icon">◬</span>
        <span class="logo-text">GHOST</span>
        <span class="logo-sub">CRYPTO</span>
        <div id="api-s" class="sbadge off">
          <span class="sdot"></span>
          <span id="api-st">NO KEY</span>
        </div>
      </div>

      <div class="mode-bar">
        <button class="new-chat-btn" onclick="newChat()" title="New Chat">+</button>
        <button class="mode-btn active" data-mode="chat" onclick="setMode('chat')"><span class="ic">◇</span> CHAT</button>
        <button class="mode-btn" data-mode="history" onclick="setMode('history')"><span class="ic">☰</span> HISTORY</button>
        <button class="mode-btn" data-mode="trade" onclick="setMode('trade')"><span class="ic">⟡</span> TRADE</button>
        <button class="mode-btn" data-mode="launch" onclick="setMode('launch')"><span class="ic">◆</span> LAUNCH</button>
        <button class="mode-btn" data-mode="tools" onclick="setMode('tools')"><span class="ic">◈</span> TOOLS</button>

        <button class="mode-btn" data-mode="wallet" onclick="setMode('wallet')"><span class="ic">◎</span> WALLET</button>
      </div>

      <div class="header-right">
        <button class="theme-toggle" id="theme-btn" onclick="toggleTheme()" title="Toggle light/dark mode">🌙</button>
        <button class="ws-toggle" id="ws-btn" onclick="toggleWebSearch()" title="Toggle web search">
          <span class="ws-dot"></span><span id="ws-label">🔍 Web</span>
        </button>
        <select id="model-sel" class="model-select">
          <option value="claude-sonnet-4-20250514">Sonnet 4</option>
          <option value="claude-haiku-4-5-20250929">Haiku 4.5</option>
          <option value="claude-opus-4-5-20251101">Opus 4.5</option>
        </select>
        <button class="theme-toggle" id="key-btn" onclick="promptApiKey()" title="Set Claude API Key">🔑</button>
        <button id="wbtn" class="wallet-btn off" onclick="connectWallet()">
          <span id="wbtn-icon">🔗</span> <span id="wbtn-t">Connect Wallet</span>
        </button>
      </div>
    </div>

    <div class="main-layout" id="main-layout">
      <div id="sidebar" class="sidebar">
        <div class="sidebar-inner">
        <button class="sidebar-close-mobile" onclick="setMode('chat')" title="Close panel">✕</button>
        <!-- CHAIN SELECTOR -->
        <div class="chain-bar" id="chain-bar">
          <button class="chain-btn active" data-chain="solana" onclick="switchChain('solana')"><span class="chain-dot"></span>SOL</button>
          <button class="chain-btn" data-chain="ethereum" onclick="switchChain('ethereum')"><span class="chain-dot"></span>ETH</button>
          <button class="chain-btn" data-chain="base" onclick="switchChain('base')"><span class="chain-dot"></span>BASE</button>
          <button class="chain-btn" data-chain="bsc" onclick="switchChain('bsc')"><span class="chain-dot"></span>BNB</button>
        </div>



          <!-- TRADE -->
          <div id="p-trade" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>⟡ SWAP TERMINAL <span id="trade-dex-label" style="font-size:10px;font-weight:400;color:var(--text-faint);">via Jupiter</span></div>

            <div class="trade-section">
              <div class="fg">
                <label class="fl">TOKEN ADDRESS</label>
                <input type="text" id="tr-mint" class="fi" placeholder="Paste token mint address..." oninput="onMintInput(this.value)" autocomplete="off">
              </div>
              <div id="tr-token-info" style="display:none;padding:10px 12px;background:var(--bg-glass);border:1px solid var(--border-primary);border-radius:10px;margin-bottom:12px;font-size:12px;">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                  <span id="tr-token-name" style="font-weight:700;color:var(--text-primary);"></span>
                  <span id="tr-token-price" style="color:var(--accent);font-weight:600;font-family:'Fira Code',monospace;"></span>
                </div>
              </div>

              <div class="fg">
                <label class="fl">AMOUNT (SOL)</label>
                <input type="number" id="tr-amount" class="fi" placeholder="0.00" step="0.01" min="0" oninput="getQuote()">
              </div>
              <div class="trade-amt-row">
                <button class="trade-preset" onclick="setTradeAmt(0.01)">0.01</button>
                <button class="trade-preset" onclick="setTradeAmt(0.05)">0.05</button>
                <button class="trade-preset" onclick="setTradeAmt(0.1)">0.1</button>
                <button class="trade-preset" onclick="setTradeAmt(0.5)">0.5</button>
                <button class="trade-preset" onclick="setTradeAmt(1)">1.0</button>
              </div>

              <div class="trade-settings">
                <div class="fg"><label class="fl">SLIPPAGE %</label><input type="number" id="tr-slippage" class="fi" value="1" step="0.5" min="0.1" max="50"></div>
                <div class="fg"><label class="fl">PRIORITY (SOL)</label><input type="number" id="tr-priority" class="fi" value="0.0005" step="0.0001" min="0"></div>
              </div>
              <div class="mev-row">
                <div>
                  <div class="mev-label">🛡️ MEV Protection</div>
                  <div class="mev-sub">Route via Jito bundles to prevent sandwich attacks</div>
                </div>
                <button class="mev-toggle on" id="mev-toggle" onclick="toggleMev()"></button>
              </div>

              <div id="tr-quote" class="trade-quote">
                <div class="tq-row"><span>You pay</span><span class="tq-val" id="tq-pay">—</span></div>
                <div class="tq-row"><span>You receive</span><span class="tq-val" id="tq-receive">—</span></div>
                <div class="tq-row"><span>Price impact</span><span class="tq-val" id="tq-impact">—</span></div>
                <div class="tq-row"><span>Route</span><span class="tq-val" id="tq-route">—</span></div>
              </div>

              <button id="tr-buy-btn" class="trade-exec trade-buy" onclick="executeTrade('buy')" disabled>🟢 BUY TOKEN</button>
              <div class="trade-amt-row" style="margin-bottom:6px;">
                <button class="trade-preset" onclick="setSellPct(25)" id="sell-pct-25">25%</button>
                <button class="trade-preset" onclick="setSellPct(50)" id="sell-pct-50">50%</button>
                <button class="trade-preset" onclick="setSellPct(75)" id="sell-pct-75">75%</button>
                <button class="trade-preset active" onclick="setSellPct(100)" id="sell-pct-100">100%</button>
              </div>
              <button id="tr-sell-btn" class="trade-exec trade-sell" onclick="executeTrade('sell')" disabled>🔴 SELL 100%</button>

              <div class="lwarn" style="font-size:11px;">⚠️ Trades execute on-chain via your selected DEX. You approve each transaction in your wallet. Always DYOR.</div>

              <div style="margin-top:10px;padding:10px 12px;background:var(--bg-glass);border:1px solid var(--border-primary);border-radius:10px;">
                <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;" onclick="$('sltp-body').style.display=$('sltp-body').style.display==='none'?'block':'none';$('sltp-arrow').textContent=$('sltp-body').style.display==='none'?'▸':'▾';">
                  <span style="font-size:11px;font-weight:700;letter-spacing:0.08em;color:var(--text-muted);">🎯 AUTO SL / TP</span>
                  <div style="display:flex;align-items:center;gap:8px;">
                    <button class="mev-toggle" id="sltp-toggle" onclick="event.stopPropagation();toggleSltp();" style="transform:scale(0.8);"></button>
                    <span id="sltp-arrow" style="color:var(--text-faint);font-size:10px;">▸</span>
                  </div>
                </div>
                <div id="sltp-body" style="display:none;margin-top:8px;">
                  <div style="display:flex;gap:8px;">
                    <div class="fg" style="flex:1;"><label class="fl">STOP-LOSS %</label><input type="number" id="manual-sl" class="fi" value="30" min="5" max="80" step="5"></div>
                    <div class="fg" style="flex:1;"><label class="fl">TAKE-PROFIT %</label><input type="number" id="manual-tp" class="fi" value="100" min="10" max="500" step="10"></div>
                  </div>
                  <div style="font-size:10px;color:var(--text-faint);margin-top:4px;">After buying, Ghost monitors price and auto-sells at SL/TP via Jupiter.</div>
                </div>
              </div>
            </div>

            <hr class="trade-divider">

            <div class="pos-header">
              <span>POSITIONS</span>
              <button onclick="refreshPositions()">↻ Refresh</button>
            </div>
            <div id="positions-list">
              <div class="pos-empty">Connect wallet to see positions</div>
            </div>

            <hr class="trade-divider">

            <div class="pos-header">
              <span>TRADE HISTORY</span>
              <div style="display:flex;gap:6px;">
                <button onclick="exportTradesCsv()">📥 CSV</button>
                <button onclick="clearTradeHistory()">Clear</button>
              </div>
            </div>
            <div id="trade-history" class="trade-history">
              <div class="pos-empty" style="padding:16px;">No trades yet</div>
            </div>
          </div>

          <!-- LAUNCH -->
          <div id="p-launch" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>🚀 TOKEN LAUNCHER</div>
            <div class="launch-steps" id="launch-steps" style="display:none">
              <div class="launch-step pending" id="step-1"><span class="step-num">1</span><span class="step-label" id="step-1-label">Upload metadata to IPFS</span><span class="step-status"></span></div>
              <div class="launch-step pending" id="step-2"><span class="step-num">2</span><span class="step-label" id="step-2-label">Build transaction</span><span class="step-status"></span></div>
              <div class="launch-step pending" id="step-3"><span class="step-num">3</span><span class="step-label" id="step-3-label">Sign with wallet</span><span class="step-status"></span></div>
              <div class="launch-step pending" id="step-4"><span class="step-num">4</span><span class="step-label" id="step-4-label">Submit to blockchain</span><span class="step-status"></span></div>
              <div class="launch-step pending" id="step-5"><span class="step-num">5</span><span class="step-label">Token is live!</span><span class="step-status"></span></div>
              <div class="launch-step pending" id="step-6" style="display:none"><span class="step-num">6</span><span class="step-label">Sniper buys</span><span class="step-status"></span></div>
            </div>
            <div id="launch-form-area">
              <div class="lsection" id="launch-platforms">
                <div class="lplatform sel sol-platform" data-p="pumpfun" onclick="selPlatform('pumpfun')">
                  <div class="lp-head"><span class="lp-name">🎰 Pump.fun</span><span class="lp-tag">SOL</span></div>
                  <div class="lp-desc">Fair launch, bonding curve, auto-LP</div>
                </div>
                <div class="lplatform sol-platform" data-p="bonkfun" onclick="selPlatform('bonkfun')">
                  <div class="lp-head"><span class="lp-name">🐕 Bonk.fun</span><span class="lp-tag">SOL</span></div>
                  <div class="lp-desc">Bonk ecosystem launcher</div>
                </div>
                <div class="lplatform sol-platform" data-p="bagsfm" onclick="selPlatform('bagsfm')">
                  <div class="lp-head"><span class="lp-name">💰 Bags.fm</span><span class="lp-tag">SOL</span></div>
                  <div class="lp-desc">Social token launcher</div>
                </div>
                <div class="lplatform bnb-platform" data-p="fourmeme" onclick="selPlatform('fourmeme')" style="display:none">
                  <div class="lp-head"><span class="lp-name">🟡 Four.meme</span><span class="lp-tag" style="background:rgba(240,185,11,0.15);color:#F0B90B;">BNB</span></div>
                  <div class="lp-desc">BSC memecoin launchpad — bonding curve, auto-LP to PancakeSwap</div>
                </div>
              </div>
              <div class="lform">
                <div class="fg"><label class="fl">TOKEN NAME *</label><input type="text" id="t-name" class="fi" placeholder="e.g. Ghost Protocol"></div>
                <div class="fg"><label class="fl">TICKER *</label><input type="text" id="t-ticker" class="fi" placeholder="e.g. $GHOST" maxlength="10" oninput="this.value=this.value.toUpperCase().replace(/[^A-Z0-9$]/g,'')"></div>
                <div class="fg"><label class="fl">DESCRIPTION</label><textarea id="t-desc" class="fi fi-ta" placeholder="What's your token about?"></textarea></div>
                <div class="fg"><label class="fl">TOKEN IMAGE *</label><label class="file-upload" id="file-label">📁 Click to upload image (PNG, JPG, GIF)<input type="file" id="t-image" accept="image/*" onchange="handleImageUpload(event)"></label></div>
                <div class="fg"><label class="fl" id="launch-buy-label">INITIAL BUY (SOL)</label><input type="number" id="t-buy" class="fi" placeholder="0 = no initial buy" step="0.01" min="0"></div>
                <div class="fg"><label class="fl">TWITTER (optional)</label><input type="text" id="t-twitter" class="fi" placeholder="https://x.com/yourtoken"></div>
                <div class="fg"><label class="fl">TELEGRAM (optional)</label><input type="text" id="t-telegram" class="fi" placeholder="https://t.me/yourtoken"></div>
                <div class="fg"><label class="fl">WEBSITE (optional)</label><input type="text" id="t-website" class="fi" placeholder="https://yourtoken.com"></div>
                <button id="lbtn" class="lbtn dis" onclick="launchToken()">CONNECT WALLET TO LAUNCH</button>
                <div class="lwarn" id="launch-warning">⚠️ This creates a real token on Solana. You need SOL for gas (~0.02 SOL). DYOR. Ghost is a tool — you are responsible for your actions.</div>
              </div>
            </div>
          </div>

          <!-- TOOLS -->
          <div id="p-tools" style="display:none">
            <div class="ph">CRYPTO PLUGINS</div>
            <div class="tcard" onclick="toolOpen('trade')"><div class="tcard-h"><span class="tcard-n" id="swap-card-name">⟡ Jupiter Swap</span><span class="tcard-s" style="background:var(--green-dim);color:var(--green);">ACTIVE</span></div><div class="tcard-d" id="swap-card-desc">Buy & sell any Solana token via Jupiter aggregator</div></div>
            <div class="tcard" onclick="setMode('perps')"><div class="tcard-h"><span class="tcard-n">⚡ Leverage Trading</span><span class="tcard-s" style="background:rgba(251,191,36,0.12);color:#fbbf24;">ACTIVE</span></div><div class="tcard-d">Trade SOL, BTC, ETH up to 250x — set up in Ghost, execute on Jupiter, track live</div></div>
            <div class="tcard" onclick="toolOpen('launch')"><div class="tcard-h"><span class="tcard-n">🎰 Token Launcher</span><span class="tcard-s" style="background:var(--green-dim);color:var(--green);">ACTIVE</span></div><div class="tcard-d">Launch on pump.fun (SOL), bonk.fun, bags.fm, or Four.meme (BNB)</div></div>
            <div class="tcard" onclick="toolOpen('wallet')"><div class="tcard-h"><span class="tcard-n" id="wallet-card-name">🔗 Wallet</span><span class="tcard-s" id="ph-stat" style="background:var(--red-dim);color:var(--red);">DISCONNECTED</span></div><div class="tcard-d" id="wallet-card-desc">Connect Phantom, MetaMask, or Trust Wallet</div></div>
            <div class="tcard" onclick="setMode('sniper')"><div class="tcard-h"><span class="tcard-n">⚡ Sniper Bot</span><span class="tcard-s" id="sniper-stat" style="background:var(--green-dim);color:var(--green);">ACTIVE</span></div><div class="tcard-d">Auto-buy your token launches with multiple wallets</div></div>
            <div class="tcard" onclick="setMode('intel')"><div class="tcard-h"><span class="tcard-n">⬡ Token Intel</span><span class="tcard-s" style="background:var(--green-dim);color:var(--green);">ACTIVE</span></div><div class="tcard-d">Scan any token: holders, liquidity, rug risk score</div></div>
            <div class="tcard" onclick="setMode('portfolio')"><div class="tcard-h"><span class="tcard-n">◐ Portfolio</span><span class="tcard-s" style="background:var(--green-dim);color:var(--green);">ACTIVE</span></div><div class="tcard-d">Full portfolio dashboard with PnL tracking</div></div>
            <div class="tcard" onclick="setMode('alpha')"><div class="tcard-h"><span class="tcard-n">🧠 Alpha Bot</span><span class="tcard-s" id="alpha-tool-stat" style="background:var(--green-dim);color:var(--green);">ACTIVE</span></div><div class="tcard-d">AI copy-trader — study wallets, learn patterns, auto-trade</div></div>
            <div class="tcard" onclick="setMode('watchlist')"><div class="tcard-h"><span class="tcard-n">⭐ Watchlist</span><span class="tcard-s" style="background:var(--green-dim);color:var(--green);">ACTIVE</span></div><div class="tcard-d">Track tokens you're eyeing — live prices & 24h change</div></div>
            <div class="tcard" onclick="setMode('bundle')"><div class="tcard-h"><span class="tcard-n">🔍 Bundle Checker</span><span class="tcard-s" style="background:rgba(239,68,68,0.12);color:#f87171;">ACTIVE</span></div><div class="tcard-d">Detect bundled launches — find if dev used multiple wallets to fake volume</div></div>

          </div>

          <!-- WALLET -->
          <div id="p-wallet" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>PHANTOM WALLET</div>
            <div class="winfo" id="wallet-content">
              <div style="text-align:center;padding:48px 20px;color:var(--text-muted);">
                <div style="font-size:40px;margin-bottom:14px;">👻</div>
                <div style="font-size:14px;margin-bottom:6px;color:var(--text);font-weight:600;">Not Connected</div>
                <div style="font-size:12px;margin-bottom:20px;">Connect your Phantom wallet to view holdings</div>
                <button class="wallet-btn off" onclick="connectWallet()">Connect Wallet</button>
              </div>
            </div>
          </div>

          <!-- HISTORY -->
          <div id="p-history" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>HISTORY</div>
            <div class="hist-tabs">
              <button class="hist-tab active" id="ht-chats" onclick="setHistTab('chats')">💬 CHATS</button>
              <button class="hist-tab" id="ht-txs" onclick="setHistTab('txs')">📋 TRADES</button>
              <button class="hist-tab" id="ht-pnl" onclick="setHistTab('pnl')">📊 PNL</button>
            </div>
            <div id="hist-chats" class="hist-list"></div>
            <div id="hist-txs" class="hist-list" style="display:none"></div>
            <div id="hist-pnl" style="display:none"></div>
          </div>

          <!-- SNIPER -->
          <div id="p-sniper" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>⚡ SNIPER BOT</div>

            <div class="sniper-toggle-row">
              <div>
                <div class="sniper-toggle-label">Auto-snipe on Launch</div>
                <div class="sniper-toggle-sub">Buy with all wallets after token deploys</div>
              </div>
              <button class="sniper-switch" id="sniper-sw" onclick="toggleSniper()"></button>
            </div>

            <div class="sniper-warn">
              ⚠️ Private keys are stored in your browser only. Use fresh wallets with only the SOL you need. Never reuse keys from your main wallet.
            </div>

            <div id="sniper-wallets" class="sniper-wallets"></div>

            <button class="sniper-add" id="sniper-add-btn" onclick="showSniperImport()">+ Add Wallet</button>

            <div class="sniper-import" id="sniper-import">
              <input type="password" id="sniper-key-input" class="fi" placeholder="Paste base58 private key...">
              <div class="sniper-import-btns">
                <button class="si-gen" onclick="generateSniperWallet()">🎲 Generate New</button>
                <button class="si-import" onclick="importSniperWallet()">📥 Import</button>
                <button class="si-cancel" onclick="hideSniperImport()">✕</button>
              </div>
            </div>

            <div id="sniper-log" style="padding:0 14px;"></div>
          </div>

          <!-- TOKEN INTEL -->
          <div id="p-intel" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>⬡ TOKEN INTEL</div>
            <div class="intel-search">
              <div class="intel-search-row">
                <input type="text" id="intel-mint" class="fi" placeholder="Paste mint address or ticker...">
                <button class="intel-search-btn" id="intel-go" onclick="fetchTokenIntel()">SCAN</button>
              </div>
            </div>
            <div id="intel-results">
              <div class="intel-empty">
                <div class="intel-empty-icon">⬡</div>
                <div class="intel-empty-text">Paste a token address or ticker and hit SCAN<br>for full intel: price, volume, holders, risk score</div>
              </div>
            </div>
          </div>

          <!-- PORTFOLIO -->
          <div id="p-portfolio" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>◐ PORTFOLIO <button onclick="refreshPortfolio()" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:12px;font-family:inherit;float:right;">↻ Refresh</button></div>
            <div id="portfolio-content">
              <div class="intel-empty">
                <div class="intel-empty-icon">◐</div>
                <div class="intel-empty-text">Connect wallet to view portfolio</div>
              </div>
            </div>
          </div>

          <!-- ALPHA BOT -->
          <div id="p-alpha" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>🧠 ALPHA BOT</div>

            <div id="alpha-status" class="alpha-status-bar idle">
              <span class="alpha-dot"></span>
              <span id="alpha-status-text">Idle — add wallets to track</span>
            </div>

            <div class="alpha-section">
              <div class="alpha-stitle">Tracked Wallets (Smart Money)</div>
              <div class="alpha-add-row">
                <input type="text" id="alpha-addr" class="fi" placeholder="Wallet address...">
                <input type="text" id="alpha-label" class="fi" placeholder="Label" style="width:70px;flex:none;">
                <button class="alpha-add-btn" onclick="addAlphaWallet()">+</button>
              </div>
              <div id="alpha-wallets"></div>
            </div>

            <div class="alpha-btn-row">
              <button class="alpha-btn study" id="alpha-study-btn" onclick="alphaStudy()">📚 Study Wallets</button>
              <button class="alpha-btn start" id="alpha-start-btn" onclick="alphaToggle()">▶ Start Bot</button>
            </div>

            <div class="alpha-btn-row" style="margin-top:-4px;">
              <button class="alpha-btn" id="alpha-scout-btn" onclick="alphaToggleScout()" style="flex:1;background:linear-gradient(135deg,#1a1a3e,#0d2137);border:1px solid #2a4a6a;">🔍 Scout Mode: OFF</button>
            </div>

            <div class="alpha-section">
              <div class="alpha-stitle">Strategy Profile</div>
              <div class="alpha-strategy" id="alpha-strategy">No strategy yet. Add wallets and click "Study" to analyze their trading patterns.</div>
            </div>

            <div class="alpha-section">
              <div class="alpha-stitle">Live Activity</div>
              <div class="alpha-log" id="alpha-log"></div>
            </div>

            <div class="alpha-settings-toggle" onclick="toggleAlphaSettings()">
              <span id="alpha-settings-arrow">▸</span> Settings & Configuration
            </div>
            <div id="alpha-settings-body" class="alpha-settings-body">
              <div class="alpha-section">
                <div class="alpha-stitle">🔑 Bot Wallet</div>
                <div style="font-size:10px;color:var(--text-faint);margin-bottom:8px;">This wallet auto-signs trades. Only fund what you can afford to lose.</div>
                <div id="alpha-wallet-display" style="display:none;padding:10px 12px;background:var(--bg-glass);border:1px solid var(--border-primary);border-radius:10px;margin-bottom:8px;">
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div>
                      <div id="alpha-wallet-label" style="font-size:12px;font-weight:700;color:var(--text);"></div>
                      <div id="alpha-wallet-addr" style="font-size:9px;color:var(--text-faint);font-family:'Fira Code',monospace;cursor:pointer;" onclick="navigator.clipboard.writeText(this.textContent);toast('📋 Copied!')"></div>
                      <div id="alpha-wallet-bal" style="font-size:10px;color:var(--accent);margin-top:2px;"></div>
                    </div>
                    <button onclick="removeAlphaBotWallet()" style="background:none;border:none;color:var(--red);cursor:pointer;font-size:14px;" title="Remove wallet">✕</button>
                  </div>
                </div>
                <div id="alpha-wallet-form">
                  <div class="alpha-add-row" style="margin-bottom:4px;">
                    <input type="text" id="alpha-bot-label" class="fi" placeholder="Label (e.g. Alpha Wallet)" style="flex:0.4;font-size:11px;">
                    <input type="password" id="alpha-bot-privkey" class="fi" placeholder="Paste private key (base58)..." style="flex:1;font-size:11px;">
                    <button class="alpha-add-btn" onclick="saveAlphaBotWallet()">💾 Save</button>
                  </div>
                  <div style="font-size:9px;color:var(--text-faint);">⚠️ Key is stored in your browser's localStorage. Never share it.</div>
                </div>
              </div>

              <div class="alpha-section">
                <div class="alpha-stitle">Configuration</div>
                <div class="alpha-config">
                  <div class="alpha-cfg-row"><span class="alpha-cfg-label">Buy Amount (SOL)</span><input type="number" id="alpha-buy-amt" class="alpha-cfg-input" value="0.01" step="0.005" min="0.001"></div>
                  <div class="alpha-cfg-row"><span class="alpha-cfg-label">Max Daily Trades</span><input type="number" id="alpha-max-daily" class="alpha-cfg-input" value="10" step="1" min="1"></div>
                  <div class="alpha-cfg-row"><span class="alpha-cfg-label">Slippage %</span><input type="number" id="alpha-slip" class="alpha-cfg-input" value="15" step="1" min="1"></div>
                </div>
                <div style="padding:6px 0 0;font-size:9px;color:var(--text-ghost);line-height:1.5;">TP/SL, timing, and exit rules are learned automatically from studying tracked wallets. Run <strong>Study</strong> to generate.</div>
              </div>

              <div class="alpha-section">
                <div class="alpha-stitle">Helius API Key (optional)</div>
                <div class="alpha-add-row">
                  <input type="password" id="alpha-helius-key" class="fi" placeholder="Optional — improves accuracy..." style="flex:1;font-size:11px;" value="">
                  <button class="alpha-add-btn" onclick="saveHeliusKey()" style="padding:0 10px;">Save</button>
                </div>
                <div style="font-size:9px;color:var(--text-faint);margin-top:2px;">Built-in key works by default. Override here if needed.</div>
              </div>
            </div>

            <div class="sniper-warn">⚠️ Alpha Bot uses private keys to auto-sign. Only fund what you can afford to lose. Past performance ≠ future results.</div>
          </div>

          <!-- WATCHLIST -->
          <div id="p-watchlist" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>⭐ WATCHLIST</div>
            <div class="watch-add-row">
              <input type="text" id="watch-input" class="fi" placeholder="Paste token address to watch..." style="flex:1;font-size:11px;">
              <button class="alpha-add-btn" onclick="addToWatchlist($('watch-input').value.trim())">+ Add</button>
            </div>
            <div id="watchlist-list">
              <div style="text-align:center;padding:40px;color:var(--text-muted);font-size:12px;">
                <div style="font-size:28px;margin-bottom:10px;">⭐</div>
                Your watchlist is empty.<br>Paste a contract address above or tap ⭐ on any token card.
              </div>
            </div>
          </div>

          <!-- EMBEDDED CHART -->
          <div id="p-chart" style="display:none">
            <div class="ph">
              <button class="ph-back" onclick="goBack()">←</button>
              📊 CHART <span id="chart-token-label" style="font-size:10px;font-weight:400;color:var(--text-faint);margin-left:6px;"></span>
              <span style="flex:1"></span>
              <button onclick="window.open($('chart-embed').src.replace('/embed/','/'),'_blank')" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:10px;font-family:inherit;">Open Full ↗</button>
            </div>
            <iframe id="chart-embed" class="chart-embed" src="about:blank" sandbox="allow-scripts allow-same-origin" loading="lazy"></iframe>
            <div id="chart-actions" style="display:flex;gap:6px;padding:10px 14px;">
              <button class="tk-btn buy" id="chart-buy-btn" onclick="">⟡ BUY</button>
              <button class="tk-btn" id="chart-scan-btn" onclick="">⬡ SCAN</button>
              <button class="tk-btn" id="chart-solscan-btn" onclick="">🔍 SOLSCAN</button>
              <button class="tk-btn" id="chart-watch-btn" onclick="">⭐ WATCH</button>
            </div>
          </div>

          <!-- BUNDLE CHECKER -->
          <div id="p-bundle" style="display:none">
            <div class="ph"><button class="ph-back" onclick="goBack()">←</button>🔍 BUNDLE CHECKER <span style="font-size:9px;font-weight:600;color:#f87171;margin-left:6px;">SCAM DETECTOR</span></div>
            <div class="bundle-search">
              <div class="bundle-search-row">
                <input type="text" id="bundle-mint" class="fi" placeholder="Paste token mint address...">
                <button class="bundle-search-btn" id="bundle-go" onclick="runBundleCheck()">🔍 SCAN</button>
              </div>
            </div>
            <div id="bundle-log" class="bundle-log" style="display:none;"></div>
            <div id="bundle-results">
              <div class="bundle-empty">
                <div class="bundle-empty-icon">🔍</div>
                <div class="bundle-empty-text">Paste a token mint address to check if the<br>launch was bundled (dev used multiple wallets<br>to fake volume and holders).</div>
              </div>
            </div>
          </div>




        </div>
      </div>

      <div class="chat-area">
        <div id="session-stats" style="display:none;padding:4px 14px;font-size:10px;font-family:'Fira Code',monospace;color:var(--text-faint);background:var(--bg-glass);border-bottom:1px solid var(--border-secondary);align-items:center;flex-shrink:0;gap:12px;"></div>
        <div id="messages" class="messages">
          <div class="empty-state" id="empty-state">
            <div class="eicon">◬</div>
            <div class="etitle">Ghost Crypto</div>
            <div class="edesc">AI-powered crypto command center. Multi-chain trading (Solana, Ethereum, Base, BNB Chain). Trade via Jupiter/OpenOcean, launch tokens, copy-trade smart wallets with Alpha Bot, and manage your portfolio.<br><br><span style="color:var(--accent);font-weight:700;font-size:11px;">💡 Quick: type <code style="background:var(--bg-elevated);padding:1px 6px;border-radius:4px;">fc sol 5m</code> for instant charts · paste any token address for instant scan</span></div>
          </div>
        </div>
      </div>
    </div>

    <!-- ═══════ FULLSCREEN PERPS TERMINAL ═══════ -->
    <div id="p-perps" class="perps-fullscreen" style="display:none;">
      <!-- Top Bar -->
      <div class="perps-topbar">
        <div class="perps-topbar-left">
          <button class="perps-back-btn" onclick="goBack()">← Back</button>
          <span class="perps-title">⚡ LEVERAGE TERMINAL</span>
          <span class="perps-badge">JUPITER PERPS</span>
        </div>
        <div class="perps-topbar-markets" id="perps-markets">
          <button class="perps-market-btn active" data-market="SOL" onclick="selectPerpsMarket('SOL')">
            <span class="perps-market-sym"><span class="dot" style="background:#9945FF;"></span>SOL</span>
            <span class="perps-market-price" id="perps-mp-SOL">—</span>
          </button>
          <button class="perps-market-btn" data-market="BTC" onclick="selectPerpsMarket('BTC')">
            <span class="perps-market-sym"><span class="dot" style="background:#f7931a;"></span>BTC</span>
            <span class="perps-market-price" id="perps-mp-BTC">—</span>
          </button>
          <button class="perps-market-btn" data-market="ETH" onclick="selectPerpsMarket('ETH')">
            <span class="perps-market-sym"><span class="dot" style="background:#627eea;"></span>ETH</span>
            <span class="perps-market-price" id="perps-mp-ETH">—</span>
          </button>
        </div>
        <div class="perps-topbar-right">
          <div class="perps-topbar-price">
            <span id="perps-big-price" class="perps-big-price">$—</span>
            <span class="perps-stat-val" id="perps-24h-chg" style="font-size:12px;">—</span>
          </div>
          <div class="perps-topbar-stats">
            <div class="perps-stat"><span class="perps-stat-label">24H HIGH</span><span class="perps-stat-val" id="perps-24h-high">—</span></div>
            <div class="perps-stat"><span class="perps-stat-label">24H LOW</span><span class="perps-stat-val" id="perps-24h-low">—</span></div>
            <div class="perps-stat"><span class="perps-stat-label">BORROW</span><span class="perps-stat-val" id="perps-borrow-rate">~0.012%/hr</span></div>
          </div>
          <span id="perps-connection" style="font-size:9px;color:var(--green);font-weight:600;">● LIVE</span>
        </div>
      </div>

      <!-- Main 2-Column Layout -->
      <div class="perps-body">
        <!-- LEFT: Chart -->
        <div class="perps-left">
          <div class="perps-chart-section">
            <div class="perps-chart-toolbar">
              <div class="perps-tf-group">
                <button class="perps-tf-btn" onclick="setPerpsTimeframe('1')">1m</button>
                <button class="perps-tf-btn" onclick="setPerpsTimeframe('5')">5m</button>
                <button class="perps-tf-btn" onclick="setPerpsTimeframe('15')">15m</button>
                <button class="perps-tf-btn active" onclick="setPerpsTimeframe('60')">1H</button>
                <button class="perps-tf-btn" onclick="setPerpsTimeframe('240')">4H</button>
                <button class="perps-tf-btn" onclick="setPerpsTimeframe('D')">1D</button>
                <button class="perps-tf-btn" onclick="setPerpsTimeframe('W')">1W</button>
              </div>
              <div class="perps-rate-chips">
                <span class="perps-rate-chip">Max: <span id="perps-max-lev">100x</span></span>
                <span class="perps-rate-chip">OI: <span id="perps-oi">—</span></span>
              </div>
            </div>
            <div class="perps-chart-wrap">
              <iframe id="perps-chart-iframe" src="about:blank" sandbox="allow-scripts allow-same-origin allow-popups" style="width:100%;height:100%;border:none;"></iframe>
            </div>
          </div>
        </div>

        <!-- RIGHT: Order Form -->
        <div class="perps-right">
          <div class="perps-order-panel">
            <!-- Long / Short -->
            <div class="perps-side-toggle">
              <button class="perps-side-btn long-active" id="perps-long-btn" onclick="setPerpsPosition('long')">🟢 LONG</button>
              <button class="perps-side-btn" id="perps-short-btn" onclick="setPerpsPosition('short')">🔴 SHORT</button>
            </div>

            <!-- Order Type -->
            <div class="perps-order-type">
              <button class="perps-otype-btn active" onclick="setPerpsOrderType('market')">MARKET</button>
              <button class="perps-otype-btn" onclick="setPerpsOrderType('limit')">LIMIT</button>
            </div>

            <!-- Limit Price -->
            <div class="perps-limit-row" id="perps-limit-row">
              <div class="perps-input-section" style="margin-bottom:0;">
                <div class="perps-input-label"><span>LIMIT PRICE</span></div>
                <div class="perps-input-wrap">
                  <input type="number" id="perps-limit-price" placeholder="0.00" step="0.01" oninput="updatePerpsOrder()">
                  <div class="perps-input-token">USD</div>
                </div>
              </div>
            </div>

            <!-- Leverage -->
            <div class="perps-leverage-section">
              <div class="perps-lev-header">
                <span class="perps-lev-label">LEVERAGE</span>
                <span class="perps-lev-val" id="perps-lev-val">5x</span>
              </div>
              <div class="perps-lev-slider-wrap">
                <input type="range" class="perps-lev-slider" id="perps-lev-slider" min="1" max="100" value="5" step="1" oninput="updatePerpsLeverage(this.value)">
              </div>
              <div class="perps-lev-presets">
                <button class="perps-lev-preset" onclick="setPerpsLeverage(2)">2x</button>
                <button class="perps-lev-preset active" onclick="setPerpsLeverage(5)">5x</button>
                <button class="perps-lev-preset" onclick="setPerpsLeverage(10)">10x</button>
                <button class="perps-lev-preset" onclick="setPerpsLeverage(25)">25x</button>
                <button class="perps-lev-preset" onclick="setPerpsLeverage(50)">50x</button>
                <button class="perps-lev-preset" onclick="setPerpsLeverage(100)">100x</button>
              </div>
            </div>

            <!-- Collateral -->
            <div class="perps-input-section">
              <div class="perps-input-label">
                <span>PAY / COLLATERAL</span>
                <span class="bal" id="perps-bal">Bal: —</span>
              </div>
              <div class="perps-input-wrap">
                <input type="number" id="perps-collateral" placeholder="0.00" step="0.01" min="0" oninput="updatePerpsOrder()">
                <div class="perps-input-token" id="perps-collat-token">SOL</div>
              </div>
              <div class="perps-collat-presets">
                <button class="perps-collat-preset" onclick="setPerpsCollateral(0.1)">0.1</button>
                <button class="perps-collat-preset" onclick="setPerpsCollateral(0.5)">0.5</button>
                <button class="perps-collat-preset" onclick="setPerpsCollateral(1)">1.0</button>
                <button class="perps-collat-preset" onclick="setPerpsCollateral(5)">5.0</button>
                <button class="perps-collat-preset" onclick="setPerpsCollateral(10)">10</button>
              </div>
              <div class="perps-token-row" id="perps-token-row"></div>
            </div>

            <!-- Order Summary -->
            <div class="perps-summary">
              <div class="perps-summary-row"><span>Position Size</span><span class="pos-size" id="perps-pos-size">$0.00</span></div>
              <div class="perps-summary-row"><span>Entry Price</span><span id="perps-entry-price">$—</span></div>
              <div class="perps-summary-row"><span>Liq. Price</span><span class="liq-price" id="perps-liq-price">$—</span></div>
              <div class="perps-summary-row"><span>Open Fee</span><span id="perps-open-fee">—</span></div>
              <div class="perps-summary-row"><span>Borrow Rate</span><span id="perps-borrow-disp">—</span></div>
            </div>

            <!-- Execute -->
            <button class="perps-exec long-btn" id="perps-exec-btn" onclick="executePerps()">
              🟢 OPEN LONG SOL — $0
            </button>

            <!-- Info -->
            <div class="perps-info">
              ⚡ Shows your order details, then opens <strong>Jupiter Perps</strong> to execute on-chain.
              Ghost tracks your position with live Binance prices. Up to 250x leverage.
            </div>

            <!-- Open Positions -->
            <div class="perps-positions-section">
              <div class="perps-pos-header">
                <span>OPEN POSITIONS</span>
                <button onclick="refreshPerpsPositions()">↻ Refresh</button>
              </div>
              <div id="perps-positions-list">
                <div class="perps-pos-empty">No open positions</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="input-area" id="input-area">
      <div class="input-box">
        <div class="chat-mode-toggle" id="cmt">
          <button class="cmt-btn active" id="cmt-agent" onclick="setChatMode('agent')"><span class="cmt-dot agent-dot"></span>Agent</button>
          <button class="cmt-btn" id="cmt-chat" onclick="setChatMode('chat')"><span class="cmt-dot chat-dot"></span>Chat</button>
        </div>
        <input type="text" id="input" placeholder="Tell Ghost what to do..." autocomplete="off">
        <button id="send-btn" class="send-btn" onclick="sendMessage()">↵</button>
      </div>
    </div>

    <div class="footer" id="app-footer">Ghost Crypto v0.9 • <span class="g">Powered by Claude</span> • Swaps via Jupiter • Wallet via Phantom • <span style="color:#9945FF;font-weight:600;">Solana</span></div>
  </div>

  <!-- Wallet Selector Modal -->
  <div class="wallet-modal-overlay" id="wallet-modal" onclick="if(event.target===this)closeWalletModal()">
    <div class="wallet-modal">
      <div class="wallet-modal-title">Connect Wallet</div>
      <div class="wallet-modal-sub" id="wm-subtitle">Choose a wallet to connect</div>
      <div id="wm-options"></div>
      <button class="wallet-modal-close" onclick="closeWalletModal()">Cancel</button>
    </div>
  </div>

  <!-- Jupiter Trade Bridge Modal -->
  <div id="jup-modal" class="jup-overlay" style="display:none;" onclick="if(event.target===this)closeJupModal()">
    <div class="jup-win">
      <div class="jup-bar">
        <div class="jup-dot r" onclick="closeJupModal()" title="Close"></div>
        <div class="jup-dot y"></div>
        <div class="jup-dot g"></div>
        <div class="jup-url"><span class="lk">🔒</span><span id="jup-url-text">jup.ag/perps</span></div>
      </div>
      <div class="jup-body" id="jup-body"></div>
      <div class="jup-footer">
        <span>⚡ Ghost × Jupiter Perps</span>
        <span id="jup-track" class="live"></span>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    const CLAUDE_API = 'https://api.anthropic.com/v1/messages';
    const PUMP_API = 'https://pump.fun/api';
    const PUMPPORTAL_API = 'https://pumpportal.fun/api';
    const RPC_URL = 'https://api.mainnet-beta.solana.com';
    const JUP_API = 'https://api.jup.ag';
    const JUP_ENDPOINTS = [
      'https://public.jupiterapi.com',
      'https://api.jup.ag/swap/v1',
      'https://lite-api.jup.ag/swap/v1',
    ];
    const JUP_PRICE = 'https://api.jup.ag/price/v2';
    const SOL_MINT = 'So11111111111111111111111111111111111111112';
    let heliusKey = lsGet('ghost-helius-key', '');

    // Backup RPCs for avoiding 403 on public RPC
    const BACKUP_RPCS = [
      'https://rpc.ankr.com/solana',
      'https://solana-rpc.publicnode.com',
      RPC_URL,
    ];

    let _cachedConn = null;
    let _cachedConnTime = 0;
    const CONN_CACHE_TTL = 30000; // 30 seconds

    async function getWorkingConnection() {
      // Return cached connection if still fresh
      if (_cachedConn && Date.now() - _cachedConnTime < CONN_CACHE_TTL) {
        return _cachedConn;
      }
      const rpcs = heliusKey
        ? [`https://mainnet.helius-rpc.com/?api-key=${heliusKey}`, ...BACKUP_RPCS]
        : BACKUP_RPCS;
      for (const rpc of rpcs) {
        try {
          const conn = new solanaWeb3.Connection(rpc);
          await conn.getBalance(new solanaWeb3.PublicKey('11111111111111111111111111111111'));
          _cachedConn = conn;
          _cachedConnTime = Date.now();
          return conn;
        } catch (e) { continue; }
      }
      return new solanaWeb3.Connection(BACKUP_RPCS[0]);
    }

    let currentModel = lsGet('ghost-model', 'claude-sonnet-4-20250514');
    const GHOST_DEFAULT_KEY = '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';
    function lsGet(k, fallback) { try { return localStorage.getItem(k) || fallback; } catch(e) { return fallback; } }
    function lsSet(k, v) { try { localStorage.setItem(k, v); } catch(e) {} }
    function lsGetJSON(k, fallback) { try { const v = localStorage.getItem(k); return v ? JSON.parse(v) : fallback; } catch(e) { return fallback; } }
    function lsSetJSON(k, v) { try { localStorage.setItem(k, JSON.stringify(v)); } catch(e) {} }
    function lsRemove(k) { try { localStorage.removeItem(k); } catch(e) {} }
    let apiKey = lsGet('ghost-claude-key', GHOST_DEFAULT_KEY);
    lsSet('ghost-claude-key', apiKey);
    let isGenerating = false;
    let chatMessages = [];
    let walletPubkey = null;
    let walletAddress = null;
    let walletBalance = null;
    let selectedPlatform = 'pumpfun';
    let currentMode = 'chat';
    let chatMode = lsGet('ghost-chat-mode', 'agent'); // 'agent' or 'chat'
    let tokenImageFile = null;

    // Chat session management
    let chatSessions = lsGetJSON('ghost-chat-sessions', []);
    let currentSessionId = lsGet('ghost-current-session', '') || null;

    // Trade state
    let currentQuote = null;
    let tradeHistory = lsGetJSON('ghost-trades', []);
    let quoteTimer = null;
    let isTrading = false;
    let sellPct = 100; // Sell percentage (25, 50, 75, 100)
    let sltpEnabled = lsGet('ghost-sltp', '') === 'true';
    let manualPositions = lsGetJSON('ghost-manual-positions', {});
    let manualSltpTimer = null;
    let webSearchEnabled = lsGet('ghost-websearch', '') === 'true';

    // ═══════ MULTI-CHAIN CONFIG ═══════
    const CHAINS = {
      solana: {
        name: 'Solana', symbol: 'SOL', decimals: 9, icon: '◎', color: '#9945FF',
        explorer: 'https://solscan.io', explorerTx: 'https://solscan.io/tx/',
        explorerAddr: 'https://solscan.io/account/',
        nativeMint: 'So11111111111111111111111111111111111111112',
        walletType: 'phantom', walletName: 'Phantom', walletIcon: '👻',
        dexName: 'Jupiter', dexLabel: 'via Jupiter',
        dexScreenerChain: 'solana', addressRegex: /^[1-9A-HJ-NP-Za-km-z]{32,50}$/,
      },
      ethereum: {
        name: 'Ethereum', symbol: 'ETH', decimals: 18, icon: 'Ξ', color: '#627EEA',
        chainId: 1, chainIdHex: '0x1',
        explorer: 'https://etherscan.io', explorerTx: 'https://etherscan.io/tx/',
        explorerAddr: 'https://etherscan.io/address/',
        nativeMint: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
        wrappedNative: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
        walletType: 'metamask', walletName: 'MetaMask', walletIcon: '🦊',
        dexName: 'Uniswap', dexLabel: 'via OpenOcean',
        dexScreenerChain: 'ethereum', addressRegex: /^0x[a-fA-F0-9]{40}$/,
        rpcUrls: ['https://eth.llamarpc.com', 'https://rpc.ankr.com/eth', 'https://ethereum-rpc.publicnode.com'],
        openOceanChain: 'eth',
      },
      base: {
        name: 'Base', symbol: 'ETH', decimals: 18, icon: '🔵', color: '#0052FF',
        chainId: 8453, chainIdHex: '0x2105',
        explorer: 'https://basescan.org', explorerTx: 'https://basescan.org/tx/',
        explorerAddr: 'https://basescan.org/address/',
        nativeMint: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
        wrappedNative: '0x4200000000000000000000000000000000000006',
        walletType: 'metamask', walletName: 'MetaMask', walletIcon: '🦊',
        dexName: 'Aerodrome', dexLabel: 'via OpenOcean',
        dexScreenerChain: 'base', addressRegex: /^0x[a-fA-F0-9]{40}$/,
        rpcUrls: ['https://mainnet.base.org', 'https://rpc.ankr.com/base', 'https://base-rpc.publicnode.com'],
        openOceanChain: 'base',
      },
      bsc: {
        name: 'BNB Chain', symbol: 'BNB', decimals: 18, icon: '⬡', color: '#F0B90B',
        chainId: 56, chainIdHex: '0x38',
        explorer: 'https://bscscan.com', explorerTx: 'https://bscscan.com/tx/',
        explorerAddr: 'https://bscscan.com/address/',
        nativeMint: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
        wrappedNative: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        walletType: 'metamask', walletName: 'MetaMask', walletIcon: '🦊',
        dexName: 'PancakeSwap', dexLabel: 'via OpenOcean',
        dexScreenerChain: 'bsc', addressRegex: /^0x[a-fA-F0-9]{40}$/,
        rpcUrls: ['https://bsc-dataseed.binance.org', 'https://rpc.ankr.com/bsc', 'https://bsc-rpc.publicnode.com'],
        openOceanChain: 'bsc',
      },
    };

    let activeChain = lsGet('ghost-chain', 'solana');
    let evmProvider = null; // ethers.js provider for EVM chains
    let evmSigner = null;   // ethers.js signer for EVM chains

    function getChain() { return CHAINS[activeChain]; }
    function isEVM() { return activeChain !== 'solana'; }

    // ═══════ CHAIN SWITCHING ═══════
    function switchChain(chain) {
      if (chain === activeChain) return;
      
      // Disconnect current wallet
      if (walletAddress) {
        disconnectWallet();
      }
      
      activeChain = chain;
      lsSet('ghost-chain', chain);
      
      // Update chain selector UI
      document.querySelectorAll('.chain-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.chain === chain);
      });
      
      // Update wallet button
      const cfg = getChain();
      $('wbtn-icon').textContent = '🔗';
      $('wbtn-t').textContent = 'Connect Wallet';
      
      // Update trade panel
      if ($('trade-dex-label')) $('trade-dex-label').textContent = cfg.dexLabel;
      
      // Update tool cards
      if ($('swap-card-name')) $('swap-card-name').textContent = '⟡ ' + cfg.dexName + ' Swap';
      if ($('swap-card-desc')) $('swap-card-desc').textContent = 'Buy & sell any ' + cfg.name + ' token via ' + cfg.dexName;
      if ($('wallet-card-name')) $('wallet-card-name').textContent = '🔗 Wallet';
      if ($('wallet-card-desc')) $('wallet-card-desc').textContent = 'Connect & manage wallet on ' + cfg.name;
      
      // Update trade panel labels
      const amtLabel = document.querySelector('#p-trade .fl');
      
      // Show/hide Solana-only features
      const isSol = chain === 'solana';
      const mevRow = document.querySelector('.mev-row');
      if (mevRow) mevRow.style.display = isSol ? 'flex' : 'none';
      const sltpPanel = document.querySelector('#p-trade [onclick*="sltp-body"]')?.closest('div[style*="margin-top:10px"]');
      if (sltpPanel) sltpPanel.style.display = isSol ? 'block' : 'none';
      
      // Show/hide chain-specific modes
      const showLaunch = chain === 'solana' || chain === 'bsc';
      ['sniper', 'alpha', 'bundle', 'perps'].forEach(mode => {
        const card = document.querySelector(`.tcard[onclick*="${mode}"]`);
        if (card) card.style.display = isSol ? '' : 'none';
      });
      // Launch visible on SOL + BNB
      const launchCard = document.querySelector('.tcard[onclick*="launch"]');
      if (launchCard) launchCard.style.display = showLaunch ? '' : 'none';
      // Launch mode button in navbar
      const launchModeBtn = document.querySelector('.mode-btn[data-mode="launch"]');
      if (launchModeBtn) launchModeBtn.style.display = showLaunch ? '' : 'none';
      
      // Update launch platforms visibility
      updateLaunchPlatforms();
      
      // Update amount label 
      const amtLabels = document.querySelectorAll('#p-trade .fl');
      amtLabels.forEach(l => {
        if (l.textContent.includes('AMOUNT')) l.textContent = 'AMOUNT (' + cfg.symbol + ')';
      });
      
      // Update trade warnings
      const warns = document.querySelectorAll('#p-trade .lwarn');
      warns.forEach(w => {
        if (w.textContent.includes('Trades execute')) {
          w.textContent = '⚠️ Trades execute on-chain via ' + cfg.dexName + '. You approve each transaction in your wallet. Always DYOR.';
        }
      });
      
      // Update preset amounts for the chain
      updateTradePresets();
      
      // Reset trade state
      $('tr-mint').placeholder = isEVM() ? 'Paste 0x token contract address...' : 'Paste token mint address...';
      $('tr-mint').value = '';
      $('tr-token-info').style.display = 'none';
      $('tr-quote').style.display = 'none';
      currentQuote = null;
      $('positions-list').innerHTML = '<div class="pos-empty">Connect wallet to see positions</div>';
      
      // Update footer
      const footer = $('app-footer');
      if (footer) {
        footer.innerHTML = `Ghost Crypto v0.9 • <span class="g">Powered by Claude</span> • Swaps via ${cfg.dexName} • <span style="color:${cfg.color};font-weight:600;">${cfg.name}</span>`;
      }
      
      toast(`⛓️ Switched to ${cfg.name}`);
    }
    
    function updateTradePresets() {
      const cfg = getChain();
      const presets = isEVM() ? [0.001, 0.005, 0.01, 0.05, 0.1] : [0.01, 0.05, 0.1, 0.5, 1.0];
      const btns = document.querySelectorAll('#p-trade .trade-amt-row:first-of-type .trade-preset');
      btns.forEach((btn, i) => {
        if (presets[i] !== undefined) {
          btn.textContent = presets[i];
          btn.setAttribute('onclick', `setTradeAmt(${presets[i]})`);
        }
      });
    }

    // ═══════ EVM PROVIDER HELPERS ═══════
    function getMetaMask() {
      if (window.ethereum?.isMetaMask) return window.ethereum;
      if (window.ethereum?.providers) {
        return window.ethereum.providers.find(p => p.isMetaMask);
      }
      return window.ethereum || null;
    }

    // ═══════ WALLET PROVIDERS ═══════
    let activeWalletId = null; // 'phantom' | 'metamask' | 'trustwallet'

    const WALLET_PROVIDERS = {
      phantom: {
        name: 'Phantom', icon: '👻', installUrl: 'https://phantom.app',
        supportsSolana: true, supportsEVM: true,
        detect: () => !!window.phantom?.solana?.isPhantom,
        detectEVM: () => !!window.phantom?.ethereum,
        getSolana: () => window.phantom?.solana,
        getEVM: () => {
          if (window.phantom?.ethereum) return window.phantom.ethereum;
          return null;
        },
      },
      metamask: {
        name: 'MetaMask', icon: '🦊', installUrl: 'https://metamask.io',
        supportsSolana: false, supportsEVM: true,
        detect: () => {
          if (window.ethereum?.isMetaMask) return true;
          if (window.ethereum?.providers?.some(p => p.isMetaMask)) return true;
          return false;
        },
        detectEVM: () => WALLET_PROVIDERS.metamask.detect(),
        getEVM: () => {
          if (window.ethereum?.isMetaMask) return window.ethereum;
          if (window.ethereum?.providers) return window.ethereum.providers.find(p => p.isMetaMask);
          return window.ethereum || null;
        },
      },
      trustwallet: {
        name: 'Trust Wallet', icon: '🛡️', installUrl: 'https://trustwallet.com',
        supportsSolana: true, supportsEVM: true,
        detect: () => !!window.trustwallet || !!window.ethereum?.isTrust,
        detectEVM: () => {
          if (window.trustwallet?.ethereum) return true;
          if (window.ethereum?.isTrust) return true;
          return false;
        },
        detectSolana: () => !!window.trustwallet?.solana,
        getSolana: () => window.trustwallet?.solana || null,
        getEVM: () => {
          if (window.trustwallet?.ethereum) return window.trustwallet.ethereum;
          if (window.ethereum?.isTrust) return window.ethereum;
          return null;
        },
      },
    };

    function openWalletModal() {
      const cfg = getChain();
      const isSol = !isEVM();
      $('wm-subtitle').textContent = `Connect to ${cfg.name}`;
      
      const providers = Object.entries(WALLET_PROVIDERS);
      let html = '';
      
      for (const [id, wp] of providers) {
        // Check if this wallet supports the active chain
        const supportsChain = isSol ? wp.supportsSolana : wp.supportsEVM;
        if (!supportsChain) continue;
        
        // Check if detected
        const detected = isSol
          ? (id === 'trustwallet' ? (wp.detectSolana?.() || wp.detect()) : wp.detect())
          : wp.detectEVM();
        
        // Build chain support tags
        const chains = [];
        if (wp.supportsSolana) chains.push({ name: 'SOL', active: isSol });
        if (wp.supportsEVM) {
          chains.push({ name: 'ETH', active: !isSol && activeChain === 'ethereum' });
          chains.push({ name: 'BASE', active: !isSol && activeChain === 'base' });
          chains.push({ name: 'BNB', active: !isSol && activeChain === 'bsc' });
        }
        const chainTags = chains.map(c =>
          `<span class="wo-chain-tag${c.active ? ' active' : ''}">${c.name}</span>`
        ).join('');
        
        html += `<div class="wallet-option ${detected ? 'detected' : 'not-detected'}" 
                      onclick="${detected ? `closeWalletModal();connectWithProvider('${id}')` : `window.open('${wp.installUrl}','_blank')`}">
          <div class="wo-icon">${wp.icon}</div>
          <div class="wo-info">
            <div class="wo-name">${wp.name}</div>
            <div class="wo-status ${detected ? 'ok' : 'missing'}">${detected ? '● Detected' : '○ Not installed — click to install'}</div>
            <div class="wo-chains">${chainTags}</div>
          </div>
        </div>`;
      }
      
      $('wm-options').innerHTML = html;
      $('wallet-modal').classList.add('open');
    }

    function closeWalletModal() {
      $('wallet-modal').classList.remove('open');
    }

    async function connectWithProvider(providerId) {
      activeWalletId = providerId;
      lsSet('ghost-wallet-provider', providerId);
      const wp = WALLET_PROVIDERS[providerId];
      
      if (isEVM()) {
        await connectEVMWithProvider(wp, providerId);
      } else {
        await connectSolanaWithProvider(wp, providerId);
      }
    }

    async function connectSolanaWithProvider(wp, providerId) {
      // For Phantom
      if (providerId === 'phantom') {
        toast('🔍 Connecting to Phantom...');
        let phantom = await waitForPhantom(5000);
        if (!phantom) {
          toast('Phantom not found');
          addMsg('system', '👻 **Phantom not detected.** Install it from https://phantom.app');
          return;
        }
        try {
          const resp = await phantom.connect();
          onSolanaWalletConnected(resp.publicKey, resp.publicKey.toString(), '👻', 'Phantom');
        } catch (err) { toast('Connection rejected'); }
        return;
      }
      
      // For Trust Wallet (Solana)
      if (providerId === 'trustwallet') {
        toast('🔍 Connecting to Trust Wallet...');
        const solProvider = wp.getSolana?.();
        if (!solProvider) {
          toast('Trust Wallet Solana provider not found');
          addMsg('system', '🛡️ **Trust Wallet Solana provider not detected.** Make sure Trust Wallet browser extension is installed and Solana is enabled.');
          return;
        }
        try {
          const resp = await solProvider.connect();
          const pubkey = resp.publicKey;
          onSolanaWalletConnected(pubkey, pubkey.toString(), '🛡️', 'Trust Wallet');
        } catch (err) { toast('Connection rejected'); }
        return;
      }
    }

    function onSolanaWalletConnected(pubkey, address, icon, name) {
      walletPubkey = pubkey;
      walletAddress = address;
      $('wbtn').className = 'wallet-btn on';
      $('wbtn-icon').textContent = icon;
      $('wbtn-t').textContent = address.slice(0, 4) + '...' + address.slice(-4);
      $('lbtn').className = 'lbtn ready'; $('lbtn').textContent = '🚀 LAUNCH TOKEN';
      $('ph-stat').style.background = 'var(--green-dim)'; $('ph-stat').style.color = 'var(--green)'; $('ph-stat').textContent = 'CONNECTED';
      getWorkingConnection().then(conn => {
        conn.getBalance(pubkey).then(bal => { walletBalance = bal / 1e9; updateWalletPanel(); }).catch(() => {});
      }).catch(() => {});
      updateWalletPanel();
      toast(`✅ ${name} connected: ${address.slice(0, 8)}...`);
      $('tr-buy-btn').disabled = false;
      $('tr-sell-btn').disabled = false;
      setTimeout(refreshPositions, 500);
    }

    // ═══════ SOLANA SIGNER HELPER ═══════
    function getSolanaSigner() {
      if (activeWalletId === 'trustwallet') {
        const tw = WALLET_PROVIDERS.trustwallet.getSolana?.();
        if (tw) return tw;
      }
      if (activeWalletId === 'phantom' || !activeWalletId) {
        return getPhantom();
      }
      return getPhantom(); // fallback
    }

    async function connectEVMWithProvider(wp, providerId) {
      const evmEth = wp.getEVM();
      if (!evmEth) {
        toast(`${wp.name} EVM provider not found`);
        addMsg('system', `${wp.icon} **${wp.name} not detected for EVM.**\\n\\nInstall from ${wp.installUrl}`);
        return;
      }
      
      try {
        // Switch to correct chain
        const cfg = getChain();
        const currentChainId = await evmEth.request({ method: 'eth_chainId' });
        if (currentChainId !== cfg.chainIdHex) {
          try {
            await evmEth.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: cfg.chainIdHex }] });
          } catch (switchError) {
            if (switchError.code === 4902) {
              const addParams = {
                ethereum: { chainId: '0x1', chainName: 'Ethereum Mainnet', nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 }, rpcUrls: ['https://eth.llamarpc.com'], blockExplorerUrls: ['https://etherscan.io'] },
                base: { chainId: '0x2105', chainName: 'Base', nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 }, rpcUrls: ['https://mainnet.base.org'], blockExplorerUrls: ['https://basescan.org'] },
                bsc: { chainId: '0x38', chainName: 'BNB Smart Chain', nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 }, rpcUrls: ['https://bsc-dataseed.binance.org'], blockExplorerUrls: ['https://bscscan.com'] },
              };
              await evmEth.request({ method: 'wallet_addEthereumChain', params: [addParams[activeChain]] });
            } else throw switchError;
          }
        }
        
        const accounts = await evmEth.request({ method: 'eth_requestAccounts' });
        if (!accounts || accounts.length === 0) throw new Error('No accounts returned');
        
        walletAddress = accounts[0];
        walletPubkey = walletAddress;
        evmProvider = new ethers.providers.Web3Provider(evmEth);
        evmSigner = evmProvider.getSigner();
        
        $('wbtn').className = 'wallet-btn on';
        $('wbtn-icon').textContent = wp.icon;
        $('wbtn-t').textContent = walletAddress.slice(0, 4) + '...' + walletAddress.slice(-4);
        $('ph-stat').style.background = 'var(--green-dim)';
        $('ph-stat').style.color = 'var(--green)';
        $('ph-stat').textContent = 'CONNECTED';
        
        try {
          const balance = await evmProvider.getBalance(walletAddress);
          walletBalance = parseFloat(ethers.utils.formatEther(balance));
        } catch (e) { walletBalance = '—'; }
        
        updateWalletPanel();
        toast(`✅ ${wp.name} connected: ${walletAddress.slice(0, 8)}...`);
        $('tr-buy-btn').disabled = false;
        $('tr-sell-btn').disabled = false;
        setTimeout(refreshPositions, 500);
        
        // Listen for changes
        evmEth.on('accountsChanged', (accs) => {
          if (accs.length === 0) disconnectWallet();
          else { walletAddress = accs[0]; walletPubkey = accs[0]; updateWalletPanel(); }
        });
        evmEth.on('chainChanged', () => { window.location.reload(); });
        
      } catch (err) {
        if (err.code === 4001) toast('Connection rejected');
        else toast('❌ ' + (err.message || 'Connection failed').slice(0, 60));
      }
    }

    async function ensureEVMChain() {
      const cfg = getChain();
      const mm = getMetaMask();
      if (!mm) throw new Error('MetaMask not found');
      
      const currentChainId = await mm.request({ method: 'eth_chainId' });
      if (currentChainId !== cfg.chainIdHex) {
        try {
          await mm.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: cfg.chainIdHex }] });
        } catch (switchError) {
          if (switchError.code === 4902) {
            // Chain not added, add it
            const addParams = {
              ethereum: { chainId: '0x1', chainName: 'Ethereum Mainnet', nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 }, rpcUrls: ['https://eth.llamarpc.com'], blockExplorerUrls: ['https://etherscan.io'] },
              base: { chainId: '0x2105', chainName: 'Base', nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 }, rpcUrls: ['https://mainnet.base.org'], blockExplorerUrls: ['https://basescan.org'] },
              bsc: { chainId: '0x38', chainName: 'BNB Smart Chain', nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 }, rpcUrls: ['https://bsc-dataseed.binance.org'], blockExplorerUrls: ['https://bscscan.com'] },
            };
            await mm.request({ method: 'wallet_addEthereumChain', params: [addParams[activeChain]] });
          } else {
            throw switchError;
          }
        }
      }
    }

    async function getEVMProvider() {
      const cfg = getChain();
      for (const rpc of cfg.rpcUrls) {
        try {
          const provider = new ethers.providers.JsonRpcProvider(rpc);
          await provider.getBlockNumber(); // test connection
          return provider;
        } catch (e) { continue; }
      }
      return new ethers.providers.JsonRpcProvider(cfg.rpcUrls[0]);
    }

    async function connectEVMWallet() {
      const mm = getMetaMask();
      if (!mm) {
        toast('MetaMask not found — install it from metamask.io');
        addMsg('system', '🦊 **MetaMask not detected.**\n\nInstall MetaMask from https://metamask.io to trade on EVM chains (Ethereum, Base, BNB Chain).');
        return;
      }
      
      try {
        await ensureEVMChain();
        const accounts = await mm.request({ method: 'eth_requestAccounts' });
        if (!accounts || accounts.length === 0) throw new Error('No accounts returned');
        
        walletAddress = accounts[0];
        walletPubkey = walletAddress; // For EVM, we just use the address
        evmProvider = new ethers.providers.Web3Provider(mm);
        evmSigner = evmProvider.getSigner();
        
        const cfg = getChain();
        $('wbtn').className = 'wallet-btn on';
        $('wbtn-t').textContent = walletAddress.slice(0, 4) + '...' + walletAddress.slice(-4);
        $('ph-stat').style.background = 'var(--green-dim)';
        $('ph-stat').style.color = 'var(--green)';
        $('ph-stat').textContent = 'CONNECTED';
        
        // Get native balance
        try {
          const balance = await evmProvider.getBalance(walletAddress);
          walletBalance = parseFloat(ethers.utils.formatEther(balance));
        } catch (e) { walletBalance = '—'; }
        
        updateWalletPanel();
        toast('✅ Wallet connected: ' + walletAddress.slice(0, 8) + '...');
        $('tr-buy-btn').disabled = false;
        $('tr-sell-btn').disabled = false;
        setTimeout(refreshPositions, 500);
        
        // Listen for account/chain changes
        mm.on('accountsChanged', (accs) => {
          if (accs.length === 0) disconnectWallet();
          else { walletAddress = accs[0]; walletPubkey = accs[0]; updateWalletPanel(); }
        });
        mm.on('chainChanged', () => { window.location.reload(); });
        
      } catch (err) {
        if (err.code === 4001) toast('Connection rejected');
        else toast('❌ ' + (err.message || 'Connection failed').slice(0, 60));
      }
    }

    // ═══════ EVM TOKEN HELPERS ═══════
    const ERC20_ABI = [
      'function balanceOf(address) view returns (uint256)',
      'function decimals() view returns (uint8)',
      'function symbol() view returns (string)',
      'function name() view returns (string)',
      'function allowance(address owner, address spender) view returns (uint256)',
      'function approve(address spender, uint256 amount) returns (bool)',
    ];

    async function getEVMTokenBalance(tokenAddress) {
      try {
        if (!walletAddress || !evmProvider) return 0;
        const contract = new ethers.Contract(tokenAddress, ERC20_ABI, evmProvider);
        const [balance, decimals] = await Promise.all([
          contract.balanceOf(walletAddress),
          contract.decimals(),
        ]);
        return parseFloat(ethers.utils.formatUnits(balance, decimals));
      } catch (e) { return 0; }
    }

    async function getEVMTokenDecimals(tokenAddress) {
      try {
        const provider = evmProvider || await getEVMProvider();
        const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
        return await contract.decimals();
      } catch (e) { return 18; }
    }

    // ═══════ EVM SWAP VIA OPENOCEAN ═══════
    const OPENOCEAN_API = 'https://open-api.openocean.finance/v3';

    async function openOceanQuote(inToken, outToken, amount, slippage, chainKey) {
      const cfg = CHAINS[chainKey || activeChain];
      const url = `${OPENOCEAN_API}/${cfg.openOceanChain}/quote?inTokenAddress=${inToken}&outTokenAddress=${outToken}&amount=${amount}&gasPrice=5&slippage=${slippage}`;
      const res = await fetchWithTimeout(url, {}, 10000);
      if (!res.ok) throw new Error('OpenOcean quote failed: ' + res.status);
      const data = await res.json();
      if (data.code !== 200) throw new Error(data.error || 'Quote error');
      return data.data;
    }

    async function openOceanSwap(inToken, outToken, amount, slippage, account, chainKey) {
      const cfg = CHAINS[chainKey || activeChain];
      const gasPrice = '5'; // Will be overridden by wallet
      const url = `${OPENOCEAN_API}/${cfg.openOceanChain}/swap_quote?inTokenAddress=${inToken}&outTokenAddress=${outToken}&amount=${amount}&gasPrice=${gasPrice}&slippage=${slippage}&account=${account}`;
      const res = await fetchWithTimeout(url, {}, 15000);
      if (!res.ok) throw new Error('OpenOcean swap failed: ' + res.status);
      const data = await res.json();
      if (data.code !== 200) throw new Error(data.error || 'Swap error');
      return data.data;
    }

    async function executeEVMTrade(side) {
      if (!walletAddress || !evmSigner) { toast('Connect wallet first!'); return; }
      if (isTrading) return;
      
      const cfg = getChain();
      const mint = $('tr-mint').value.trim();
      const amount = parseFloat($('tr-amount').value);
      const slippage = parseFloat($('tr-slippage').value) || 1;
      
      if (!mint || !cfg.addressRegex.test(mint)) { toast('Paste a valid ' + cfg.name + ' token address'); return; }
      if (!amount || amount <= 0) { toast('Enter an amount'); return; }
      
      isTrading = true;
      const btn = side === 'buy' ? $('tr-buy-btn') : $('tr-sell-btn');
      const origText = btn.textContent;
      btn.classList.add('loading');
      btn.disabled = true;
      
      try {
        let inToken, outToken, swapAmount;
        
        if (side === 'buy') {
          // Buying token with native currency
          inToken = cfg.nativeMint;
          outToken = mint;
          swapAmount = amount; // amount in native token (ETH/BNB)
        } else {
          // Selling token for native currency
          inToken = mint;
          outToken = cfg.nativeMint;
          // Get token balance
          const tokenBal = await getEVMTokenBalance(mint);
          if (!tokenBal || tokenBal <= 0) throw new Error('No token balance to sell');
          swapAmount = tokenBal * (sellPct / 100);
        }
        
        btn.textContent = 'GETTING QUOTE...';
        
        // Get swap data from OpenOcean
        btn.textContent = 'BUILDING TX...';
        const swapData = await openOceanSwap(inToken, outToken, swapAmount, slippage, walletAddress);
        
        if (!swapData || !swapData.to) throw new Error('Failed to build swap transaction');
        
        // Check if we need to approve the token first (for sells)
        if (side === 'sell') {
          btn.textContent = 'CHECKING APPROVAL...';
          const tokenContract = new ethers.Contract(mint, ERC20_ABI, evmSigner);
          const allowance = await tokenContract.allowance(walletAddress, swapData.to);
          const decimals = await tokenContract.decimals();
          const requiredAmount = ethers.utils.parseUnits(String(swapAmount), decimals);
          
          if (allowance.lt(requiredAmount)) {
            btn.textContent = 'APPROVE IN WALLET...';
            const approveTx = await tokenContract.approve(swapData.to, ethers.constants.MaxUint256);
            btn.textContent = 'WAITING APPROVAL...';
            await approveTx.wait();
            toast('✅ Token approved');
          }
        }
        
        // Build and send transaction
        btn.textContent = 'SIGN IN ' + (activeWalletId ? WALLET_PROVIDERS[activeWalletId].name.toUpperCase() : 'WALLET') + '...';
        
        const txParams = {
          to: swapData.to,
          data: swapData.data,
          value: side === 'buy' ? ethers.utils.parseEther(String(amount)) : ethers.BigNumber.from(swapData.value || '0'),
          gasLimit: swapData.estimatedGas ? ethers.BigNumber.from(swapData.estimatedGas).mul(130).div(100) : undefined,
        };
        
        const tx = await evmSigner.sendTransaction(txParams);
        
        btn.textContent = 'CONFIRMING...';
        const receipt = await tx.wait();
        
        if (receipt.status === 0) throw new Error('Transaction reverted on-chain');
        
        // Success
        const symbol = $('tr-token-name')?.textContent || mint.slice(0, 10);
        const outAmount = swapData.outAmount ? parseFloat(swapData.outAmount) : 0;
        
        toast(`✅ ${side === 'buy' ? 'Bought' : 'Sold'} ${symbol}!`, 5000);
        
        const trade = {
          side, symbol, mint, chain: activeChain,
          amountIn: side === 'buy' ? amount + ' ' + cfg.symbol : formatNum(swapAmount) + ' ' + symbol,
          amountOut: side === 'buy' ? formatNum(outAmount) + ' ' + symbol : outAmount.toFixed(6) + ' ' + cfg.symbol,
          sig: tx.hash,
          time: Date.now(),
        };
        tradeHistory.unshift(trade);
        if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
        lsSetJSON('ghost-trades', tradeHistory);
        renderTradeHistory();
        
        if ($('empty-state')) $('empty-state').style.display = 'none';
        addMsg('success',
          `${side === 'buy' ? '🟢 BUY' : '🔴 SELL'} EXECUTED on ${cfg.name}\n\nToken: ${symbol}\nPaid: ${trade.amountIn}\nReceived: ${trade.amountOut}\nTx: ${tx.hash.slice(0, 20)}...\n\n🔍 ${cfg.explorerTx}${tx.hash}`
        );
        
        // Refresh balance
        try {
          const balance = await evmProvider.getBalance(walletAddress);
          walletBalance = parseFloat(ethers.utils.formatEther(balance));
          updateWalletPanel();
        } catch(e) {}
        
        setTimeout(refreshPositions, 3000);
        
      } catch(e) {
        console.error('EVM Trade error:', e);
        const errMsg = e.message || 'Trade failed';
        if (errMsg.includes('user rejected') || errMsg.includes('User denied') || errMsg.includes('ACTION_REJECTED')) {
          toast('Transaction rejected in wallet');
        } else {
          toast('❌ ' + errMsg.slice(0, 60));
          if ($('empty-state')) $('empty-state').style.display = 'none';
          addMsg('system', `❌ ${side.toUpperCase()} failed on ${getChain().name}: ${errMsg}`);
        }
      }
      
      isTrading = false;
      const btn2 = side === 'buy' ? $('tr-buy-btn') : $('tr-sell-btn');
      btn2.classList.remove('loading');
      btn2.disabled = !walletAddress;
      btn2.textContent = side === 'buy' ? '🟢 BUY TOKEN' : `🔴 SELL ${sellPct}%`;
    }

    // ═══════ EVM POSITIONS ═══════
    async function refreshEVMPositions() {
      if (!walletAddress) {
        $('positions-list').innerHTML = '<div class="pos-empty">Connect wallet to see positions</div>';
        return;
      }
      $('positions-list').innerHTML = '<div class="pos-empty">Loading positions...</div>';
      
      try {
        const cfg = getChain();
        // Use DexScreener to find tokens in wallet via their API
        // Alternative: use blockchain explorer APIs
        // For now, use a simpler approach - check recent trade history tokens
        const chainTokens = tradeHistory
          .filter(t => (t.chain || 'solana') === activeChain && t.side === 'buy')
          .map(t => t.mint)
          .filter((v, i, a) => a.indexOf(v) === i) // unique
          .slice(0, 20);
        
        if (chainTokens.length === 0) {
          $('positions-list').innerHTML = '<div class="pos-empty">No tracked positions on ' + cfg.name + '.<br>Tokens you buy will appear here.</div>';
          return;
        }
        
        const provider = evmProvider || await getEVMProvider();
        const positions = [];
        
        for (const tokenAddr of chainTokens) {
          try {
            const contract = new ethers.Contract(tokenAddr, ERC20_ABI, provider);
            const [balance, decimals, symbol] = await Promise.all([
              contract.balanceOf(walletAddress),
              contract.decimals(),
              contract.symbol().catch(() => tokenAddr.slice(0, 6)),
            ]);
            const amt = parseFloat(ethers.utils.formatUnits(balance, decimals));
            if (amt > 0) {
              positions.push({ mint: tokenAddr, amount: amt, symbol, decimals });
            }
          } catch (e) { continue; }
        }
        
        if (positions.length === 0) {
          $('positions-list').innerHTML = '<div class="pos-empty">No token positions on ' + cfg.name + '</div>';
          return;
        }
        
        // Get prices from DexScreener
        let prices = {};
        try {
          const addrs = positions.map(p => p.mint).join(',');
          const dsRes = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${addrs}`);
          if (dsRes.ok) {
            const dsData = await dsRes.json();
            (dsData.pairs || []).filter(p => p.chainId === cfg.dexScreenerChain).forEach(pair => {
              const addr = pair.baseToken?.address?.toLowerCase();
              if (addr && pair.priceUsd) {
                prices[addr] = { price: parseFloat(pair.priceUsd), symbol: pair.baseToken.symbol };
              }
            });
          }
        } catch (e) {}
        
        let html = '';
        for (const pos of positions) {
          const priceInfo = prices[pos.mint.toLowerCase()] || {};
          const price = priceInfo.price || 0;
          const value = price * pos.amount;
          const sym = priceInfo.symbol || pos.symbol || pos.mint.slice(0, 6);
          
          html += `<div class="pos-item">
            <div class="pos-top">
              <div class="pos-name">${escapeHtml(sym)}</div>
              <div class="pos-val">${value > 0 ? '$' + value.toFixed(2) : '—'}</div>
            </div>
            <div class="pos-bottom">
              <span>${formatNum(pos.amount)} tokens</span>
              <span>${price > 0 ? '$' + (price < 0.01 ? price.toFixed(8) : price.toFixed(4)) : 'price N/A'}</span>
            </div>
            <div style="display:flex;gap:6px;margin-top:6px;">
              <button class="tk-btn buy" style="font-size:10px;padding:4px 8px;" onclick="$('tr-mint').value='${pos.mint}';setMode('trade');onMintInput('${pos.mint}');">BUY</button>
              <button class="tk-btn" style="font-size:10px;padding:4px 8px;background:var(--red-dim);color:var(--red);" onclick="$('tr-mint').value='${pos.mint}';setMode('trade');onMintInput('${pos.mint}');setTimeout(()=>setSellPct(100),500);">SELL</button>
              <button class="tk-btn" style="font-size:10px;padding:4px 8px;" onclick="window.open('${cfg.explorerAddr}${pos.mint}','_blank')">🔍</button>
            </div>
          </div>`;
        }
        
        $('positions-list').innerHTML = html;
        
      } catch (e) {
        $('positions-list').innerHTML = '<div class="pos-empty">Error loading positions: ' + escapeHtml(e.message) + '</div>';
      }
    }

    // ═══════ EVM TOKEN LOOKUP ═══════
    async function lookupEVMToken(address) {
      try {
        const cfg = getChain();
        // Use DexScreener which works for all chains
        const dsRes = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${address}`);
        if (!dsRes.ok) return;
        const dsData = await dsRes.json();
        const pairs = (dsData.pairs || []).filter(p => p.chainId === cfg.dexScreenerChain);
        
        if (pairs.length > 0) {
          const best = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
          $('tr-token-name').textContent = best.baseToken?.symbol || address.slice(0, 10);
          $('tr-token-price').textContent = best.priceUsd ? '$' + parseFloat(best.priceUsd).toFixed(best.priceUsd < 0.01 ? 8 : 4) : 'price N/A';
          $('tr-token-info').style.display = 'block';
          $('tr-buy-btn').disabled = !walletAddress;
          $('tr-sell-btn').disabled = !walletAddress;
          if (parseFloat($('tr-amount').value) > 0) getQuote();
        } else {
          // Try to read from contract directly
          try {
            const provider = evmProvider || await getEVMProvider();
            const contract = new ethers.Contract(address, ERC20_ABI, provider);
            const [symbol, name] = await Promise.all([
              contract.symbol().catch(() => address.slice(0, 8)),
              contract.name().catch(() => ''),
            ]);
            $('tr-token-name').textContent = symbol;
            $('tr-token-price').textContent = 'price unavailable';
            $('tr-token-info').style.display = 'block';
            $('tr-buy-btn').disabled = !walletAddress;
            $('tr-sell-btn').disabled = !walletAddress;
          } catch (e) {
            $('tr-token-name').textContent = address.slice(0, 10) + '...';
            $('tr-token-price').textContent = 'unknown token';
            $('tr-token-info').style.display = 'block';
          }
        }
      } catch (e) {
        $('tr-token-info').style.display = 'none';
      }
    }

    // ═══════ EVM QUOTE ═══════
    async function getEVMQuote() {
      const cfg = getChain();
      const mint = $('tr-mint').value.trim();
      const amount = parseFloat($('tr-amount').value);
      const slippage = parseFloat($('tr-slippage').value) || 1;
      if (!mint || !cfg.addressRegex.test(mint) || !amount || amount <= 0) {
        $('tr-quote').style.display = 'none';
        currentQuote = null;
        return;
      }
      clearTimeout(quoteTimer);
      quoteTimer = setTimeout(async () => {
        try {
          const quoteData = await openOceanQuote(cfg.nativeMint, mint, amount, slippage);
          currentQuote = quoteData;
          
          $('tq-pay').textContent = amount + ' ' + cfg.symbol;
          const outAmt = parseFloat(quoteData.outAmount || 0);
          $('tq-receive').textContent = formatNum(outAmt) + ' tokens';
          // Price impact (estimated)
          const estimatedImpact = quoteData.price_impact || quoteData.priceImpact || 0;
          $('tq-impact').textContent = (parseFloat(estimatedImpact) || 0).toFixed(3) + '%';
          $('tq-route').textContent = cfg.dexName + ' (OpenOcean)';
          $('tr-quote').style.display = 'block';
        } catch (e) {
          $('tr-quote').style.display = 'none';
          currentQuote = null;
        }
      }, 400);
    }

    // ═══════ EVM WALLET PANEL ═══════
    function updateEVMWalletPanel() {
      if (!walletAddress) return;
      const cfg = getChain();
      const wp = activeWalletId ? WALLET_PROVIDERS[activeWalletId] : null;
      const walletIcon = wp ? wp.icon : cfg.walletIcon;
      const walletName = wp ? wp.name : cfg.walletName;
      const shortAddr = walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
      $('wallet-content').innerHTML = `
        <div class="wp-header">
          <div class="wp-avatar">${walletIcon}</div>
          <div class="wp-balance">${typeof walletBalance === 'number' ? walletBalance.toFixed(6) : '—'}</div>
          <div class="wp-balance-label">${cfg.symbol} BALANCE <span style="color:${cfg.color};font-size:10px;margin-left:4px;">${cfg.name}</span></div>
          <div class="wp-addr">
            <span>${shortAddr}</span>
            <button class="wp-addr-copy" onclick="navigator.clipboard.writeText('${walletAddress}');toast('📋 Copied!')">Copy</button>
          </div>
        </div>
        <div class="wp-actions">
          <button class="wp-action" onclick="window.open('${cfg.explorerAddr}${walletAddress}','_blank')">
            <span class="wp-action-icon">🔍</span>Explorer
          </button>
          <button class="wp-action" onclick="setMode('portfolio')">
            <span class="wp-action-icon">◐</span>Portfolio
          </button>
          <button class="wp-action danger" onclick="disconnectWallet()">
            <span class="wp-action-icon">⏏</span>Disconnect
          </button>
        </div>
        <div class="wp-section">
          <div class="wp-stitle">${cfg.name} Holdings</div>
          <div id="wp-holdings"><div class="wp-loading">Loading tokens...</div></div>
        </div>`;
      // Fetch EVM holdings
      fetchEVMWalletHoldings();
    }

    async function fetchEVMWalletHoldings() {
      const holdingsEl = $('wp-holdings');
      if (!holdingsEl || !walletAddress) return;
      
      try {
        const cfg = getChain();
        // Check recent traded tokens
        const tokenAddrs = tradeHistory
          .filter(t => (t.chain || 'solana') === activeChain && t.side === 'buy')
          .map(t => t.mint)
          .filter((v, i, a) => a.indexOf(v) === i)
          .slice(0, 15);
        
        if (tokenAddrs.length === 0) {
          holdingsEl.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted);font-size:12px;">No tracked holdings on ' + cfg.name + '.<br>Tokens you trade will appear here.</div>';
          return;
        }
        
        const provider = evmProvider || await getEVMProvider();
        let html = '';
        
        for (const addr of tokenAddrs) {
          try {
            const contract = new ethers.Contract(addr, ERC20_ABI, provider);
            const [balance, decimals, symbol] = await Promise.all([
              contract.balanceOf(walletAddress),
              contract.decimals(),
              contract.symbol().catch(() => addr.slice(0, 6)),
            ]);
            const amt = parseFloat(ethers.utils.formatUnits(balance, decimals));
            if (amt > 0) {
              html += `<div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid var(--border-primary);font-size:12px;">
                <span style="color:var(--text-primary);font-weight:600;">${escapeHtml(symbol)}</span>
                <span style="color:var(--text-secondary);font-family:'Fira Code',monospace;">${formatNum(amt)}</span>
              </div>`;
            }
          } catch (e) { continue; }
        }
        
        holdingsEl.innerHTML = html || '<div style="text-align:center;padding:20px;color:var(--text-muted);font-size:12px;">No token balances found</div>';
        
      } catch (e) {
        holdingsEl.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted);font-size:12px;">Error loading holdings</div>';
      }
    }


    const $ = id => document.getElementById(id);

    // ═══════ THEME ═══════
    function toggleTheme() {
      const html = document.documentElement;
      const current = html.getAttribute('data-theme');
      const next = current === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', next);
      $('theme-btn').textContent = next === 'dark' ? '☀️' : '🌙';
      lsSet('ghost-theme', next);
    }

    // Restore saved theme on load
    (function initTheme() {
      const saved = lsGet('ghost-theme', '');
      if (saved) {
        document.documentElement.setAttribute('data-theme', saved);
      }
      // Icon will be set after DOM ready below
    })();

    // ═══════ TOAST ═══════
    function toast(msg, dur = 3000) {
      const t = $('toast'); t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), dur);
    }

    // ═══════ WEB SEARCH ═══════
    function toggleWebSearch() {
      webSearchEnabled = !webSearchEnabled;
      lsSet('ghost-websearch', webSearchEnabled);
      updateWsBtn();
      toast(webSearchEnabled ? '🔍 Web search enabled' : 'Web search disabled');
    }

    function updateWsBtn() {
      const btn = $('ws-btn');
      btn.classList.toggle('on', webSearchEnabled);
      $('input').placeholder = webSearchEnabled
        ? 'Ask anything — web search enabled 🔍'
        : 'Ask about crypto, trade tokens, launch, analyze...';
    }

    // ═══════ MODES ═══════
    let modeHistory = [];

    function setMode(mode) {
      // Cleanup timers when leaving modes
      if (currentMode === 'trade' && mode !== 'trade') {
        clearTimeout(quoteTimer); quoteTimer = null;
      }
      if (currentMode === 'perps' && mode !== 'perps') {
        if (perpsPnlInterval) { clearInterval(perpsPnlInterval); perpsPnlInterval = null; }
      }
      if (currentMode && currentMode !== mode) modeHistory.push(currentMode);
      if (modeHistory.length > 10) modeHistory = modeHistory.slice(-10);
      currentMode = mode;
      lsSet('ghost-mode', mode);
      document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
      $('p-trade').style.display = mode === 'trade' ? 'block' : 'none';
      $('p-launch').style.display = mode === 'launch' ? 'block' : 'none';
      $('p-tools').style.display = mode === 'tools' ? 'block' : 'none';
      $('p-wallet').style.display = mode === 'wallet' ? 'block' : 'none';
      $('p-history').style.display = mode === 'history' ? 'block' : 'none';
      $('p-sniper').style.display = mode === 'sniper' ? 'block' : 'none';
      $('p-intel').style.display = mode === 'intel' ? 'block' : 'none';
      $('p-portfolio').style.display = mode === 'portfolio' ? 'block' : 'none';
      $('p-alpha').style.display = mode === 'alpha' ? 'block' : 'none';
      $('p-watchlist').style.display = mode === 'watchlist' ? 'block' : 'none';
      $('p-chart').style.display = mode === 'chart' ? 'block' : 'none';
      $('p-bundle').style.display = mode === 'bundle' ? 'block' : 'none';



      // Perps takes over the full screen
      const isPerps = mode === 'perps';
      $('p-perps').style.display = isPerps ? 'flex' : 'none';
      $('main-layout').style.display = isPerps ? 'none' : 'flex';
      $('input-area').style.display = isPerps ? 'none' : '';
      $('app-footer').style.display = isPerps ? 'none' : '';

      if (!isPerps) $('sidebar').classList.toggle('open', mode !== 'chat');
      if (mode === 'history') { renderChatHistory(); renderTxHistory(); }
      if (mode === 'sniper') { renderSniperWallets(); refreshSniperBalances(); }
      if (mode === 'portfolio') { refreshPortfolio(); }
      if (mode === 'alpha') { renderAlphaWallets(); renderAlphaLog(); renderAlphaBotWallet(); refreshAlphaBotBalance(); }
      if (mode === 'watchlist') { renderWatchlist(); refreshWatchlistPrices(); }
      if (mode === 'perps') { initPerpsPanel(); }

      // In launch mode, only show SOL and BNB chains
      const ethBtn = document.querySelector('.chain-btn[data-chain="ethereum"]');
      const baseBtn = document.querySelector('.chain-btn[data-chain="base"]');
      if (ethBtn) ethBtn.style.display = mode === 'launch' ? 'none' : '';
      if (baseBtn) baseBtn.style.display = mode === 'launch' ? 'none' : '';
      
      // If entering launch mode on ETH/BASE, auto-switch to SOL
      if (mode === 'launch' && (activeChain === 'ethereum' || activeChain === 'base')) {
        switchChain('solana');
      }
      // Update launch platform visibility when entering launch
      if (mode === 'launch') updateLaunchPlatforms();
    }

    function goBack() {
      const prev = modeHistory.pop() || 'tools';
      setMode(prev);
      // Remove the duplicate push that setMode just added
      if (modeHistory.length && modeHistory[modeHistory.length - 1] === prev) modeHistory.pop();
    }

    function selPlatform(p) {
      selectedPlatform = p;
      document.querySelectorAll('.lplatform').forEach(el => el.classList.toggle('sel', el.dataset.p === p));
    }

    function updateLaunchPlatforms() {
      const isBNB = activeChain === 'bsc';
      // Show/hide platform options
      document.querySelectorAll('.sol-platform').forEach(el => el.style.display = isBNB ? 'none' : '');
      document.querySelectorAll('.bnb-platform').forEach(el => el.style.display = isBNB ? '' : 'none');
      
      // Auto-select the right platform
      if (isBNB) {
        selPlatform('fourmeme');
      } else if (selectedPlatform === 'fourmeme') {
        selPlatform('pumpfun');
      }
      
      // Update form labels
      const sym = isBNB ? 'BNB' : 'SOL';
      const chainName = isBNB ? 'BNB Chain' : 'Solana';
      if ($('launch-buy-label')) $('launch-buy-label').textContent = `INITIAL BUY (${sym})`;
      if ($('launch-warning')) $('launch-warning').textContent = `⚠️ This creates a real token on ${chainName}. You need ${sym} for gas (~${isBNB ? '0.005 BNB' : '0.02 SOL'}). DYOR. Ghost is a tool — you are responsible for your actions.`;
    }


    // ═══════ FOUR.MEME (BNB CHAIN) LAUNCHER ═══════
    const FOURMEME_CONTRACT = '0x5c952063c7fc8610FFDB798152D69F0B9550762b';
    const FOURMEME_CREATE_FEE = '0.01'; // 0.01 BNB creation fee
    const FOURMEME_API_BASE = 'https://four.meme';

    async function launchTokenFourMeme() {
      if (!walletAddress) { toast('Connect wallet first!'); return; }
      if (!evmSigner) { toast('Connect a BNB wallet first!'); return; }

      const name = $('t-name').value.trim();
      const ticker = $('t-ticker').value.trim().replace('$', '');
      const desc = $('t-desc').value.trim();
      const initialBuy = parseFloat($('t-buy').value) || 0;
      const twitter = $('t-twitter').value.trim();
      const telegram = $('t-telegram').value.trim();
      const website = $('t-website').value.trim();

      if (!name) { toast('Token name is required!'); return; }
      if (!ticker) { toast('Ticker is required!'); return; }
      if (!tokenImageFile) { toast('Token image is required!'); return; }

      $('launch-steps').style.display = 'block';
      if ($('step-1-label')) $('step-1-label').textContent = 'Upload image to Four.meme';
      if ($('step-2-label')) $('step-2-label').textContent = 'Prepare token';
      if ($('step-3-label')) $('step-3-label').textContent = 'Sign transaction';
      if ($('step-4-label')) $('step-4-label').textContent = 'Confirm on BSC';
      $('lbtn').className = 'lbtn loading'; $('lbtn').textContent = 'LAUNCHING ON FOUR.MEME...';

      let apiWorked = false;

      try {
        // ═══ Step 1: Upload image ═══
        setStep(1, 'active', 'uploading image...');
        
        let imageUrl = '';
        const imgFormData = new FormData();
        imgFormData.append('file', tokenImageFile);
        
        try {
          const imgRes = await fetchWithTimeout(`${FOURMEME_API_BASE}/meme-api/upload/img`, {
            method: 'POST', body: imgFormData,
          }, 15000);
          if (imgRes.ok) {
            const imgData = await imgRes.json();
            imageUrl = imgData.data || imgData.url || '';
          }
        } catch (e) {
          console.warn('Four.meme image upload (CORS expected):', e.message);
        }
        
        // Base64 fallback if API blocked by CORS
        if (!imageUrl) {
          imageUrl = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => resolve('');
            reader.readAsDataURL(tokenImageFile);
          });
        }
        setStep(1, 'done', '✓');

        // ═══ Step 2: Try Four.meme prepare API for createArg + signature ═══
        setStep(2, 'active', 'preparing token...');
        
        let createArg = null;
        let apiSign = null;

        try {
          const prepareRes = await fetchWithTimeout(`${FOURMEME_API_BASE}/meme-api/token/prepare`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name, symbol: ticker,
              desc: desc || name + ' — launched via Ghost',
              image: imageUrl, label: 'Meme', onlyMPC: false,
              webUrl: website, twitterUrl: twitter, telegramUrl: telegram,
              presaleBNB: String(initialBuy || 0),
              creator: walletAddress,
            }),
          }, 15000);

          if (prepareRes.ok) {
            const prepData = await prepareRes.json();
            if (prepData.data) {
              createArg = prepData.data.createArg || prepData.data.arg || prepData.data;
              apiSign = prepData.data.sign || prepData.data.signature;
              if (createArg && apiSign) apiWorked = true;
            }
          }
        } catch (e) {
          console.warn('Four.meme prepare API (CORS expected):', e.message);
        }

        if (apiWorked) {
          // ═══ API path: call contract with createArg + sign ═══
          setStep(2, 'done', '✓');
          setStep(3, 'active', 'sign in wallet...');

          const totalValue = ethers.utils.parseEther(
            String(parseFloat(FOURMEME_CREATE_FEE) + (initialBuy || 0))
          );

          // Encode createToken(createArg, sign) call
          const iface = new ethers.utils.Interface([
            'function createToken(tuple(string,string,string,string,string,uint256,bool,string,string,string) createArg, bytes sign) payable',
          ]);
          const txData = iface.encodeFunctionData('createToken', [createArg, apiSign]);

          const txResponse = await evmSigner.sendTransaction({
            to: FOURMEME_CONTRACT, data: txData,
            value: totalValue, gasLimit: 3000000,
          });
          setStep(3, 'done', '✓');

          setStep(4, 'active', 'confirming on BSC...');
          const receipt = await txResponse.wait();
          
          // Parse TokenCreate event for new token address
          let tokenAddress = null;
          for (const log of receipt.logs) {
            if (log.address && log.address.toLowerCase() === FOURMEME_CONTRACT.toLowerCase() && log.topics.length >= 2) {
              try { tokenAddress = ethers.utils.getAddress('0x' + log.topics[1].slice(26)); } catch (e) {}
            }
            if (!tokenAddress && log.address && log.address.toLowerCase() !== FOURMEME_CONTRACT.toLowerCase() && log.topics.length >= 1) {
              try { tokenAddress = ethers.utils.getAddress(log.address); } catch (e) {}
            }
          }
          setStep(4, 'done', '✓');
          setStep(5, 'done', '🎉 LIVE!');

          const txHash = receipt.transactionHash;
          if ($('empty-state')) $('empty-state').style.display = 'none';
          addMsg('success',
            `🎉 TOKEN LAUNCHED ON FOUR.MEME!\n\nName: ${name}\nTicker: $${ticker}\n${tokenAddress ? 'Token: ' + tokenAddress + '\n' : ''}${initialBuy > 0 ? 'Initial Buy: ' + initialBuy + ' BNB\n' : ''}Tx: ${txHash.slice(0, 20)}...\n\n🔗 View: https://four.meme/token/${tokenAddress || ''}\n🔍 BscScan: https://bscscan.com/tx/${txHash}`
          );
          toast('🎉 $' + ticker + ' is live on Four.meme!');

        } else {
          // ═══ Fallback: CORS blocked API — open Four.meme directly ═══
          setStep(2, 'done', '↗ redirect');
          setStep(3, 'active', 'opening Four.meme...');

          window.open('https://four.meme/create-token', '_blank');

          setStep(3, 'done', '✓');
          setStep(4, 'done', '↗');
          setStep(5, 'done', '🔗');

          if ($('empty-state')) $('empty-state').style.display = 'none';
          addMsg('system',
            `🟡 **Redirected to Four.meme**\n\nFour.meme\'s API blocks direct browser calls (CORS). We opened **four.meme/create-token** in a new tab.\n\n**Your token details to paste there:**\n• Name: ${name}\n• Ticker: $${ticker}\n• Description: ${desc || '—'}\n• Initial Buy: ${initialBuy || 0} BNB\n\nThe token launches on a bonding curve and auto-lists on PancakeSwap when filled (~18 BNB).\nCreation fee: 0.01 BNB.`
          );
          toast('🟡 Four.meme opened in new tab');
        }

        setTimeout(() => {
          $('launch-steps').style.display = 'none';
          [1,2,3,4,5].forEach(n => setStep(n, 'pending', ''));
          $('lbtn').className = 'lbtn ready'; $('lbtn').textContent = '🚀 LAUNCH TOKEN';
        }, 6000);

      } catch (err) {
        console.error('Four.meme launch error:', err);
        for (let i = 1; i <= 5; i++) {
          if ($('step-' + i) && $('step-' + i).classList.contains('active')) {
            setStep(i, 'error', '✗ ' + (err.message || 'failed').slice(0, 40)); break;
          }
        }
        if ($('empty-state')) $('empty-state').style.display = 'none';

        const errMsg = err.message || 'Unknown error';
        let helpText = '';
        if (errMsg.includes('user rejected') || errMsg.includes('ACTION_REJECTED')) {
          helpText = 'You rejected the transaction in your wallet.';
        } else if (errMsg.includes('insufficient funds')) {
          helpText = 'Not enough BNB. Need 0.01 BNB (creation fee) + gas + initial buy.';
        } else {
          helpText = errMsg + '\n\nYou can also launch at https://four.meme/create-token';
        }
        addMsg('system', '❌ Four.meme launch failed\n\n' + helpText);
        $('lbtn').className = 'lbtn ready'; $('lbtn').textContent = '🚀 RETRY LAUNCH';
        setTimeout(() => { $('launch-steps').style.display = 'none'; [1,2,3,4,5].forEach(n => setStep(n, 'pending', '')); }, 8000);
      }
    }


    // ═══════ TOOL ACTIONS ═══════
    function toolOpen(mode) {
      setMode(mode);
    }

    function toolChat(prompt) {
      setMode('chat');
      $('input').value = prompt;
      setTimeout(() => sendMessage(), 100);
    }

    // ═══════ CHAT SESSIONS ═══════
    function generateId() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 6); }

    function saveCurrentSession() {
      if (chatMessages.length === 0) return;
      if (!currentSessionId) currentSessionId = generateId();
      const firstUserMsg = chatMessages.find(m => m.role === 'user');
      const title = firstUserMsg ? firstUserMsg.content.slice(0, 60) : 'New Chat';
      const existing = chatSessions.findIndex(s => s.id === currentSessionId);
      const session = {
        id: currentSessionId,
        title: title,
        messages: chatMessages,
        msgCount: chatMessages.length,
        created: existing >= 0 ? chatSessions[existing].created : Date.now(),
        updated: Date.now()
      };
      if (existing >= 0) {
        chatSessions[existing] = session;
      } else {
        chatSessions.unshift(session);
      }
      // Keep max 50 sessions
      if (chatSessions.length > 50) chatSessions = chatSessions.slice(0, 50);
      lsSetJSON('ghost-chat-sessions', chatSessions);
      lsSet('ghost-current-session', currentSessionId);
    }

    function newChat() {
      saveCurrentSession();
      chatMessages = [];
      currentSessionId = generateId();
      lsSet('ghost-current-session', currentSessionId);
      $('messages').innerHTML = '';
      const es = $('empty-state');
      if (es) es.style.display = 'flex';
      else {
        const div = document.createElement('div');
        div.className = 'empty-state'; div.id = 'empty-state';
        div.innerHTML = '<div class="eicon">◬</div><div class="etitle">Ghost Crypto</div><div class="edesc">AI-powered crypto command center. Chat with Claude, trade tokens via Jupiter, launch on pump.fun, manage your wallet.</div>';
        $('messages').appendChild(div);
      }
      setMode('chat');
      $('input').focus();
      toast('New chat started');
    }

    function loadSession(id) {
      saveCurrentSession();
      const session = chatSessions.find(s => s.id === id);
      if (!session) return;
      currentSessionId = session.id;
      lsSet('ghost-current-session', currentSessionId);
      chatMessages = [...session.messages];
      $('messages').innerHTML = '';
      if ($('empty-state')) $('empty-state').style.display = 'none';
      for (const msg of chatMessages) {
        if (msg.role === 'user' || msg.role === 'assistant') {
          addMsg(msg.role, msg.content, false);
        }
      }
      setMode('chat');
      toast('Chat loaded');
    }

    function deleteSession(id, evt) {
      evt.stopPropagation();
      chatSessions = chatSessions.filter(s => s.id !== id);
      lsSetJSON('ghost-chat-sessions', chatSessions);
      if (currentSessionId === id) {
        currentSessionId = null;
        lsRemove('ghost-current-session');
        chatMessages = [];
        $('messages').innerHTML = '';
        const div = document.createElement('div');
        div.className = 'empty-state'; div.id = 'empty-state';
        div.innerHTML = '<div class="eicon">◬</div><div class="etitle">Ghost Crypto</div><div class="edesc">AI-powered crypto command center. Chat with Claude, trade tokens via Jupiter, launch on pump.fun, manage your wallet.</div>';
        $('messages').appendChild(div);
      }
      renderChatHistory();
      toast('Chat deleted');
    }

    function setHistTab(tab) {
      $('ht-chats').classList.toggle('active', tab === 'chats');
      $('ht-txs').classList.toggle('active', tab === 'txs');
      $('ht-pnl').classList.toggle('active', tab === 'pnl');
      $('hist-chats').style.display = tab === 'chats' ? 'block' : 'none';
      $('hist-txs').style.display = tab === 'txs' ? 'block' : 'none';
      $('hist-pnl').style.display = tab === 'pnl' ? 'block' : 'none';
      if (tab === 'pnl') renderPnlAnalytics();
    }

    function renderChatHistory() {
      const el = $('hist-chats');
      if (chatSessions.length === 0) {
        el.innerHTML = '<div class="hist-empty"><div class="hist-empty-icon">💬</div>No saved chats yet.<br>Start chatting and your conversations will appear here.</div>';
        return;
      }
      let html = '';
      for (const s of chatSessions) {
        const date = new Date(s.updated);
        const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const msgs = s.msgCount || s.messages.length;
        const isActive = s.id === currentSessionId;
        html += `
          <div class="chat-card${isActive ? ' active-session' : ''}" onclick="loadSession('${s.id}')">
            <div class="chat-card-title">${s.title.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>
            <div class="chat-card-meta">
              <span>${msgs} messages · ${dateStr} ${timeStr}</span>
            </div>
            <button class="chat-card-del" onclick="deleteSession('${s.id}', event)" title="Delete">✕</button>
          </div>`;
      }
      el.innerHTML = html;
    }

    function renderTxHistory() {
      const el = $('hist-txs');
      if (tradeHistory.length === 0) {
        el.innerHTML = '<div class="hist-empty"><div class="hist-empty-icon">📋</div>No transactions yet.<br>Trade tokens via Jupiter and your history will appear here.</div>';
        return;
      }
      let html = '';
      for (const t of tradeHistory) {
        const date = new Date(t.time);
        const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const isBuy = t.side === 'buy';
        html += `
          <div class="tx-card">
            <div class="tx-card-top">
              <span class="tx-badge ${isBuy ? 'tx-buy' : 'tx-sell'}">${t.side.toUpperCase()}</span>
              <span class="tx-time">${dateStr} · ${timeStr}</span>
            </div>
            <div class="tx-detail"><strong>${t.symbol || 'Unknown'}</strong> · ${t.amountIn} → ${t.amountOut}</div>
            ${t.sig ? `<a class="tx-sig" href="${(t.chain && CHAINS[t.chain]) ? CHAINS[t.chain].explorerTx : 'https://solscan.io/tx/'}${t.sig}" target="_blank">🔗 ${t.sig.slice(0,8)}...${t.sig.slice(-6)}</a>` : ''}
          </div>`;
      }
      el.innerHTML = html;
    }

    // ═══════ IMAGE ═══════

    // ═══════ BASE58 UTILITIES ═══════
    const B58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    function bs58Decode(str) {
      const bytes = [];
      for (let i = 0; i < str.length; i++) {
        const c = B58_ALPHABET.indexOf(str[i]);
        if (c < 0) throw new Error('Invalid base58 character: ' + str[i]);
        let carry = c;
        for (let j = 0; j < bytes.length; j++) {
          carry += bytes[j] * 58;
          bytes[j] = carry & 0xff;
          carry >>= 8;
        }
        while (carry > 0) { bytes.push(carry & 0xff); carry >>= 8; }
      }
      for (let i = 0; i < str.length && str[i] === '1'; i++) bytes.push(0);
      return new Uint8Array(bytes.reverse());
    }

    function bs58Encode(bytes) {
      let num = 0n;
      for (const b of bytes) num = num * 256n + BigInt(b);
      let str = '';
      while (num > 0n) { str = B58_ALPHABET[Number(num % 58n)] + str; num /= 58n; }
      for (const b of bytes) { if (b !== 0) break; str = '1' + str; }
      return str || '1';
    }

    // ═══════ SNIPER BOT ═══════
    let sniperEnabled = lsGet('ghost-sniper-enabled', '') === 'true';
    let sniperWallets = lsGetJSON('ghost-sniper-wallets', []);
    const MAX_SNIPER_WALLETS = 3;

    function toggleSniper() {
      sniperEnabled = !sniperEnabled;
      lsSet('ghost-sniper-enabled', sniperEnabled);
      $('sniper-sw').classList.toggle('on', sniperEnabled);
      toast(sniperEnabled ? '⚡ Sniper enabled' : 'Sniper disabled');
    }

    function updateSniperSwitch() {
      $('sniper-sw').classList.toggle('on', sniperEnabled);
    }

    function showSniperImport() {
      $('sniper-import').classList.add('show');
      $('sniper-key-input').value = '';
      $('sniper-key-input').focus();
    }

    function hideSniperImport() {
      $('sniper-import').classList.remove('show');
    }

    function generateSniperWallet() {
      if (sniperWallets.length >= MAX_SNIPER_WALLETS) {
        toast('Max ' + MAX_SNIPER_WALLETS + ' wallets'); return;
      }
      try {
        const keypair = solanaWeb3.Keypair.generate();
        const secretKey = bs58Encode(keypair.secretKey);
        const pubKey = keypair.publicKey.toBase58();
        sniperWallets.push({
          publicKey: pubKey,
          secretKey: secretKey,
          amount: 0.01,
          label: 'Wallet ' + (sniperWallets.length + 1)
        });
        saveSniperWallets();
        hideSniperImport();
        renderSniperWallets();
        toast('🎲 Generated ' + pubKey.slice(0, 4) + '...' + pubKey.slice(-4));
      } catch (e) {
        toast('Generation failed: ' + e.message);
      }
    }

    function importSniperWallet() {
      if (sniperWallets.length >= MAX_SNIPER_WALLETS) {
        toast('Max ' + MAX_SNIPER_WALLETS + ' wallets'); return;
      }
      const key = $('sniper-key-input').value.trim();
      if (!key) { toast('Paste a private key first'); return; }
      try {
        const decoded = bs58Decode(key);
        if (decoded.length !== 64) throw new Error('Key must be 64 bytes, got ' + decoded.length);
        const keypair = solanaWeb3.Keypair.fromSecretKey(decoded);
        const pubKey = keypair.publicKey.toBase58();
        if (sniperWallets.some(w => w.publicKey === pubKey)) {
          toast('Wallet already added'); return;
        }
        sniperWallets.push({
          publicKey: pubKey,
          secretKey: key,
          amount: 0.01,
          label: 'Wallet ' + (sniperWallets.length + 1)
        });
        saveSniperWallets();
        hideSniperImport();
        renderSniperWallets();
        toast('📥 Imported ' + pubKey.slice(0, 4) + '...' + pubKey.slice(-4));
      } catch (e) {
        toast('Invalid key: ' + e.message);
      }
    }

    function removeSniperWallet(idx) {
      const w = sniperWallets[idx];
      if (!w) return;
      sniperWallets.splice(idx, 1);
      // Re-label
      sniperWallets.forEach((w, i) => w.label = 'Wallet ' + (i + 1));
      saveSniperWallets();
      renderSniperWallets();
      toast('Wallet removed');
    }

    function saveSniperWallets() {
      lsSetJSON('ghost-sniper-wallets', sniperWallets);
      $('sniper-add-btn').disabled = sniperWallets.length >= MAX_SNIPER_WALLETS;
    }

    function updateSniperAmount(idx, val) {
      if (sniperWallets[idx]) {
        sniperWallets[idx].amount = Math.max(0.001, parseFloat(val) || 0.01);
        saveSniperWallets();
      }
    }

    function renderSniperWallets() {
      const el = $('sniper-wallets');
      if (sniperWallets.length === 0) {
        el.innerHTML = '<div class="hist-empty"><div class="hist-empty-icon">⚡</div>No sniper wallets yet.<br>Generate or import wallets below.</div>';
        $('sniper-add-btn').disabled = false;
        return;
      }
      let html = '';
      for (let i = 0; i < sniperWallets.length; i++) {
        const w = sniperWallets[i];
        const addr = w.publicKey;
        html += `
          <div class="sniper-wallet" id="sw-${i}">
            <div class="sw-header">
              <span class="sw-label">⚡ ${w.label}</span>
              <button class="sw-remove" onclick="removeSniperWallet(${i})" title="Remove">✕</button>
            </div>
            <div class="sw-addr">${addr}</div>
            <div class="sw-bal-row">
              <span class="sw-bal" id="sw-bal-${i}">Balance: loading...</span>
              <button class="sw-bal-refresh" onclick="refreshSniperBalance(${i})">↻</button>
            </div>
            <div class="sw-amt-row">
              <span class="sw-amt-label">Snipe:</span>
              <input type="number" class="fi" value="${w.amount}" step="0.01" min="0.001" max="10"
                style="flex:1;" onchange="updateSniperAmount(${i}, this.value)">
              <span class="sw-amt-label">SOL</span>
            </div>
            <div class="sw-status" id="sw-status-${i}"></div>
          </div>`;
      }
      el.innerHTML = html;
      $('sniper-add-btn').disabled = sniperWallets.length >= MAX_SNIPER_WALLETS;
      refreshSniperBalances();
    }

    async function refreshSniperBalance(idx) {
      const w = sniperWallets[idx];
      if (!w) return;
      const balEl = $('sw-bal-' + idx);
      if (balEl) balEl.textContent = 'Balance: loading...';
      try {
        const connection = await getWorkingConnection();
        const pubkey = new solanaWeb3.PublicKey(w.publicKey);
        const bal = await connection.getBalance(pubkey);
        const sol = (bal / 1e9).toFixed(4);
        if (balEl) balEl.textContent = `Balance: ${sol} SOL`;
        if (parseFloat(sol) < w.amount + 0.005) {
          if (balEl) balEl.innerHTML = `Balance: <span style="color:var(--red);">${sol} SOL</span> <span style="font-size:10px;color:var(--red);">⚠ low</span>`;
        }
      } catch (e) {
        if (balEl) balEl.textContent = 'Balance: error';
      }
    }

    async function refreshSniperBalances() {
      for (let i = 0; i < sniperWallets.length; i++) {
        refreshSniperBalance(i);
      }
    }

    function setSniperStatus(idx, text, type) {
      const el = $('sw-status-' + idx);
      if (!el) return;
      el.textContent = text;
      el.className = 'sw-status show ' + type;
    }

    async function executeSniperBuys(mintAddress, ticker) {
      const activeWallets = sniperWallets.filter(w => w.amount > 0);
      if (activeWallets.length === 0) return;

      setStep(6, 'active', `sniping (${activeWallets.length} wallets)...`);

      const results = [];
      // Fire all buy requests in parallel for speed
      const promises = sniperWallets.map(async (w, idx) => {
        if (w.amount <= 0) return;
        setSniperStatus(idx, '⏳ Building buy tx...', 'pending');

        try {
          // 1. Get buy transaction from PumpPortal
          const txRes = await fetch('https://pumpportal.fun/api/trade-local', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: w.publicKey,
              action: 'buy',
              mint: mintAddress,
              amount: w.amount,
              denominatedInSol: 'true',
              slippage: 50,
              priorityFee: 0.001,
              pool: 'pump',
            }),
          });

          if (!txRes.ok) {
            const errText = await txRes.text();
            throw new Error('PumpPortal: ' + errText.slice(0, 60));
          }

          setSniperStatus(idx, '✍️ Signing...', 'pending');

          // 2. Deserialize and sign
          const txData = await txRes.arrayBuffer();
          const tx = solanaWeb3.VersionedTransaction.deserialize(new Uint8Array(txData));
          const secretKey = bs58Decode(w.secretKey);
          const keypair = solanaWeb3.Keypair.fromSecretKey(secretKey);
          tx.sign([keypair]);

          setSniperStatus(idx, '📡 Submitting...', 'pending');

          // 3. Send to Solana
          const connection = await getWorkingConnection();
          const sig = await connection.sendRawTransaction(tx.serialize(), {
            skipPreflight: true, maxRetries: 3,
          });

          setSniperStatus(idx, '⏳ Confirming...', 'pending');

          // 4. Confirm (with timeout)
          const confirmPromise = connection.confirmTransaction(sig, 'confirmed');
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('timeout')), 30000)
          );
          await Promise.race([confirmPromise, timeoutPromise]);

          setSniperStatus(idx, `✅ Bought! ${sig.slice(0, 8)}...`, 'success');
          results.push({ wallet: w.label, success: true, sig });

          // Add to trade history
          tradeHistory.unshift({
            side: 'buy', symbol: ticker || 'SNIPE', mint: mintAddress,
            amountIn: w.amount + ' SOL', amountOut: 'snipe', sig, time: Date.now()
          });
          if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
          lsSetJSON('ghost-trades', tradeHistory);

        } catch (e) {
          const errMsg = e.message || 'Unknown error';
          setSniperStatus(idx, '❌ ' + errMsg.slice(0, 40), 'error');
          results.push({ wallet: w.label, success: false, error: errMsg });
        }
      });

      await Promise.allSettled(promises);

      const successes = results.filter(r => r.success);
      const failures = results.filter(r => !r.success);

      if (successes.length === activeWallets.length) {
        setStep(6, 'done', `✓ ${successes.length}/${activeWallets.length} sniped`);
      } else if (successes.length > 0) {
        setStep(6, 'done', `⚠ ${successes.length}/${activeWallets.length} sniped`);
      } else {
        setStep(6, 'error', `✗ all failed`);
      }

      // Log to chat
      let logMsg = `⚡ SNIPER RESULTS\n\n`;
      for (const r of results) {
        if (r.success) {
          logMsg += `✅ ${r.wallet}: Bought! tx: ${r.sig.slice(0, 12)}...\n`;
        } else {
          logMsg += `❌ ${r.wallet}: ${r.error}\n`;
        }
      }
      addMsg('system', logMsg);

      renderTradeHistory();
      return results;
    }
    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (file) {
        tokenImageFile = file;
        const label = $('file-label');
        // Keep the hidden input
        const input = e.target;
        label.innerHTML = '';
        // Add small preview
        const reader = new FileReader();
        reader.onload = (ev) => {
          const img = document.createElement('img');
          img.src = ev.target.result;
          img.style.cssText = 'width:36px;height:36px;border-radius:6px;object-fit:cover;';
          label.insertBefore(img, label.firstChild);
        };
        reader.readAsDataURL(file);
        const txt = document.createTextNode('✓ ' + file.name);
        label.appendChild(txt);
        label.appendChild(input);
        label.classList.add('has-file');
      }
    }

    // ═══════ PHANTOM ═══════
    let phantomReady = false;
    
    function getPhantom() {
      if (window.phantom?.solana?.isPhantom) return window.phantom.solana;
      if (window.solana?.isPhantom) return window.solana;
      return null;
    }

    // Listen for Phantom's own ready event
    window.addEventListener('phantom#initialized', () => { phantomReady = true; });
    // Also detect if already loaded
    if (getPhantom()) phantomReady = true;

    function waitForPhantom(maxWait = 5000) {
      return new Promise((resolve) => {
        const p = getPhantom();
        if (p) return resolve(p);

        let elapsed = 0;
        const interval = setInterval(() => {
          elapsed += 200;
          const p = getPhantom();
          if (p) { clearInterval(interval); resolve(p); }
          else if (elapsed >= maxWait) { clearInterval(interval); resolve(null); }
        }, 200);

        // Also resolve on the event
        const handler = () => {
          clearInterval(interval);
          window.removeEventListener('phantom#initialized', handler);
          setTimeout(() => resolve(getPhantom()), 100);
        };
        window.addEventListener('phantom#initialized', handler);
      });
    }

    async function connectWallet() {
      openWalletModal();
    }

    function updateWalletPanel() {
      if (!walletAddress) return;
      if (isEVM()) { updateEVMWalletPanel(); return; }
      const wp = activeWalletId ? WALLET_PROVIDERS[activeWalletId] : null;
      const walletIcon = wp ? wp.icon : '👻';
      const shortAddr = walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
      $('wallet-content').innerHTML = `
        <div class="wp-header">
          <div class="wp-avatar">${walletIcon}</div>
          <div class="wp-balance">${typeof walletBalance === 'number' ? walletBalance.toFixed(4) : '—'}</div>
          <div class="wp-balance-label">SOL BALANCE</div>
          <div class="wp-addr">
            <span>${shortAddr}</span>
            <button class="wp-addr-copy" onclick="navigator.clipboard.writeText('${walletAddress}');toast('📋 Copied!')">Copy</button>
          </div>
        </div>
        <div class="wp-actions">
          <button class="wp-action" onclick="window.open('https://solscan.io/account/${walletAddress}','_blank')">
            <span class="wp-action-icon">🔍</span>Explorer
          </button>
          <button class="wp-action" onclick="setMode('portfolio')">
            <span class="wp-action-icon">◐</span>Portfolio
          </button>
          <button class="wp-action danger" onclick="disconnectWallet()">
            <span class="wp-action-icon">⏏</span>Disconnect
          </button>
        </div>
        <div class="wp-section">
          <div class="wp-stitle">Holdings</div>
          <div id="wp-holdings"><div class="wp-loading">Loading tokens...</div></div>
        </div>`;
      // Fetch holdings
      fetchWalletHoldings();
    }

    async function fetchWalletHoldings() {
      const holdingsEl = $('wp-holdings');
      if (!holdingsEl || !walletAddress) return;

      try {
        const pubkey = new solanaWeb3.PublicKey(walletAddress);
        const conn = await getWorkingConnection();
        const tokenAccounts = await conn.getParsedTokenAccountsByOwner(pubkey, {
          programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
        });

        // Filter for tokens with balance > 0
        const tokens = tokenAccounts.value
          .map(ta => ({
            mint: ta.account.data.parsed.info.mint,
            amount: ta.account.data.parsed.info.tokenAmount.uiAmount || 0,
            decimals: ta.account.data.parsed.info.tokenAmount.decimals,
          }))
          .filter(t => t.amount > 0)
          .sort((a, b) => b.amount - a.amount);

        if (tokens.length === 0) {
          holdingsEl.innerHTML = '<div class="wp-empty">No token holdings found</div>';
          return;
        }

        // Get prices + metadata from Jupiter + DexScreener
        const mints = tokens.slice(0, 15).map(t => t.mint);
        let prices = {};
        try {
          const priceRes = await fetch(`${JUP_PRICE}?ids=${mints.join(',')}`);
          if (priceRes.ok) {
            const priceData = await priceRes.json();
            prices = priceData.data || {};
          }
        } catch (e) {}

        // Build holdings HTML — SOL first
        const colors = ['#9b8ce8','#00ffc8','#ff6b6b','#ffd93d','#6bcbff','#ff8f5c','#a6e86b','#e86bb5','#6b7ae8','#e8c86b'];
        let html = '';

        // SOL entry
        let solPrice = 0;
        try {
          const sp = await fetch(`${JUP_PRICE}?ids=${SOL_MINT}`);
          if (sp.ok) { const spd = await sp.json(); solPrice = parseFloat(spd.data?.[SOL_MINT]?.price || 0); }
        } catch(e) {}
        const solVal = typeof walletBalance === 'number' ? (walletBalance * solPrice) : 0;
        html += `<div class="wp-holding">
          <div class="wp-holding-icon" style="background:linear-gradient(135deg,#9945FF,#14F195);">◎</div>
          <div class="wp-holding-info">
            <div class="wp-holding-name">SOL</div>
            <div class="wp-holding-amt">${typeof walletBalance === 'number' ? walletBalance.toFixed(4) : '—'} SOL</div>
          </div>
          <div class="wp-holding-val">
            <div class="wp-holding-usd">$${solVal.toFixed(2)}</div>
            <div class="wp-holding-price">$${solPrice.toFixed(2)}</div>
          </div>
        </div>`;

        for (let i = 0; i < Math.min(tokens.length, 15); i++) {
          const t = tokens[i];
          const price = parseFloat(prices[t.mint]?.price || 0);
          const usdVal = t.amount * price;
          const sym = prices[t.mint]?.mintSymbol || t.mint.slice(0, 4).toUpperCase();
          const color = colors[i % colors.length];
          const initial = sym.slice(0, 2);
          const amtStr = t.amount > 1000000 ? (t.amount / 1000000).toFixed(2) + 'M' :
                         t.amount > 1000 ? (t.amount / 1000).toFixed(2) + 'K' :
                         t.amount.toFixed(t.amount < 1 ? 6 : 2);

          html += `<div class="wp-holding">
            <div class="wp-holding-icon" style="background:${color};">${initial}</div>
            <div class="wp-holding-info">
              <div class="wp-holding-name">${sym}</div>
              <div class="wp-holding-amt">${amtStr} ${sym}</div>
            </div>
            <div class="wp-holding-val">
              <div class="wp-holding-usd">${price > 0 ? '$' + (usdVal > 1 ? usdVal.toFixed(2) : usdVal.toFixed(6)) : '—'}</div>
              <div class="wp-holding-price">${price > 0 ? '$' + (price > 0.01 ? price.toFixed(4) : price.toExponential(2)) : ''}</div>
            </div>
          </div>`;
        }

        if (tokens.length > 15) {
          html += `<div class="wp-empty">+ ${tokens.length - 15} more tokens</div>`;
        }

        holdingsEl.innerHTML = html;

      } catch (e) {
        holdingsEl.innerHTML = `<div class="wp-empty">Could not load holdings</div>`;
      }
    }

    async function disconnectWallet() {
      // EVM cleanup
      evmProvider = null;
      evmSigner = null;
      // Disconnect Solana wallet if applicable
      if (activeWalletId === 'phantom') {
        const phantom = getPhantom(); if (phantom) try { await phantom.disconnect(); } catch(e) {}
      } else if (activeWalletId === 'trustwallet') {
        const tw = WALLET_PROVIDERS.trustwallet.getSolana?.();
        if (tw) try { await tw.disconnect(); } catch(e) {}
      }
      activeWalletId = null;
      lsRemove('ghost-wallet-provider');
      walletPubkey = null; walletAddress = null; walletBalance = null;
      $('wbtn').className = 'wallet-btn off'; $('wbtn-icon').textContent = '🔗'; $('wbtn-t').textContent = 'Connect Wallet';
      $('lbtn').className = 'lbtn dis'; $('lbtn').textContent = 'CONNECT WALLET TO LAUNCH';
      $('ph-stat').style.background = 'var(--red-dim)'; $('ph-stat').style.color = 'var(--red)'; $('ph-stat').textContent = 'DISCONNECTED';
      $('wallet-content').innerHTML = `<div style="text-align:center;padding:48px 20px;color:var(--text-muted);"><div style="font-size:40px;margin-bottom:14px;">🔗</div><div style="font-size:14px;margin-bottom:6px;color:var(--text);font-weight:600;">Not Connected</div><div style="font-size:12px;margin-bottom:20px;">Connect a wallet to start trading on ${getChain().name}</div><button class="wallet-btn off" onclick="connectWallet()">Connect Wallet</button></div>`;
      $('tr-buy-btn').disabled = true;
      $('tr-sell-btn').disabled = true;
      $('positions-list').innerHTML = '<div class="pos-empty">Connect wallet to see positions</div>';
      toast('Wallet disconnected');
    }

    // ═══════ TOKEN LAUNCH ═══════
    function setStep(n, status, statusText) {
      const el = $('step-' + n); el.className = 'launch-step ' + status;
      el.querySelector('.step-status').textContent = statusText || '';
    }

    async function launchToken() {
      // Dispatch to Four.meme launcher if on BNB chain
      if (selectedPlatform === 'fourmeme' || activeChain === 'bsc') {
        return launchTokenFourMeme();
      }
      if (!walletAddress) { toast('Connect a wallet first!'); return; }
      const name = $('t-name').value.trim();
      const ticker = $('t-ticker').value.trim().replace('$', '');
      const desc = $('t-desc').value.trim();
      const initialBuy = parseFloat($('t-buy').value) || 0;
      const twitter = $('t-twitter').value.trim();
      const telegram = $('t-telegram').value.trim();
      const website = $('t-website').value.trim();

      if (!name) { toast('Token name is required!'); return; }
      if (!ticker) { toast('Ticker is required!'); return; }
      if (!tokenImageFile) { toast('Token image is required!'); return; }

      $('launch-steps').style.display = 'block';
      $('lbtn').className = 'lbtn loading'; $('lbtn').textContent = 'LAUNCHING...';

      try {
        setStep(1, 'active', 'uploading...');
        const formData = new FormData();
        formData.append('file', tokenImageFile);
        formData.append('name', name); formData.append('symbol', ticker);
        formData.append('description', desc || `${name} — launched via Ghost`);
        formData.append('twitter', twitter); formData.append('telegram', telegram);
        formData.append('website', website); formData.append('showName', 'true');

        const ipfsRes = await fetch(`${PUMPPORTAL_API}/ipfs`, { method: 'POST', body: formData });
        if (!ipfsRes.ok) throw new Error('IPFS upload failed: ' + ipfsRes.status);
        const ipfsData = await ipfsRes.json();
        setStep(1, 'done', '✓');

        setStep(2, 'active', 'building...');
        const mintKeypair = solanaWeb3.Keypair.generate();
        const txRes = await fetch(`${PUMPPORTAL_API}/trade-local`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            publicKey: walletAddress, action: 'create',
            tokenMetadata: { name, symbol: ticker, uri: ipfsData.metadataUri },
            mint: mintKeypair.publicKey.toBase58(),
            denominatedInSol: 'true', amount: initialBuy,
            slippage: 15, priorityFee: 0.0005, pool: 'pump',
          }),
        });
        if (!txRes.ok) throw new Error('Transaction build failed: ' + await txRes.text());
        setStep(2, 'done', '✓');

        setStep(3, 'active', 'sign in wallet...');
        const txData = await txRes.arrayBuffer();
        const tx = solanaWeb3.VersionedTransaction.deserialize(new Uint8Array(txData));
        tx.sign([mintKeypair]);
        const signedTx = await getSolanaSigner().signTransaction(tx);
        setStep(3, 'done', '✓');

        setStep(4, 'active', 'submitting...');
        const connection = await getWorkingConnection();
        const signature = await connection.sendRawTransaction(signedTx.serialize(), { skipPreflight: true, maxRetries: 3 });
        await connection.confirmTransaction(signature, 'confirmed');
        setStep(4, 'done', '✓');

        setStep(5, 'done', '🎉 LIVE!');
        const mintAddr = mintKeypair.publicKey.toBase58();
        if ($('empty-state')) $('empty-state').style.display = 'none';
        addMsg('success',
          `🎉 TOKEN LAUNCHED!\n\nName: ${name}\nTicker: $${ticker}\nMint: ${mintAddr}\n${initialBuy > 0 ? `Initial Buy: ${initialBuy} SOL\n` : ''}Tx: ${signature.slice(0, 16)}...\n\n🔗 View: https://pump.fun/${mintAddr}\n🔍 Solscan: https://solscan.io/tx/${signature}`
        );
        toast('🎉 $' + ticker + ' is live!');

        // ═══ SNIPER INTEGRATION ═══
        if (sniperEnabled && sniperWallets.length > 0 && sniperWallets.some(w => w.amount > 0)) {
          $('step-6').style.display = 'flex';
          try {
            await executeSniperBuys(mintAddr, ticker);
          } catch (sniperErr) {
            setStep(6, 'error', '✗ ' + (sniperErr.message || 'sniper failed').slice(0, 30));
            addMsg('system', `⚡ Sniper error: ${sniperErr.message}\n\nToken launched OK — you can manually buy from the TRADE tab.`);
          }
          setTimeout(() => { $('launch-steps').style.display = 'none'; [1,2,3,4,5,6].forEach(n => { setStep(n, 'pending', ''); if (n === 6) $('step-6').style.display = 'none'; }); $('lbtn').className = 'lbtn ready'; $('lbtn').textContent = '🚀 LAUNCH TOKEN'; }, 8000);
        } else {
          setTimeout(() => { $('launch-steps').style.display = 'none'; [1,2,3,4,5].forEach(n => setStep(n, 'pending', '')); $('lbtn').className = 'lbtn ready'; $('lbtn').textContent = '🚀 LAUNCH TOKEN'; }, 5000);
        }
      } catch (err) {
        console.error('Launch error:', err);
        for (let i = 1; i <= 6; i++) { if ($('step-' + i) && $('step-' + i).classList.contains('active')) { setStep(i, 'error', '✗ ' + err.message.slice(0, 40)); break; } }
        if ($('empty-state')) $('empty-state').style.display = 'none';
        addMsg('system', `❌ Launch failed: ${err.message}\n\nCommon fixes:\n• Enough SOL? (0.02+ for gas)\n• Image under 5MB?\n• Approve in Phantom\n• Check internet connection`);
        $('lbtn').className = 'lbtn ready'; $('lbtn').textContent = '🚀 RETRY LAUNCH';
        setTimeout(() => { $('launch-steps').style.display = 'none'; [1,2,3,4,5,6].forEach(n => { setStep(n, 'pending', ''); if (n === 6) $('step-6').style.display = 'none'; }); }, 8000);
      }
    }

    // ═══════ JUPITER TRADING ═══════
    function setTradeAmt(amt) {
      $('tr-amount').value = amt;
      document.querySelectorAll('.trade-preset').forEach(b => b.classList.toggle('sel', parseFloat(b.textContent) === amt));
      getQuote();
    }

    function setSellPct(pct) {
      sellPct = pct;
      [25, 50, 75, 100].forEach(p => {
        const btn = $('sell-pct-' + p);
        if (btn) btn.classList.toggle('active', p === pct);
      });
      $('tr-sell-btn').textContent = '🔴 SELL ' + pct + '%';
    }

    function toggleSltp() {
      sltpEnabled = !sltpEnabled;
      lsSet('ghost-sltp', sltpEnabled);
      if ($('sltp-toggle')) $('sltp-toggle').classList.toggle('on', sltpEnabled);
      toast(sltpEnabled ? '🎯 Auto SL/TP ON' : 'Auto SL/TP OFF');
      if (sltpEnabled && !manualSltpTimer) startManualSltpMonitor();
      if (!sltpEnabled && manualSltpTimer) { clearInterval(manualSltpTimer); manualSltpTimer = null; }
    }

    function saveManualPositions() {
      lsSetJSON('ghost-manual-positions', manualPositions);
    }

    function registerManualPosition(mint, symbol, entrySOL) {
      if (!sltpEnabled) return;
      const sl = Math.max(5, Math.min(80, parseFloat($('manual-sl')?.value) || 30));
      const tp = Math.max(10, Math.min(500, parseFloat($('manual-tp')?.value) || 100));
      manualPositions[mint] = { symbol, entrySOL, entryTime: Date.now(), sl, tp, status: 'active' };
      saveManualPositions();
      toast('🎯 Monitoring ' + symbol + ' — SL: -' + sl + '% / TP: +' + tp + '%');
      if (!manualSltpTimer) startManualSltpMonitor();
    }

    function startManualSltpMonitor() {
      if (manualSltpTimer) return;
      manualSltpTimer = setInterval(() => checkManualSltpPositions(), 15000);
    }

    async function checkManualSltpPositions() {
      if (!sltpEnabled || !walletAddress) return;
      const mints = Object.keys(manualPositions).filter(m => manualPositions[m].status === 'active');
      if (mints.length === 0) return;

      for (const mint of mints) {
        const pos = manualPositions[mint];
        try {
          const bal = await getTokenBalance(mint);
          if (!bal || bal <= 0) { pos.status = 'closed'; saveManualPositions(); continue; }
          const tokenDecimals = await getTokenDecimals(mint);
          const tokenLamports = Math.round(bal * Math.pow(10, tokenDecimals));
          const jupResult = await jupQuote(mint, SOL_MINT, tokenLamports, 1500);
          if (!jupResult) continue;
          const currentSOL = parseInt(jupResult.quote.outAmount || '0') / 1e9;
          const pnlPct = ((currentSOL - pos.entrySOL) / pos.entrySOL) * 100;

          if (pnlPct <= -pos.sl) {
            toast('🛑 SL triggered for ' + pos.symbol + ': ' + pnlPct.toFixed(1) + '%');
            addMsg('system', '🛑 STOP-LOSS triggered for ' + pos.symbol + ': ' + pnlPct.toFixed(1) + '% — auto-selling...');
            pos.status = 'sl_triggered'; saveManualPositions();
            $('tr-mint').value = mint; sellPct = 100; await executeTrade('sell');
          } else if (pnlPct >= pos.tp) {
            toast('🎯 TP triggered for ' + pos.symbol + ': +' + pnlPct.toFixed(1) + '%');
            addMsg('system', '🎯 TAKE-PROFIT triggered for ' + pos.symbol + ': +' + pnlPct.toFixed(1) + '% — auto-selling...');
            pos.status = 'tp_triggered'; saveManualPositions();
            $('tr-mint').value = mint; sellPct = 100; await executeTrade('sell');
          }
        } catch (e) { /* skip this position */ }
        await new Promise(r => setTimeout(r, 500));
      }
    }

    function onMintInput(val) {
      const clean = val.trim();
      if (isEVM()) {
        if (/^0x[a-fA-F0-9]{40}$/.test(clean)) {
          lookupEVMToken(clean);
        } else {
          $('tr-token-info').style.display = 'none';
          currentQuote = null;
          $('tr-quote').style.display = 'none';
        }
        return;
      }
      if (clean.length >= 32 && clean.length <= 50) {
        lookupToken(clean);
      } else {
        $('tr-token-info').style.display = 'none';
        currentQuote = null;
        $('tr-quote').style.display = 'none';
      }
    }

    async function lookupToken(mint) {
      try {
        const res = await fetch(`${JUP_PRICE}?ids=${mint}`);
        if (!res.ok) return;
        const data = await res.json();
        const info = data.data?.[mint];
        if (info) {
          $('tr-token-name').textContent = info.mintSymbol || mint.slice(0, 6) + '...';
          $('tr-token-price').textContent = '$' + parseFloat(info.price).toFixed(info.price < 0.001 ? 8 : info.price < 1 ? 6 : 4);
          $('tr-token-info').style.display = 'block';
          $('tr-buy-btn').disabled = !walletAddress;
          $('tr-sell-btn').disabled = !walletAddress;
          if (parseFloat($('tr-amount').value) > 0) getQuote();
        } else {
          $('tr-token-name').textContent = mint.slice(0, 8) + '...';
          $('tr-token-price').textContent = 'price unavailable';
          $('tr-token-info').style.display = 'block';
          $('tr-buy-btn').disabled = !walletAddress;
          $('tr-sell-btn').disabled = !walletAddress;
        }
      } catch(e) {
        $('tr-token-info').style.display = 'none';
      }
    }

    async function getQuote() {
      if (isEVM()) { getEVMQuote(); return; }
      const mint = $('tr-mint').value.trim();
      const amount = parseFloat($('tr-amount').value);
      const slippage = parseFloat($('tr-slippage').value) || 1;
      if (!mint || mint.length < 32 || !amount || amount <= 0) {
        $('tr-quote').style.display = 'none';
        currentQuote = null;
        return;
      }
      clearTimeout(quoteTimer);
      quoteTimer = setTimeout(async () => {
        try {
          const lamports = Math.round(amount * 1e9);
          const jupResult = await jupQuote(SOL_MINT, mint, lamports, Math.round(slippage * 100));
          if (!jupResult) throw new Error('All Jupiter endpoints failed');
          const quote = jupResult.quote;
          currentQuote = quote;

          $('tq-pay').textContent = amount + ' SOL';
          const outAmt = parseInt(quote.outAmount);
          const decimals = quote.outputMint === SOL_MINT ? 9 : (quote.routePlan?.[0]?.swapInfo?.outputMint === mint ? 6 : 6);
          const tokenDecimals = await getTokenDecimals(mint);
          const received = outAmt / Math.pow(10, tokenDecimals);
          $('tq-receive').textContent = formatNum(received) + ' tokens';
          $('tq-impact').textContent = (parseFloat(quote.priceImpactPct) * 100).toFixed(3) + '%';
          const routeNames = quote.routePlan?.map(r => r.swapInfo?.label || '?').join(' → ') || 'Jupiter';
          $('tq-route').textContent = routeNames;
          $('tr-quote').style.display = 'block';
        } catch(e) {
          $('tr-quote').style.display = 'none';
          currentQuote = null;
        }
      }, 400);
    }

    async function getTokenDecimals(mint) {
      if (isEVM()) return getEVMTokenDecimals(mint);
      try {
        const conn = await getWorkingConnection();
        const info = await conn.getParsedAccountInfo(new solanaWeb3.PublicKey(mint));
        return info?.value?.data?.parsed?.info?.decimals ?? 6;
      } catch(e) { return 6; }
    }

    function formatNum(n) {
      if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
      if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
      if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
      if (n >= 1) return n.toFixed(4);
      return n.toFixed(8);
    }

    function escapeHtml(s) {
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }

    // ═══════ AXIOM-STYLE QUICK TRADE ═══════
    async function quickBuy(mint, solAmount, symbol, btnEl) {
      if (!walletAddress) { toast('Connect wallet first!'); return; }
      if (isTrading) { toast('Trade already in progress...'); return; }
      if (isEVM()) { toast('Quick-buy is Solana only for now'); return; }
      
      const statusEl = btnEl?.closest('.qt-section')?.querySelector('.qt-status');
      const allBtns = btnEl?.closest('.qt-section')?.querySelectorAll('.qt-buy-btn, .qt-sell-btn');
      const setStatus = (cls, text) => {
        if (statusEl) { statusEl.className = 'qt-status active ' + cls; statusEl.textContent = text; }
      };
      const clearStatus = () => { if (statusEl) setTimeout(() => statusEl.className = 'qt-status', 4000); };
      
      isTrading = true;
      if (allBtns) allBtns.forEach(b => b.classList.add('loading'));
      if (btnEl) btnEl.textContent = '...';
      const origText = solAmount + ' SOL';
      
      const slippage = parseFloat($('tr-slippage')?.value) || 15;
      const priority = parseFloat($('tr-priority')?.value) || 0.0005;

      try {
        setStatus('pending', '⏳ Getting quote...');
        const lamports = Math.round(solAmount * 1e9);
        const jupResult = await jupQuote(SOL_MINT, mint, lamports, Math.round(slippage * 100));
        if (!jupResult) throw new Error('Jupiter quote failed — token may have no liquidity or routes');
        
        setStatus('pending', '⏳ Building transaction...');
        const swapData = await jupSwap(jupResult.endpoint, jupResult.quote, walletAddress, Math.round(priority * 1e9));
        
        setStatus('pending', '⏳ Simulating...');
        const txBuf = Uint8Array.from(atob(swapData.swapTransaction), c => c.charCodeAt(0));
        const tx = solanaWeb3.VersionedTransaction.deserialize(txBuf);
        try {
          const simConn = await getWorkingConnection();
          const simResult = await simConn.simulateTransaction(tx, { sigVerify: false });
          if (simResult.value.err) throw new Error('Simulation failed: trade would fail on-chain');
        } catch (simErr) {
          if (simErr.message.includes('Simulation failed:')) throw simErr;
        }
        
        setStatus('pending', '✍️ Sign in wallet...');
        const solSigner = getSolanaSigner();
        if (!solSigner) throw new Error('Wallet signer not found');
        const signed = await solSigner.signTransaction(tx);
        
        setStatus('pending', mevEnabled ? '🛡️ Sending via Jito...' : '📡 Submitting...');
        const rawTx = signed.serialize();
        let sig;
        if (mevEnabled) {
          try { sig = await sendViaJito(rawTx); }
          catch (e) {
            const conn = await getWorkingConnection();
            sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
          }
        } else {
          const conn = await getWorkingConnection();
          sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
        }
        
        setStatus('pending', '⏳ Confirming...');
        const confirmConn = await getWorkingConnection();
        await confirmConn.confirmTransaction(sig, 'confirmed');
        
        const tokenDecimals = await getTokenDecimals(mint);
        const outAmt = parseInt(jupResult.quote.outAmount) / Math.pow(10, tokenDecimals);
        
        setStatus('success', `✅ Bought ${formatNum(outAmt)} ${symbol || ''}!`);
        toast(`✅ Bought ${formatNum(outAmt)} ${symbol || ''} for ${solAmount} SOL`, 5000);
        
        tradeHistory.unshift({
          side: 'buy', symbol: symbol || mint.slice(0,6), mint,
          amountIn: solAmount + ' SOL',
          amountOut: formatNum(outAmt) + ' ' + (symbol || ''),
          sig, time: Date.now(),
        });
        if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
        lsSetJSON('ghost-trades', tradeHistory);
        renderTradeHistory();
        
        // Auto SL/TP if enabled
        if (sltpEnabled) {
          const slPct = parseFloat($('manual-sl')?.value) || 30;
          const tpPct = parseFloat($('manual-tp')?.value) || 100;
          const pricePerToken = solAmount / outAmt;
          manualPositions[mint] = {
            symbol: symbol || mint.slice(0,6), mint, entryPrice: pricePerToken,
            sl: slPct, tp: tpPct, amount: outAmt, time: Date.now()
          };
          lsSetJSON('ghost-manual-positions', manualPositions);
          startManualSltpMonitor();
        }
        
      } catch (e) {
        const msg = e.message || 'Trade failed';
        if (msg.includes('User rejected')) {
          setStatus('error', '❌ Rejected in wallet');
        } else {
          setStatus('error', '❌ ' + msg.slice(0, 60));
        }
        toast('❌ ' + msg.slice(0, 80));
      } finally {
        isTrading = false;
        if (allBtns) allBtns.forEach(b => b.classList.remove('loading'));
        if (btnEl) btnEl.textContent = origText;
        clearStatus();
      }
    }

    async function quickSell(mint, pct, symbol, btnEl) {
      if (!walletAddress) { toast('Connect wallet first!'); return; }
      if (isTrading) { toast('Trade already in progress...'); return; }
      if (isEVM()) { toast('Quick-sell is Solana only for now'); return; }
      
      const statusEl = btnEl?.closest('.qt-section')?.querySelector('.qt-status');
      const allBtns = btnEl?.closest('.qt-section')?.querySelectorAll('.qt-buy-btn, .qt-sell-btn');
      const setStatus = (cls, text) => {
        if (statusEl) { statusEl.className = 'qt-status active ' + cls; statusEl.textContent = text; }
      };
      const clearStatus = () => { if (statusEl) setTimeout(() => statusEl.className = 'qt-status', 4000); };
      
      isTrading = true;
      if (allBtns) allBtns.forEach(b => b.classList.add('loading'));
      const origText = btnEl?.textContent || '';
      if (btnEl) btnEl.textContent = '...';
      
      const slippage = parseFloat($('tr-slippage')?.value) || 15;
      const priority = parseFloat($('tr-priority')?.value) || 0.0005;

      try {
        setStatus('pending', '⏳ Checking balance...');
        const tokenBalance = await getTokenBalance(mint);
        if (!tokenBalance || tokenBalance <= 0) throw new Error('No token balance found');
        const tokenDecimals = await getTokenDecimals(mint);
        const sellAmount = tokenBalance * (pct / 100);
        const lamports = Math.round(sellAmount * Math.pow(10, tokenDecimals));
        
        setStatus('pending', '⏳ Getting sell quote...');
        const jupResult = await jupQuote(mint, SOL_MINT, lamports, Math.round(slippage * 100));
        if (!jupResult) throw new Error('Jupiter quote failed — token may have no liquidity or routes');
        
        setStatus('pending', '⏳ Building transaction...');
        const swapData = await jupSwap(jupResult.endpoint, jupResult.quote, walletAddress, Math.round(priority * 1e9));
        
        setStatus('pending', '⏳ Simulating...');
        const txBuf = Uint8Array.from(atob(swapData.swapTransaction), c => c.charCodeAt(0));
        const tx = solanaWeb3.VersionedTransaction.deserialize(txBuf);
        try {
          const simConn = await getWorkingConnection();
          const simResult = await simConn.simulateTransaction(tx, { sigVerify: false });
          if (simResult.value.err) throw new Error('Simulation failed: trade would fail on-chain');
        } catch (simErr) {
          if (simErr.message.includes('Simulation failed:')) throw simErr;
        }
        
        setStatus('pending', '✍️ Sign in wallet...');
        const solSigner = getSolanaSigner();
        if (!solSigner) throw new Error('Wallet signer not found');
        const signed = await solSigner.signTransaction(tx);
        
        setStatus('pending', mevEnabled ? '🛡️ Sending via Jito...' : '📡 Submitting...');
        const rawTx = signed.serialize();
        let sig;
        if (mevEnabled) {
          try { sig = await sendViaJito(rawTx); }
          catch (e) {
            const conn = await getWorkingConnection();
            sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
          }
        } else {
          const conn = await getWorkingConnection();
          sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
        }
        
        setStatus('pending', '⏳ Confirming...');
        const confirmConn = await getWorkingConnection();
        await confirmConn.confirmTransaction(sig, 'confirmed');
        
        const solOut = parseInt(jupResult.quote.outAmount) / 1e9;
        
        setStatus('success', `✅ Sold ${pct}% for ${solOut.toFixed(4)} SOL!`);
        toast(`✅ Sold ${pct}% of ${symbol || ''} for ${solOut.toFixed(4)} SOL`, 5000);
        
        tradeHistory.unshift({
          side: 'sell', symbol: symbol || mint.slice(0,6), mint,
          amountIn: formatNum(sellAmount) + ' ' + (symbol || ''),
          amountOut: solOut.toFixed(4) + ' SOL',
          sig, time: Date.now(),
        });
        if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
        lsSetJSON('ghost-trades', tradeHistory);
        renderTradeHistory();
        
        // Remove SL/TP position if sold 100%
        if (pct >= 100 && manualPositions[mint]) {
          delete manualPositions[mint];
          lsSetJSON('ghost-manual-positions', manualPositions);
        }
        
      } catch (e) {
        const msg = e.message || 'Sell failed';
        if (msg.includes('User rejected')) {
          setStatus('error', '❌ Rejected in wallet');
        } else {
          setStatus('error', '❌ ' + msg.slice(0, 60));
        }
        toast('❌ ' + msg.slice(0, 80));
      } finally {
        isTrading = false;
        if (allBtns) allBtns.forEach(b => b.classList.remove('loading'));
        if (btnEl) btnEl.textContent = origText;
        clearStatus();
      }
    }

    async function executeTrade(side) {
      if (!walletAddress) { toast('Connect wallet first!'); return; }
      if (isTrading) return;
      if (isEVM()) { executeEVMTrade(side); return; }

      const mint = $('tr-mint').value.trim();
      const amount = parseFloat($('tr-amount').value);
      const slippage = parseFloat($('tr-slippage').value) || 1;
      const priority = parseFloat($('tr-priority').value) || 0.0005;

      if (!mint || mint.length < 32) { toast('Paste a valid token address'); return; }
      if (!amount || amount <= 0) { toast('Enter an amount'); return; }

      isTrading = true;
      const btn = side === 'buy' ? $('tr-buy-btn') : $('tr-sell-btn');
      const origText = btn.textContent;
      btn.classList.add('loading');
      btn.textContent = side === 'buy' ? 'GETTING QUOTE...' : 'GETTING QUOTE...';
      btn.disabled = true;

      try {
        // Step 1: Get quote
        let inputMint, outputMint, lamports;
        if (side === 'buy') {
          inputMint = SOL_MINT;
          outputMint = mint;
          lamports = Math.round(amount * 1e9);
        } else {
          inputMint = mint;
          outputMint = SOL_MINT;
          // For sell: amount is in SOL worth, we need token amount
          // Get token balance instead
          const tokenBalance = await getTokenBalance(mint);
          if (!tokenBalance || tokenBalance <= 0) {
            throw new Error('No token balance to sell');
          }
          const tokenDecimals = await getTokenDecimals(mint);
          // Apply sell percentage (25%, 50%, 75%, 100%)
          const sellAmount = tokenBalance * (sellPct / 100);
          lamports = Math.round(sellAmount * Math.pow(10, tokenDecimals));
        }

        btn.textContent = 'FETCHING ROUTE...';
        const jupResult = await jupQuote(inputMint, outputMint, lamports, Math.round(slippage * 100));
        if (!jupResult) throw new Error('All Jupiter endpoints failed — check connection');
        const quote = jupResult.quote;

        // Step 2: Get swap transaction
        btn.textContent = 'BUILDING TX...';
        const swapData = await jupSwap(jupResult.endpoint, quote, walletAddress, Math.round(priority * 1e9));

        // Step 3: Simulate transaction to catch errors early
        btn.textContent = 'SIMULATING...';
        const txBuf = Uint8Array.from(atob(swapData.swapTransaction), c => c.charCodeAt(0));
        const tx = solanaWeb3.VersionedTransaction.deserialize(txBuf);
        try {
          const simConn = await getWorkingConnection();
          const simResult = await simConn.simulateTransaction(tx, { sigVerify: false });
          if (simResult.value.err) {
            const simErr = typeof simResult.value.err === 'object' ? JSON.stringify(simResult.value.err) : String(simResult.value.err);
            throw new Error('Simulation failed: ' + simErr + '. Trade would fail on-chain — saving your gas fees.');
          }
        } catch (simErr) {
          if (simErr.message.includes('Simulation failed:')) throw simErr;
          console.warn('Simulation skipped (RPC issue):', simErr.message);
        }

        // Step 4: Sign with wallet
        const walletLabel = activeWalletId ? WALLET_PROVIDERS[activeWalletId].name.toUpperCase() : 'WALLET';
        btn.textContent = 'SIGN IN ' + walletLabel + '...';
        const solSigner = getSolanaSigner();
        if (!solSigner) throw new Error('Wallet signer not found — reconnect your wallet');
        const signed = await solSigner.signTransaction(tx);

        // Step 5: Send to Solana (via Jito if MEV protection is on)
        btn.textContent = mevEnabled ? 'JITO BUNDLE...' : 'SUBMITTING...';
        const rawTx = signed.serialize();
        let sig;

        if (mevEnabled) {
          try {
            sig = await sendViaJito(rawTx);
          } catch (jitoErr) {
            // Fallback to regular RPC if Jito fails
            console.warn('Jito failed, falling back to RPC:', jitoErr);
            btn.textContent = 'FALLBACK RPC...';
            const conn = await getWorkingConnection();
            sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
          }
        } else {
          const conn = await getWorkingConnection();
          sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
        }

        btn.textContent = 'CONFIRMING...';
        const confirmConn = await getWorkingConnection();
        await confirmConn.confirmTransaction(sig, 'confirmed');

        // Success!
        const tokenDecimals = await getTokenDecimals(side === 'buy' ? mint : SOL_MINT);
        const outAmt = parseInt(quote.outAmount) / Math.pow(10, side === 'buy' ? tokenDecimals : 9);
        const symbol = $('tr-token-name')?.textContent || mint.slice(0, 6);

        toast(`✅ ${side === 'buy' ? 'Bought' : 'Sold'} ${symbol}!`, 5000);

        // Add to history
        const trade = {
          side, symbol, mint,
          amountIn: side === 'buy' ? amount + ' SOL' : formatNum(lamports / Math.pow(10, tokenDecimals)) + ' ' + symbol,
          amountOut: side === 'buy' ? formatNum(outAmt) + ' ' + symbol : outAmt.toFixed(4) + ' SOL',
          sig: sig,
          time: Date.now(),
        };
        tradeHistory.unshift(trade);
        if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
        lsSetJSON('ghost-trades', tradeHistory);
        renderTradeHistory();

        // Log to chat
        if ($('empty-state')) $('empty-state').style.display = 'none';
        addMsg('success',
          `${side === 'buy' ? '🟢 BUY' : '🔴 SELL'} EXECUTED\n\nToken: ${symbol}\nPaid: ${trade.amountIn}\nReceived: ${trade.amountOut}\nTx: ${sig.slice(0, 20)}...\n\n🔍 https://solscan.io/tx/${sig}`
        );

        // Refresh balance
        try {
          const refreshConn = await getWorkingConnection();
          walletBalance = (await refreshConn.getBalance(walletPubkey)) / 1e9;
          updateWalletPanel();
        } catch(e) {}

        // Register for SL/TP monitoring if enabled
        if (side === 'buy') registerManualPosition(mint, symbol, amount);

        // Refresh positions
        setTimeout(refreshPositions, 2000);

      } catch(e) {
        console.error('Trade error:', e);
        const errMsg = e.message || 'Trade failed';
        if (errMsg.includes('User rejected')) {
          toast('Transaction rejected in Phantom');
        } else {
          toast('❌ ' + errMsg.slice(0, 60));
          if ($('empty-state')) $('empty-state').style.display = 'none';
          addMsg('system', `❌ ${side.toUpperCase()} failed: ${errMsg}\n\nCheck: enough SOL? Slippage high enough? Token still liquid?`);
        }
      }

      isTrading = false;
      btn.classList.remove('loading');
      btn.textContent = origText;
      btn.disabled = !walletAddress;
    }

    async function getTokenBalance(mint) {
      if (isEVM()) return getEVMTokenBalance(mint);
      try {
        const conn = await getWorkingConnection();
        const tokenAccounts = await conn.getParsedTokenAccountsByOwner(
          walletPubkey,
          { mint: new solanaWeb3.PublicKey(mint) }
        );
        if (tokenAccounts.value.length > 0) {
          return tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
        }
        return 0;
      } catch(e) { return 0; }
    }

    // ═══════ POSITIONS ═══════
    async function refreshPositions() {
      if (isEVM()) { refreshEVMPositions(); return; }
      if (!walletAddress) {
        $('positions-list').innerHTML = '<div class="pos-empty">Connect wallet to see positions</div>';
        return;
      }
      $('positions-list').innerHTML = '<div class="pos-empty">Loading positions...</div>';

      try {
        const conn = await getWorkingConnection();
        const tokenAccounts = await conn.getParsedTokenAccountsByOwner(
          walletPubkey,
          { programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') }
        );

        const positions = tokenAccounts.value
          .map(ta => {
            const info = ta.account.data.parsed.info;
            const amt = info.tokenAmount.uiAmount;
            if (amt <= 0) return null;
            return {
              mint: info.mint,
              amount: amt,
              decimals: info.tokenAmount.decimals,
            };
          })
          .filter(Boolean);

        if (positions.length === 0) {
          $('positions-list').innerHTML = '<div class="pos-empty">No token positions found</div>';
          return;
        }

        // Get prices for all mints
        const mints = positions.map(p => p.mint).join(',');
        let prices = {};
        try {
          const priceRes = await fetch(`${JUP_PRICE}?ids=${mints}`);
          if (priceRes.ok) {
            const priceData = await priceRes.json();
            prices = priceData.data || {};
          }
        } catch(e) {}

        let html = '';
        for (const pos of positions.slice(0, 20)) {
          const priceInfo = prices[pos.mint];
          const symbol = priceInfo?.mintSymbol || pos.mint.slice(0, 6) + '...';
          const price = priceInfo ? parseFloat(priceInfo.price) : 0;
          const value = price * pos.amount;
          const valueStr = value > 0 ? '$' + (value < 0.01 ? value.toFixed(6) : value.toFixed(2)) : '—';

          html += `
            <div class="pos-card" onclick="$('tr-mint').value='${pos.mint}';onMintInput('${pos.mint}');">
              <div class="pos-top">
                <span class="pos-symbol">${symbol}</span>
                <span class="pos-value">${valueStr}</span>
              </div>
              <div class="pos-bottom">
                <span>${formatNum(pos.amount)} tokens</span>
                <span>${price > 0 ? '$' + (price < 0.001 ? price.toFixed(8) : price.toFixed(6)) : '—'}</span>
              </div>
            </div>`;
        }
        $('positions-list').innerHTML = html;
      } catch(e) {
        console.error('Positions error:', e);
        $('positions-list').innerHTML = '<div class="pos-empty">Failed to load positions</div>';
      }
    }

    // ═══════ TRADE HISTORY ═══════
    function renderTradeHistory() {
      if (tradeHistory.length === 0) {
        $('trade-history').innerHTML = '<div class="pos-empty" style="padding:16px;">No trades yet</div>';
        updateSessionStats();
        return;
      }
      let html = '';
      for (const t of tradeHistory.slice(0, 20)) {
        const time = new Date(t.time);
        const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const chainBadge = t.chain && t.chain !== 'solana' && CHAINS[t.chain] ? ` <span style="font-size:9px;color:${CHAINS[t.chain].color};font-weight:700;">${CHAINS[t.chain].name.toUpperCase()}</span>` : '';
        html += `
          <div class="th-item">
            <span class="th-action ${t.side === 'buy' ? 'th-buy' : 'th-sell'}">${t.side.toUpperCase()}</span>
            <span class="th-details">${t.symbol}${chainBadge} · ${t.amountIn} → ${t.amountOut}</span>
            <span class="th-time">${timeStr}</span>
          </div>`;
      }
      $('trade-history').innerHTML = html;
      updateSessionStats();
    }

    function updateSessionStats() {
      const el = $('session-stats');
      if (!el || tradeHistory.length === 0) { if (el) el.style.display = 'none'; return; }
      const today = new Date(); today.setHours(0,0,0,0);
      const todayTrades = tradeHistory.filter(t => t.time >= today.getTime());
      const buys = todayTrades.filter(t => t.side === 'buy').length;
      const sells = todayTrades.filter(t => t.side === 'sell').length;
      let buyVol = 0, sellVol = 0;
      for (const t of todayTrades) {
        if (t.side === 'buy' && t.amountIn?.includes('SOL')) buyVol += parseFloat(t.amountIn?.replace(/[^0-9.]/g,'') || 0);
        else if (t.side === 'sell' && t.amountOut?.includes('SOL')) sellVol += parseFloat(t.amountOut?.replace(/[^0-9.]/g,'') || 0);
      }
      const pnl = sellVol - buyVol;
      const pnlStr = pnl >= 0 ? '+' + pnl.toFixed(3) : pnl.toFixed(3);
      const pnlColor = pnl >= 0 ? 'var(--green)' : 'var(--red)';
      const alphaActive = typeof alphaPositions !== 'undefined' ? Object.keys(alphaPositions).length : 0;
      el.style.display = 'flex';
      el.innerHTML = '<span>📊 Today: ' + (buys+sells) + ' trades</span><span>' + buys + 'B/' + sells + 'S</span><span style="color:' + pnlColor + '">' + pnlStr + ' SOL</span>' + (alphaActive > 0 ? '<span>🧠 ' + alphaActive + ' alpha</span>' : '') + (sltpEnabled ? '<span>🎯 SL/TP</span>' : '');
    }

    function clearTradeHistory() {
      tradeHistory = [];
      lsRemove('ghost-trades');
      renderTradeHistory();
      toast('Trade history cleared');
    }

    function exportTradesCsv() {
      if (tradeHistory.length === 0) { toast('No trades to export'); return; }
      const headers = 'Date,Time,Side,Symbol,Mint,Amount In,Amount Out,Tx Signature\n';
      const rows = tradeHistory.map(t => {
        const d = new Date(t.time);
        return d.toLocaleDateString() + ',' + d.toLocaleTimeString() + ',' + t.side + ',' +
          (t.symbol||'').replace(/,/g,' ') + ',' + t.mint + ',' +
          (t.amountIn||'').replace(/,/g,' ') + ',' + (t.amountOut||'').replace(/,/g,' ') + ',' + (t.sig||'');
      }).join('\n');
      const blob = new Blob([headers + rows], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url;
      a.download = 'ghost-trades-' + new Date().toISOString().slice(0,10) + '.csv';
      a.click(); URL.revokeObjectURL(url);
      toast('📥 Trades exported');
    }

    // ═══════ TOKEN INTEL ═══════
    const DEXSCREENER_API = 'https://api.dexscreener.com/latest/dex';

    async function fetchTokenIntel() {
      const input = $('intel-mint').value.trim();
      if (!input) { toast('Enter a mint address or ticker'); return; }

      $('intel-results').innerHTML = '<div class="intel-empty"><div class="intel-empty-icon" style="animation:pulse 1s infinite;">⬡</div><div class="intel-empty-text">Scanning token...</div></div>';

      try {
        let pairs = [];
        // If it looks like a mint address (base58, 32-44 chars)
        if (/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(input)) {
          const res = await fetch(`${DEXSCREENER_API}/tokens/${input}`);
          const data = await res.json();
          pairs = data.pairs || [];
        } else {
          // Search by ticker
          const res = await fetch(`${DEXSCREENER_API}/search/?q=${encodeURIComponent(input)}`);
          const data = await res.json();
          pairs = (data.pairs || []).filter(p => p.chainId === getChain().dexScreenerChain);
        }

        if (pairs.length === 0) {
          $('intel-results').innerHTML = '<div class="intel-empty"><div class="intel-empty-icon">⬡</div><div class="intel-empty-text">No token data found.<br>Check the address or try a different ticker.</div></div>';
          return;
        }

        // Use highest liquidity pair
        const pair = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
        const mint = pair.baseToken?.address || input;
        const symbol = pair.baseToken?.symbol || '???';
        const name = pair.baseToken?.name || symbol;
        const price = pair.priceUsd ? parseFloat(pair.priceUsd) : 0;
        const priceNative = pair.priceNative ? parseFloat(pair.priceNative) : 0;
        const change5m = pair.priceChange?.m5 || 0;
        const change1h = pair.priceChange?.h1 || 0;
        const change6h = pair.priceChange?.h6 || 0;
        const change24h = pair.priceChange?.h24 || 0;
        const vol24h = pair.volume?.h24 || 0;
        const vol6h = pair.volume?.h6 || 0;
        const txns24h = pair.txns?.h24 || { buys: 0, sells: 0 };
        const liquidity = pair.liquidity?.usd || 0;
        const fdv = pair.fdv || 0;
        const marketCap = pair.marketCap || fdv;
        const pairCreated = pair.pairCreatedAt ? new Date(pair.pairCreatedAt) : null;
        const dexId = pair.dexId || 'unknown';

        // Calculate risk score
        let riskScore = 0;
        let riskFactors = [];
        if (liquidity < 5000) { riskScore += 35; riskFactors.push('Very low liquidity'); }
        else if (liquidity < 20000) { riskScore += 20; riskFactors.push('Low liquidity'); }
        else if (liquidity < 100000) { riskScore += 10; riskFactors.push('Moderate liquidity'); }
        if (pairCreated && (Date.now() - pairCreated.getTime()) < 86400000) { riskScore += 20; riskFactors.push('Token < 24h old'); }
        else if (pairCreated && (Date.now() - pairCreated.getTime()) < 604800000) { riskScore += 10; riskFactors.push('Token < 7 days old'); }
        if (vol24h < 1000) { riskScore += 15; riskFactors.push('Very low volume'); }
        if (txns24h.buys + txns24h.sells < 20) { riskScore += 10; riskFactors.push('Few transactions'); }
        if (fdv > 0 && liquidity > 0 && liquidity / fdv < 0.02) { riskScore += 15; riskFactors.push('Low liq/mcap ratio'); }
        riskScore = Math.min(riskScore, 100);
        const riskClass = riskScore <= 30 ? 'low' : riskScore <= 60 ? 'med' : 'high';
        const riskLabel = riskScore <= 30 ? 'LOW RISK' : riskScore <= 60 ? 'MEDIUM RISK' : 'HIGH RISK';

        // Fetch top holders via Solana RPC
        let holdersHtml = '';
        try {
          const conn = await getWorkingConnection();
          const largestAccounts = await conn.getTokenLargestAccounts(new solanaWeb3.PublicKey(mint));
          const supply = await conn.getTokenSupply(new solanaWeb3.PublicKey(mint));
          const totalSupply = supply.value.uiAmount || 1;

          for (let i = 0; i < Math.min(largestAccounts.value.length, 10); i++) {
            const acc = largestAccounts.value[i];
            const pct = ((acc.uiAmount / totalSupply) * 100).toFixed(1);
            const addr = acc.address.toString();
            holdersHtml += `
              <div class="intel-holder">
                <span class="intel-holder-rank">${i + 1}</span>
                <span class="intel-holder-addr" title="${addr}">${addr.slice(0, 6)}...${addr.slice(-4)}</span>
                <span class="intel-holder-pct" style="color:${parseFloat(pct) > 10 ? 'var(--red)' : parseFloat(pct) > 5 ? 'var(--yellow)' : 'var(--text-primary)'}">${pct}%</span>
              </div>`;
          }
        } catch (e) {
          holdersHtml = '<div style="padding:8px;font-size:11px;color:var(--text-muted);">Could not load holders</div>';
        }

        // Format age
        let ageStr = '—';
        if (pairCreated) {
          const ageMs = Date.now() - pairCreated.getTime();
          if (ageMs < 3600000) ageStr = Math.floor(ageMs / 60000) + 'm';
          else if (ageMs < 86400000) ageStr = Math.floor(ageMs / 3600000) + 'h';
          else ageStr = Math.floor(ageMs / 86400000) + 'd';
        }

        const fmtUsd = (n) => {
          if (n >= 1e9) return '$' + (n / 1e9).toFixed(1) + 'B';
          if (n >= 1e6) return '$' + (n / 1e6).toFixed(1) + 'M';
          if (n >= 1e3) return '$' + (n / 1e3).toFixed(1) + 'K';
          return '$' + n.toFixed(0);
        };
        const fmtPrice = (p) => {
          if (p === 0) return '$0';
          if (p < 0.000001) return '$' + p.toFixed(10);
          if (p < 0.01) return '$' + p.toFixed(6);
          if (p < 1) return '$' + p.toFixed(4);
          return '$' + p.toFixed(2);
        };

        $('intel-results').innerHTML = `
          <div class="intel-card">
            <div class="intel-hero">
              <div class="intel-hero-name">${name}</div>
              <div class="intel-hero-ticker">$${symbol} · ${dexId.toUpperCase()}</div>
              <div class="intel-hero-price">${fmtPrice(price)}</div>
              <div>
                <span class="intel-hero-change ${change5m >= 0 ? 'up' : 'down'}">5m: ${change5m > 0 ? '+' : ''}${change5m.toFixed(1)}%</span>
                <span style="margin:0 6px;color:var(--text-faint);">·</span>
                <span class="intel-hero-change ${change1h >= 0 ? 'up' : 'down'}">1h: ${change1h > 0 ? '+' : ''}${change1h.toFixed(1)}%</span>
                <span style="margin:0 6px;color:var(--text-faint);">·</span>
                <span class="intel-hero-change ${change24h >= 0 ? 'up' : 'down'}">24h: ${change24h > 0 ? '+' : ''}${change24h.toFixed(1)}%</span>
              </div>
            </div>
          </div>

          <div class="intel-card">
            <div class="intel-card-title">Market Data</div>
            <div class="intel-grid">
              <div class="intel-stat"><div class="intel-stat-label">Market Cap</div><div class="intel-stat-val">${fmtUsd(marketCap)}</div></div>
              <div class="intel-stat"><div class="intel-stat-label">FDV</div><div class="intel-stat-val">${fmtUsd(fdv)}</div></div>
              <div class="intel-stat"><div class="intel-stat-label">Liquidity</div><div class="intel-stat-val">${fmtUsd(liquidity)}</div></div>
              <div class="intel-stat"><div class="intel-stat-label">Vol 24h</div><div class="intel-stat-val">${fmtUsd(vol24h)}</div></div>
              <div class="intel-stat"><div class="intel-stat-label">Buys 24h</div><div class="intel-stat-val" style="color:var(--green);">${txns24h.buys}</div></div>
              <div class="intel-stat"><div class="intel-stat-label">Sells 24h</div><div class="intel-stat-val" style="color:var(--red);">${txns24h.sells}</div></div>
              <div class="intel-stat"><div class="intel-stat-label">Age</div><div class="intel-stat-val">${ageStr}</div></div>
              <div class="intel-stat"><div class="intel-stat-label">Price/SOL</div><div class="intel-stat-val">${priceNative < 0.001 ? priceNative.toFixed(8) : priceNative.toFixed(4)}</div></div>
            </div>
          </div>

          <div class="intel-card">
            <div class="intel-card-title">Risk Assessment</div>
            <div class="intel-risk">
              <div class="intel-risk-score risk-${riskClass}">${riskScore}</div>
              <div>
                <div class="intel-risk-label">${riskLabel}</div>
                <div class="intel-risk-desc">${riskFactors.length > 0 ? riskFactors.join(' · ') : 'No major risk factors detected'}</div>
              </div>
            </div>
          </div>

          <div class="intel-card">
            <div class="intel-card-title">Top Holders</div>
            ${holdersHtml}
          </div>

          <div class="intel-card">
            <div class="intel-card-title">Quick Actions</div>
            <div class="intel-links">
              <a class="intel-link" href="https://dexscreener.com/${getChain().dexScreenerChain}/${mint}" target="_blank">📊 DexScreener</a>
              ${activeChain === 'solana' ? `<a class="intel-link" href="https://birdeye.so/token/${mint}?chain=solana" target="_blank">🦅 Birdeye</a>` : ''}
              <a class="intel-link" href="${getChain().explorerAddr}${mint}" target="_blank">🔍 ${activeChain === 'solana' ? 'Solscan' : getChain().name + ' Explorer'}</a>
              ${activeChain === 'solana' ? `<a class="intel-link" href="https://rugcheck.xyz/tokens/${mint}" target="_blank">🛡 RugCheck</a>` : ''}
              <span class="intel-link" onclick="$('tr-mint').value='${mint}';onMintInput('${mint}');setMode('trade');">⟡ Trade</span>
            </div>
          </div>`;

      } catch (e) {
        console.error('Intel error:', e);
        $('intel-results').innerHTML = `<div class="intel-empty"><div class="intel-empty-icon">⚠️</div><div class="intel-empty-text">Error fetching data: ${e.message}</div></div>`;
      }
    }

    // ═══════ PORTFOLIO DASHBOARD ═══════
    async function refreshPortfolio() {
      if (!walletAddress) {
        $('portfolio-content').innerHTML = '<div class="intel-empty"><div class="intel-empty-icon">◐</div><div class="intel-empty-text">Connect wallet to view portfolio</div></div>';
        return;
      }

      $('portfolio-content').innerHTML = '<div class="intel-empty"><div class="intel-empty-icon" style="animation:pulse 1s infinite;">◐</div><div class="intel-empty-text">Loading portfolio...</div></div>';

      try {
        const conn = await getWorkingConnection();
        const solBalance = (await conn.getBalance(walletPubkey)) / 1e9;
        const tokenAccounts = await conn.getParsedTokenAccountsByOwner(
          walletPubkey,
          { programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') }
        );

        // Get SOL price
        let solPrice = 0;
        try {
          const solPriceRes = await fetch(`${JUP_PRICE}?ids=${SOL_MINT}`);
          if (solPriceRes.ok) {
            const solPriceData = await solPriceRes.json();
            solPrice = parseFloat(solPriceData.data?.[SOL_MINT]?.price || 0);
          }
        } catch(e) {}

        const solValue = solBalance * solPrice;

        const positions = tokenAccounts.value
          .map(ta => {
            const info = ta.account.data.parsed.info;
            const amt = info.tokenAmount.uiAmount;
            if (amt <= 0) return null;
            return { mint: info.mint, amount: amt, decimals: info.tokenAmount.decimals };
          })
          .filter(Boolean);

        // Get prices for all tokens
        let prices = {};
        if (positions.length > 0) {
          const mintList = positions.map(p => p.mint).join(',');
          try {
            const priceRes = await fetch(`${JUP_PRICE}?ids=${mintList}`);
            if (priceRes.ok) {
              const priceData = await priceRes.json();
              prices = priceData.data || {};
            }
          } catch(e) {}
        }

        // Build holdings with value
        let holdings = positions.map(pos => {
          const priceInfo = prices[pos.mint];
          const symbol = priceInfo?.mintSymbol || pos.mint.slice(0, 6) + '...';
          const price = priceInfo ? parseFloat(priceInfo.price) : 0;
          const value = price * pos.amount;
          return { ...pos, symbol, price, value };
        }).sort((a, b) => b.value - a.value);

        const totalTokenValue = holdings.reduce((sum, h) => sum + h.value, 0);
        const totalValue = solValue + totalTokenValue;
        const tokenCount = holdings.length;

        // Find PnL from trade history
        let totalBought = 0, totalSold = 0;
        for (const t of tradeHistory) {
          const solAmt = parseFloat(t.amountIn?.replace(/[^0-9.]/g, '') || 0);
          if (t.side === 'buy' && t.amountIn?.includes('SOL')) totalBought += solAmt;
          if (t.side === 'sell' && t.amountOut?.includes('SOL')) totalSold += parseFloat(t.amountOut?.replace(/[^0-9.]/g, '') || 0);
        }

        const fmtUsd = (n) => {
          if (n >= 1e6) return '$' + (n / 1e6).toFixed(2) + 'M';
          if (n >= 1e3) return '$' + (n / 1e3).toFixed(2) + 'K';
          return '$' + n.toFixed(2);
        };

        let html = `
          <div class="portfolio-summary">
            <div class="portfolio-total-label">Total Portfolio Value</div>
            <div class="portfolio-total">${fmtUsd(totalValue)}</div>
            <div class="portfolio-sol">${solBalance.toFixed(4)} SOL ($${solValue.toFixed(2)})</div>
          </div>
          <div class="portfolio-row">
            <div class="portfolio-stat-card">
              <div class="portfolio-stat-label">Tokens</div>
              <div class="portfolio-stat-val">${tokenCount}</div>
            </div>
            <div class="portfolio-stat-card">
              <div class="portfolio-stat-label">Token Value</div>
              <div class="portfolio-stat-val">${fmtUsd(totalTokenValue)}</div>
            </div>
            <div class="portfolio-stat-card">
              <div class="portfolio-stat-label">SOL Price</div>
              <div class="portfolio-stat-val">$${solPrice.toFixed(2)}</div>
            </div>
          </div>`;

        // SOL holding first
        html += `
          <div class="portfolio-holding" onclick="toast('SOL — native balance')">
            <div class="portfolio-holding-icon">◎</div>
            <div class="portfolio-holding-info">
              <div class="portfolio-holding-name">SOL</div>
              <div class="portfolio-holding-amount">${solBalance.toFixed(4)}</div>
            </div>
            <div class="portfolio-holding-right">
              <div class="portfolio-holding-value">$${solValue.toFixed(2)}</div>
              <div class="portfolio-holding-price">$${solPrice.toFixed(2)}</div>
            </div>
          </div>`;

        // Token holdings
        for (const h of holdings.slice(0, 30)) {
          const fmtAmt = h.amount > 1e6 ? (h.amount / 1e6).toFixed(2) + 'M' : h.amount > 1e3 ? (h.amount / 1e3).toFixed(1) + 'K' : h.amount.toFixed(2);
          const fmtVal = h.value > 0 ? '$' + (h.value < 0.01 ? h.value.toFixed(6) : h.value.toFixed(2)) : '$0.00';
          const fmtPrc = h.price > 0 ? '$' + (h.price < 0.001 ? h.price.toFixed(8) : h.price.toFixed(6)) : '—';
          const initial = h.symbol.charAt(0).toUpperCase();

          html += `
            <div class="portfolio-holding" onclick="$('intel-mint').value='${h.mint}';setMode('intel');fetchTokenIntel();">
              <div class="portfolio-holding-icon">${initial}</div>
              <div class="portfolio-holding-info">
                <div class="portfolio-holding-name">${h.symbol}</div>
                <div class="portfolio-holding-amount">${fmtAmt}</div>
              </div>
              <div class="portfolio-holding-right">
                <div class="portfolio-holding-value">${fmtVal}</div>
                <div class="portfolio-holding-price">${fmtPrc}</div>
              </div>
            </div>`;
        }

        $('portfolio-content').innerHTML = html;
      } catch (e) {
        console.error('Portfolio error:', e);
        $('portfolio-content').innerHTML = `<div class="intel-empty"><div class="intel-empty-icon">⚠️</div><div class="intel-empty-text">Error: ${e.message}</div></div>`;
      }
    }

    // ═══════ PNL ANALYTICS ═══════
    function renderPnlAnalytics() {
      const el = $('hist-pnl');
      if (tradeHistory.length === 0) {
        el.innerHTML = '<div class="intel-empty" style="padding:30px;"><div class="intel-empty-icon">📊</div><div class="intel-empty-text">No trades recorded yet.<br>Trade via Jupiter and your PnL analytics will appear here.</div></div>';
        return;
      }

      // Calculate stats
      let totalBuys = 0, totalSells = 0;
      let totalBuyVol = 0, totalSellVol = 0;
      let tokenStats = {};
      let firstTrade = Infinity, lastTrade = 0;

      for (const t of tradeHistory) {
        const sym = t.symbol || 'Unknown';
        if (!tokenStats[sym]) tokenStats[sym] = { buys: 0, sells: 0, buyVol: 0, sellVol: 0, trades: [] };
        tokenStats[sym].trades.push(t);

        if (t.side === 'buy') {
          totalBuys++;
          tokenStats[sym].buys++;
          const solAmt = parseFloat(t.amountIn?.replace(/[^0-9.]/g, '') || 0);
          if (t.amountIn?.includes('SOL')) { totalBuyVol += solAmt; tokenStats[sym].buyVol += solAmt; }
        } else {
          totalSells++;
          tokenStats[sym].sells++;
          const solAmt = parseFloat(t.amountOut?.replace(/[^0-9.]/g, '') || 0);
          if (t.amountOut?.includes('SOL')) { totalSellVol += solAmt; tokenStats[sym].sellVol += solAmt; }
        }

        if (t.time < firstTrade) firstTrade = t.time;
        if (t.time > lastTrade) lastTrade = t.time;
      }

      const totalTrades = totalBuys + totalSells;
      const netPnl = totalSellVol - totalBuyVol;
      const netPnlPct = totalBuyVol > 0 ? ((netPnl / totalBuyVol) * 100).toFixed(1) : '0.0';
      const avgTradeSize = totalBuyVol > 0 ? (totalBuyVol / totalBuys).toFixed(3) : '0';

      // Win rate: tokens where sellVol > buyVol
      let wins = 0, losses = 0;
      for (const sym in tokenStats) {
        const s = tokenStats[sym];
        if (s.sells > 0 && s.buys > 0) {
          if (s.sellVol > s.buyVol) wins++; else losses++;
        }
      }
      const winRate = (wins + losses) > 0 ? ((wins / (wins + losses)) * 100).toFixed(0) : '—';

      // Trading period
      let tradingPeriod = '—';
      if (firstTrade < Infinity) {
        const days = Math.floor((lastTrade - firstTrade) / 86400000);
        tradingPeriod = days > 0 ? days + 'd' : '<1d';
      }

      // Best / worst token
      let bestToken = { sym: '—', pnl: -Infinity };
      let worstToken = { sym: '—', pnl: Infinity };
      for (const sym in tokenStats) {
        const s = tokenStats[sym];
        const pnl = s.sellVol - s.buyVol;
        if (s.sells > 0 && pnl > bestToken.pnl) bestToken = { sym, pnl };
        if (s.sells > 0 && pnl < worstToken.pnl) worstToken = { sym, pnl };
      }

      const pnlColor = netPnl >= 0 ? 'var(--green)' : 'var(--red)';
      const pnlSign = netPnl >= 0 ? '+' : '';

      let html = `<div class="pnl-stats">
        <div class="pnl-stat-grid">
          <div class="pnl-stat pnl-stat-big">
            <div class="pnl-stat-label">Realized PnL (SOL)</div>
            <div class="pnl-stat-val" style="color:${pnlColor}">${pnlSign}${netPnl.toFixed(4)} SOL</div>
            <div style="font-size:11px;color:${pnlColor};margin-top:2px;">${pnlSign}${netPnlPct}%</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Total Trades</div>
            <div class="pnl-stat-val">${totalTrades}</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Win Rate</div>
            <div class="pnl-stat-val" style="color:${winRate !== '—' && parseInt(winRate) >= 50 ? 'var(--green)' : 'var(--red)'}">${winRate}${winRate !== '—' ? '%' : ''}</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Bought</div>
            <div class="pnl-stat-val">${totalBuyVol.toFixed(3)} SOL</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Sold</div>
            <div class="pnl-stat-val">${totalSellVol.toFixed(3)} SOL</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Avg Buy Size</div>
            <div class="pnl-stat-val">${avgTradeSize} SOL</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Active Period</div>
            <div class="pnl-stat-val">${tradingPeriod}</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Best Token</div>
            <div class="pnl-stat-val" style="color:var(--green);font-size:12px;">${bestToken.sym !== '—' ? bestToken.sym + ' +' + bestToken.pnl.toFixed(3) : '—'}</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-label">Worst Token</div>
            <div class="pnl-stat-val" style="color:var(--red);font-size:12px;">${worstToken.sym !== '—' ? worstToken.sym + ' ' + worstToken.pnl.toFixed(3) : '—'}</div>
          </div>
        </div>

        <div style="font-size:10px;font-weight:700;letter-spacing:0.1em;color:var(--text-muted);text-transform:uppercase;margin-bottom:8px;">Recent Trades</div>
      </div>
      <div style="padding:0 14px 14px;max-height:260px;overflow-y:auto;">`;

      // List recent trades
      for (const t of tradeHistory.slice(0, 30)) {
        const date = new Date(t.time);
        const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        html += `
          <div class="pnl-trade">
            <div class="pnl-trade-top">
              <span class="pnl-trade-pair">${t.symbol || 'Unknown'}</span>
              <span class="pnl-trade-side ${t.side}">${t.side.toUpperCase()}</span>
            </div>
            <div class="pnl-trade-bottom">
              <span>${t.amountIn} → ${t.amountOut}</span>
              <span>${dateStr} ${timeStr}</span>
            </div>
          </div>`;
      }

      html += '</div>';
      el.innerHTML = html;
    }

    // ═══════ CHAT MODE (AGENT / CHAT) ═══════
    function setChatMode(mode) {
      chatMode = mode;
      lsSet('ghost-chat-mode', mode);
      $('cmt-agent').classList.toggle('active', mode === 'agent');
      $('cmt-chat').classList.toggle('active', mode === 'chat');
      $('input').placeholder = mode === 'agent'
        ? 'Tell Ghost what to do...'
        : 'Chat with Claude...';
    }

    // ═══════ ALPHA BOT — AI COPY TRADER ═══════
    const JUPITER_V6_PROGRAM = 'JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4';
    const RAYDIUM_AMM_PROGRAM = '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8';
    let alphaWallets = lsGetJSON('ghost-alpha-wallets', []);
    let alphaStrategy = lsGet('ghost-alpha-strategy', '');
    let alphaBotRunning = false;
    let alphaPollTimer = null;
    let alphaLastSigs = lsGetJSON('ghost-alpha-lastsigs', {});
    let alphaBotLog = lsGetJSON('ghost-alpha-log', []);
    let alphaBotTrades = lsGetJSON('ghost-alpha-trades', []);
    let alphaDailyCount = 0;
    let alphaPositions = {}; // mint -> { symbol, entrySOL, amount, entryTime, sig, copiedFrom }
    let alphaClosedCount = parseInt(lsGet('ghost-alpha-closed-count', '0'));

    // ── Smart Trading Systems ──
    let alphaLastBuyTime = 0;          // Global cooldown tracker
    let alphaRecentBuys = {};          // mint -> timestamp (duplicate protection)
    let alphaPendingSignals = {};      // mint -> { wallets: [labels], firstSeen: timestamp } (wallet confirmation)

    // ── Scout Mode ──
    let alphaScoutEnabled = false;
    let alphaScoutTimer = null;
    let alphaScoutSeen = new Set();     // mints already evaluated
    let alphaScoutBuying = false;       // lock to prevent concurrent AI evals

    function saveAlphaState() {
      // Strip trades array from wallet objects to save space — only keep stats
      const walletsForSave = alphaWallets.map(w => ({
        address: w.address, label: w.label, stats: w.stats, addedAt: w.addedAt,
      }));
      lsSetJSON('ghost-alpha-wallets', walletsForSave);
      lsSetJSON('ghost-alpha-lastsigs', alphaLastSigs);
      lsSetJSON('ghost-alpha-log', alphaBotLog.slice(-50));
      lsSetJSON('ghost-alpha-trades', alphaBotTrades.slice(-100));
      lsSet('ghost-alpha-strategy', alphaStrategy);
      lsSet('ghost-alpha-closed-count', alphaClosedCount.toString());
    }

    function alphaLog(msg, type = 'info') {
      const entry = { time: Date.now(), msg, type };
      alphaBotLog.unshift(entry);
      if (alphaBotLog.length > 50) alphaBotLog = alphaBotLog.slice(0, 50);
      saveAlphaState();
      renderAlphaLog();
      // Also log to chat for important events
      if (type === 'trade' || type === 'error') {
        addMsg('system', `🧠 Alpha Bot: ${msg}`);
      }
    }

    function renderAlphaLog() {
      const el = $('alpha-log');
      if (!el) return;
      if (alphaBotLog.length === 0) {
        el.innerHTML = '<div class="alpha-log-entry"><span class="alpha-log-time">—</span><span class="alpha-log-msg">Bot idle. Add wallets and start.</span></div>';
        return;
      }
      el.innerHTML = alphaBotLog.slice(0, 25).map(e => {
        const t = new Date(e.time);
        const ts = t.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const color = e.type === 'trade' ? 'var(--green)' : e.type === 'error' ? 'var(--red)' : e.type === 'warn' ? 'var(--yellow)' : 'var(--text-secondary)';
        return `<div class="alpha-log-entry"><span class="alpha-log-time">${ts}</span><span class="alpha-log-msg" style="color:${color}">${e.msg}</span></div>`;
      }).join('');
    }

    function setAlphaStatus(status, text) {
      const el = $('alpha-status');
      if (!el) return;
      el.className = 'alpha-status-bar ' + status;
      $('alpha-status-text').textContent = text;
    }

    // ── Tracked Wallet Management ──
    function addAlphaWallet() {
      const addr = $('alpha-addr').value.trim();
      const label = $('alpha-label').value.trim() || 'Wallet ' + (alphaWallets.length + 1);
      if (!addr || addr.length < 32) { toast('Enter a valid wallet address'); return; }
      if (alphaWallets.some(w => w.address === addr)) { toast('Already tracking this wallet'); return; }
      if (alphaWallets.length >= 5) { toast('Max 5 tracked wallets'); return; }
      alphaWallets.push({ address: addr, label, trades: [], stats: null, addedAt: Date.now() });
      $('alpha-addr').value = '';
      $('alpha-label').value = '';
      saveAlphaState();
      renderAlphaWallets();
      alphaLog(`Added wallet: ${label} (${addr.slice(0, 4)}...${addr.slice(-4)})`);
      toast(`🧠 Tracking ${label}`);
    }

    function removeAlphaWallet(idx) {
      const w = alphaWallets[idx];
      if (!w) return;
      alphaWallets.splice(idx, 1);
      delete alphaLastSigs[w.address];
      saveAlphaState();
      renderAlphaWallets();
      toast('Removed ' + w.label);
    }

    function renderAlphaWallets() {
      const el = $('alpha-wallets');
      if (!el) return;
      if (alphaWallets.length === 0) {
        el.innerHTML = '<div style="font-size:11px;color:var(--text-muted);padding:6px 0;">No wallets tracked yet</div>';
        return;
      }
      const bgColors = ['#22d1ee', '#f59e0b', '#34d399', '#a78bfa', '#f472b6'];
      el.innerHTML = alphaWallets.map((w, i) => {
        const addr = w.address;
        const c = bgColors[i % 5];
        const s = w.stats;
        const statsHtml = s ? `
          <div class="alpha-stat-grid">
            <div class="alpha-stat-pill"><span>Trades</span><span>${s.totalTrades}</span></div>
            <div class="alpha-stat-pill"><span>Win Rate</span><span>${s.winRate}%</span></div>
            <div class="alpha-stat-pill ${parseFloat(s.pnl) >= 0 ? 'green' : 'red'}"><span>PnL</span><span>${parseFloat(s.pnl) >= 0 ? '+' : ''}${s.pnl} SOL</span></div>
            <div class="alpha-stat-pill"><span>Avg Buy</span><span>${s.avgBuySize} SOL</span></div>
            <div class="alpha-stat-pill"><span>Buys</span><span>${s.buys}</span></div>
            <div class="alpha-stat-pill"><span>Sells</span><span>${s.sells}</span></div>
          </div>` : '<div style="font-size:9px;color:var(--text-faint);margin-bottom:6px;">Click "Study Wallets" to analyze</div>';

        const holdingsId = `alpha-holdings-${i}`;
        return `<div class="alpha-wallet" id="alpha-wcard-${i}">
          <div class="alpha-wallet-head" onclick="toggleAlphaWallet(${i})">
            <div class="alpha-wallet-icon" style="background:${c}22;color:${c}">${w.label.charAt(0).toUpperCase()}</div>
            <div class="alpha-wallet-info">
              <div class="alpha-wallet-label">${w.label}</div>
              <div class="alpha-wallet-addr">${addr.slice(0, 8)}...${addr.slice(-6)}</div>
              <div class="alpha-wallet-stats">${s ? `${s.totalTrades} trades · ${s.winRate}% win · ${parseFloat(s.pnl) >= 0 ? '+' : ''}${s.pnl} SOL` : 'Not studied yet'}</div>
            </div>
            <span class="alpha-wallet-expand">▾</span>
            <button class="alpha-wallet-del" onclick="event.stopPropagation();removeAlphaWallet(${i})">✕</button>
          </div>
          <div class="alpha-wallet-body">
            ${statsHtml}
            <div class="alpha-holdings-title">Token Holdings</div>
            <div id="${holdingsId}"><div style="font-size:9px;color:var(--text-faint);">Click to load holdings...</div></div>
          </div>
        </div>`;
      }).join('');
    }

    function toggleAlphaWallet(idx) {
      const card = $(`alpha-wcard-${idx}`);
      if (!card) return;
      const wasOpen = card.classList.contains('open');
      card.classList.toggle('open');
      // Fetch holdings on first open
      if (!wasOpen) {
        const holdEl = $(`alpha-holdings-${idx}`);
        if (holdEl && holdEl.dataset.loaded !== 'true') {
          fetchAlphaWalletHoldings(alphaWallets[idx].address, idx);
        }
      }
    }

    async function fetchAlphaWalletHoldings(address, idx) {
      const holdEl = $(`alpha-holdings-${idx}`);
      if (!holdEl) return;
      holdEl.innerHTML = '<div style="font-size:9px;color:var(--text-faint);">Loading holdings...</div>';

      try {
        // Use Helius DAS API for token balances
        if (heliusKey) {
          const res = await fetch(`https://api.helius.xyz/v0/addresses/${address}/balances?api-key=${heliusKey}`);
          if (res.ok) {
            const data = await res.json();
            const tokens = (data.tokens || []).filter(t => t.amount > 0).slice(0, 15);
            const nativeSol = (data.nativeBalance || 0) / 1e9;

            if (tokens.length === 0 && nativeSol < 0.001) {
              holdEl.innerHTML = '<div style="font-size:9px;color:var(--text-faint);">No token holdings found</div>';
              holdEl.dataset.loaded = 'true';
              return;
            }

            // Fetch token metadata for symbols
            const mints = tokens.map(t => t.mint);
            let symbolMap = {};
            try {
              const metaRes = await fetch(`https://api.helius.xyz/v0/token-metadata?api-key=${heliusKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mintAccounts: mints.slice(0, 15), includeOffChain: true }),
              });
              if (metaRes.ok) {
                const metaData = await metaRes.json();
                for (const m of metaData) {
                  symbolMap[m.account] = m.onChainMetadata?.metadata?.data?.symbol?.replace(/\0/g, '') ||
                    m.offChainMetadata?.metadata?.symbol || m.account.slice(0, 6) + '...';
                }
              }
            } catch (e) { /* use fallback names */ }

            let html = `<div class="alpha-token-row">
              <span class="alpha-token-name">◎ SOL</span>
              <span class="alpha-token-bal">${nativeSol.toFixed(4)}</span>
            </div>`;

            for (const t of tokens) {
              const dec = t.decimals || 6;
              const bal = t.amount / Math.pow(10, dec);
              if (bal < 0.000001) continue;
              const sym = symbolMap[t.mint] || t.mint.slice(0, 6) + '...';
              const balStr = bal >= 1000000 ? (bal / 1000000).toFixed(2) + 'M' :
                bal >= 1000 ? (bal / 1000).toFixed(2) + 'K' : bal.toFixed(bal < 1 ? 6 : 2);
              html += `<div class="alpha-token-row">
                <span class="alpha-token-name">${sym}</span>
                <span class="alpha-token-bal">${balStr}</span>
              </div>`;
            }

            holdEl.innerHTML = html;
            holdEl.dataset.loaded = 'true';
            return;
          }
        }

        // Fallback: RPC getTokenAccountsByOwner
        const conn = await getWorkingConnection();
        const pubkey = new solanaWeb3.PublicKey(address);
        const sol = await conn.getBalance(pubkey);
        const tokenAccs = await conn.getParsedTokenAccountsByOwner(pubkey, { programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA') });

        const tokens = (tokenAccs.value || [])
          .map(a => a.account.data.parsed?.info)
          .filter(t => t && parseFloat(t.tokenAmount?.uiAmountString || '0') > 0)
          .slice(0, 15);

        let html = `<div class="alpha-token-row">
          <span class="alpha-token-name">◎ SOL</span>
          <span class="alpha-token-bal">${(sol / 1e9).toFixed(4)}</span>
        </div>`;

        for (const t of tokens) {
          const bal = parseFloat(t.tokenAmount?.uiAmountString || '0');
          const mint = t.mint;
          const balStr = bal >= 1000000 ? (bal / 1000000).toFixed(2) + 'M' :
            bal >= 1000 ? (bal / 1000).toFixed(2) + 'K' : bal.toFixed(bal < 1 ? 6 : 2);
          html += `<div class="alpha-token-row">
            <span class="alpha-token-name">${mint.slice(0, 6)}...</span>
            <span class="alpha-token-bal">${balStr}</span>
          </div>`;
        }

        holdEl.innerHTML = html;
        holdEl.dataset.loaded = 'true';
      } catch (e) {
        holdEl.innerHTML = `<div style="font-size:9px;color:var(--red);">Error: ${e.message}</div>`;
      }
    }

    function toggleAlphaSettings() {
      const body = $('alpha-settings-body');
      const arrow = $('alpha-settings-arrow');
      const isOpen = body.classList.toggle('open');
      arrow.textContent = isOpen ? '▾' : '▸';
    }

    // ── Alpha Bot Dedicated Wallet ──
    let alphaBotWallet = lsGetJSON('ghost-alpha-bot-wallet', null);

    function saveAlphaBotWallet() {
      const label = $('alpha-bot-label').value.trim() || 'Alpha Wallet';
      const privkey = $('alpha-bot-privkey').value.trim();
      if (!privkey) { toast('Paste a private key'); return; }

      try {
        const secretKey = bs58Decode(privkey);
        const keypair = solanaWeb3.Keypair.fromSecretKey(secretKey);
        const publicKey = keypair.publicKey.toString();

        alphaBotWallet = { label, publicKey, secretKey: privkey };
        lsSetJSON('ghost-alpha-bot-wallet', alphaBotWallet);

        $('alpha-bot-label').value = '';
        $('alpha-bot-privkey').value = '';
        renderAlphaBotWallet();
        refreshAlphaBotBalance();
        toast('🔑 Bot wallet saved: ' + publicKey.slice(0, 4) + '...' + publicKey.slice(-4));
      } catch (e) {
        toast('Invalid private key: ' + e.message);
      }
    }

    function removeAlphaBotWallet() {
      alphaBotWallet = null;
      lsRemove('ghost-alpha-bot-wallet');
      renderAlphaBotWallet();
      toast('Wallet removed');
    }

    function renderAlphaBotWallet() {
      const display = $('alpha-wallet-display');
      const form = $('alpha-wallet-form');
      if (alphaBotWallet) {
        display.style.display = 'block';
        form.style.display = 'none';
        $('alpha-wallet-label').textContent = alphaBotWallet.label;
        $('alpha-wallet-addr').textContent = alphaBotWallet.publicKey;
      } else {
        display.style.display = 'none';
        form.style.display = 'block';
      }
    }

    async function refreshAlphaBotBalance() {
      if (!alphaBotWallet) return;
      try {
        const conn = await getWorkingConnection();
        const bal = await conn.getBalance(new solanaWeb3.PublicKey(alphaBotWallet.publicKey));
        $('alpha-wallet-bal').textContent = '◎ ' + (bal / 1e9).toFixed(4) + ' SOL';
      } catch (e) {
        $('alpha-wallet-bal').textContent = 'Balance: error';
      }
    }

    function getAlphaBotWallet() {
      return alphaBotWallet;
    }

    // ── Helius API Key (optional enhancement) ──
    // heliusKey defined at top with globals
    function saveHeliusKey() {
      heliusKey = $('alpha-helius-key').value.trim();
      lsSet('ghost-helius-key', heliusKey);
      toast(heliusKey ? '🔑 Helius key saved' : 'Helius key cleared');
    }

    async function rpcGetTransaction(sig) {
      // Try multiple RPCs — public RPC often blocks getParsedTransaction
      for (const rpc of BACKUP_RPCS) {
        try {
          const res = await fetch(rpc, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              jsonrpc: '2.0', id: 1,
              method: 'getTransaction',
              params: [sig, { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 }],
            }),
          });
          if (!res.ok) continue;
          const data = await res.json();
          if (data.result) return data.result;
        } catch (e) { /* try next RPC */ }
      }
      return null;
    }

    function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ── Fetch Wallet Swap History ──
    async function fetchWalletSwaps(address, limit = 50) {
      // Path A: Helius API — fetch ALL types, not just SWAP
      if (heliusKey) {
        try {
          const url = `https://api.helius.xyz/v0/addresses/${address}/transactions?api-key=${heliusKey}&limit=${limit}`;
          const res = await fetch(url);
          if (res.ok) {
            const txns = await res.json();
            alphaLog(`  → Helius returned ${txns.length} transactions`, 'info');
            return parseHeliusSwaps(txns, address);
          }
        } catch (e) { alphaLog('Helius fallback to RPC: ' + e.message, 'warn'); }
      }

      // Path B: Multi-RPC fallback
      alphaLog('Using public RPC (slower)...');
      const conn = await getWorkingConnection();
      const pubkey = new solanaWeb3.PublicKey(address);
      const sigs = await conn.getSignaturesForAddress(pubkey, { limit });
      const swaps = [];

      for (const sigInfo of sigs.slice(0, 15)) {
        await delay(300);
        try {
          const tx = await rpcGetTransaction(sigInfo.signature);
          if (!tx || !tx.meta || tx.meta.err) continue;

          const pre = tx.meta.preTokenBalances || [];
          const post = tx.meta.postTokenBalances || [];
          const preMap = {}, postMap = {};
          for (const b of pre) { if (b.owner === address) preMap[b.mint] = b.uiTokenAmount?.uiAmount || 0; }
          for (const b of post) { if (b.owner === address) postMap[b.mint] = b.uiTokenAmount?.uiAmount || 0; }

          const preSol = (tx.meta.preBalances?.[0] || 0) / 1e9;
          const postSol = (tx.meta.postBalances?.[0] || 0) / 1e9;
          const solDelta = postSol - preSol;

          const allMints = new Set([...Object.keys(preMap), ...Object.keys(postMap)]);

          for (const mint of allMints) {
            if (mint === SOL_MINT) continue;
            const before = preMap[mint] || 0;
            const after = postMap[mint] || 0;
            const delta = after - before;

            if (delta > 0.000001 && solDelta < -0.001) {
              swaps.push({ sig: sigInfo.signature, side: 'buy', mint, tokenAmount: delta, solAmount: Math.abs(solDelta), time: (sigInfo.blockTime || 0) * 1000 });
            } else if (delta < -0.000001 && solDelta > 0.001) {
              swaps.push({ sig: sigInfo.signature, side: 'sell', mint, tokenAmount: Math.abs(delta), solAmount: solDelta, time: (sigInfo.blockTime || 0) * 1000 });
            }
          }
        } catch (e) { /* skip */ }
      }
      return swaps;
    }

    function parseHeliusSwaps(txns, address) {
      const swaps = [];
      for (const tx of txns) {
        const sig = tx.signature;
        const time = (tx.timestamp || 0) * 1000;

        // Method 1: Helius parsed swap events
        if (tx.events?.swap) {
          const swap = tx.events.swap;
          if (swap.nativeInput && swap.tokenOutputs?.length > 0) {
            const solAmount = parseInt(swap.nativeInput.amount || '0') / 1e9;
            for (const out of swap.tokenOutputs) {
              const dec = out.rawTokenAmount?.decimals || 6;
              const tokenAmount = parseInt(out.rawTokenAmount?.tokenAmount || '0') / Math.pow(10, dec);
              if (solAmount > 0.0001) swaps.push({ sig, side: 'buy', mint: out.mint, tokenAmount, solAmount, time });
            }
            continue;
          }
          if (swap.nativeOutput && swap.tokenInputs?.length > 0) {
            const solAmount = parseInt(swap.nativeOutput.amount || '0') / 1e9;
            for (const inp of swap.tokenInputs) {
              const dec = inp.rawTokenAmount?.decimals || 6;
              const tokenAmount = parseInt(inp.rawTokenAmount?.tokenAmount || '0') / Math.pow(10, dec);
              if (solAmount > 0.0001) swaps.push({ sig, side: 'sell', mint: inp.mint, tokenAmount, solAmount, time });
            }
            continue;
          }
          if (swap.tokenInputs?.length > 0 && swap.tokenOutputs?.length > 0) {
            for (const out of swap.tokenOutputs) {
              const dec = out.rawTokenAmount?.decimals || 6;
              const tokenAmount = parseInt(out.rawTokenAmount?.tokenAmount || '0') / Math.pow(10, dec);
              swaps.push({ sig, side: 'buy', mint: out.mint, tokenAmount, solAmount: 0.001, time });
            }
            continue;
          }
        }

        // Method 2: Analyze tokenTransfers + nativeTransfers for any tx type
        const tokenXfers = tx.tokenTransfers || [];
        const nativeXfers = tx.nativeTransfers || [];

        // SOL spent by this address (outgoing native)
        const solOut = nativeXfers.filter(n => n.fromUserAccount === address)
          .reduce((s, n) => s + (n.amount || 0), 0) / 1e9;
        // SOL received by this address (incoming native)
        const solIn = nativeXfers.filter(n => n.toUserAccount === address)
          .reduce((s, n) => s + (n.amount || 0), 0) / 1e9;

        // Tokens received by this address
        const tokensIn = tokenXfers.filter(t => t.toUserAccount === address && t.mint !== SOL_MINT);
        // Tokens sent from this address
        const tokensOut = tokenXfers.filter(t => t.fromUserAccount === address && t.mint !== SOL_MINT);

        // BUY pattern: SOL went out, tokens came in
        if (solOut > 0.001 && tokensIn.length > 0 && tokensOut.length === 0) {
          for (const t of tokensIn) {
            const dec = t.tokenStandard === 'Fungible' ? 6 : (t.rawTokenAmount?.decimals || 6);
            const amount = t.tokenAmount || (parseInt(t.rawTokenAmount?.tokenAmount || '0') / Math.pow(10, dec));
            if (amount > 0) swaps.push({ sig, side: 'buy', mint: t.mint, tokenAmount: amount, solAmount: solOut, time });
          }
        }

        // SELL pattern: tokens went out, SOL came in
        if (solIn > 0.001 && tokensOut.length > 0 && tokensIn.length === 0) {
          for (const t of tokensOut) {
            const dec = t.tokenStandard === 'Fungible' ? 6 : (t.rawTokenAmount?.decimals || 6);
            const amount = t.tokenAmount || (parseInt(t.rawTokenAmount?.tokenAmount || '0') / Math.pow(10, dec));
            if (amount > 0) swaps.push({ sig, side: 'sell', mint: t.mint, tokenAmount: amount, solAmount: solIn, time });
          }
        }
      }

      // Dedupe by signature (in case both methods matched)
      const seen = new Set();
      return swaps.filter(s => {
        const key = s.sig + s.mint + s.side;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    // ── Study Phase — Analyze All Tracked Wallets ──
    async function alphaStudy() {
      if (!apiKey) { toast('Set Claude API key first'); return; }
      if (alphaWallets.length === 0) { toast('Add wallets to study first'); return; }

      setAlphaStatus('studying', 'Studying wallets...');
      $('alpha-study-btn').disabled = true;
      $('alpha-study-btn').textContent = '📚 Studying...';
      alphaLog('Starting wallet study' + (heliusKey ? ' (Helius)' : ' (public RPC)') + '...');

      try {
        const walletData = [];

        for (const w of alphaWallets) {
          alphaLog(`Fetching swaps for ${w.label}...`);
          const swaps = await fetchWalletSwaps(w.address, 30);
          w.trades = swaps;

          const buys = swaps.filter(s => s.side === 'buy');
          const sells = swaps.filter(s => s.side === 'sell');
          const totalSolBought = buys.reduce((s, t) => s + t.solAmount, 0);
          const totalSolSold = sells.reduce((s, t) => s + t.solAmount, 0);
          const uniqueTokens = new Set(swaps.map(s => s.mint)).size;

          let wins = 0, losses = 0;
          for (const buy of buys) {
            const sell = sells.find(s => s.mint === buy.mint);
            if (sell) { if (sell.solAmount > buy.solAmount) wins++; else losses++; }
          }

          w.stats = {
            totalTrades: swaps.length, buys: buys.length, sells: sells.length,
            uniqueTokens,
            totalSolBought: totalSolBought.toFixed(3),
            totalSolSold: totalSolSold.toFixed(3),
            pnl: (totalSolSold - totalSolBought).toFixed(3),
            winRate: (wins + losses) > 0 ? Math.round((wins / (wins + losses)) * 100) : 0,
            avgBuySize: buys.length > 0 ? (totalSolBought / buys.length).toFixed(3) : '0',
          };

          walletData.push({
            label: w.label, address: w.address.slice(0, 8) + '...',
            stats: w.stats,
            recentBuys: buys.slice(0, 5).map(b => ({
              mint: b.mint.slice(0, 8) + '...',
              solAmount: b.solAmount.toFixed(3),
              time: new Date(b.time).toISOString(),
            })),
          });

          alphaLog(`${w.label}: ${swaps.length} trades, ${w.stats.winRate}% win rate, PnL: ${w.stats.pnl} SOL`);
        }

        renderAlphaWallets();
        saveAlphaState();

        // Ask Claude to generate strategy
        alphaLog('Generating strategy via Claude...');

        // Include bot's own trade history if available
        let botPerfSection = '';
        const closedTrades = alphaBotTrades.filter(t => t.side === 'sell' && t.copiedFrom);
        if (closedTrades.length > 0) {
          const perfByWallet = {};
          for (const t of closedTrades) {
            const from = t.copiedFrom;
            if (!perfByWallet[from]) perfByWallet[from] = { wins: 0, losses: 0, pnl: 0 };
            const pnl = parseFloat(t.pnl) || 0;
            if (pnl > 0) perfByWallet[from].wins++; else perfByWallet[from].losses++;
            perfByWallet[from].pnl += pnl;
          }
          botPerfSection = `\n\nBOT'S OWN RESULTS FROM COPYING (${closedTrades.length} closed trades):\n${JSON.stringify(perfByWallet, null, 2)}\nFactor these results into your wallet rankings and rules.`;
        }

        const strategyPrompt = `You are analyzing cryptocurrency trading wallets on Solana to build a copy-trading AND autonomous scouting strategy. Here is the data from tracked wallets:

${JSON.stringify(walletData, null, 2)}${botPerfSection}

Based on this data, generate a concise trading strategy profile. Include:
1. SUMMARY: One-line assessment of these wallets
2. WALLET RANKINGS: Rank wallets by reliability (win rate, PnL, consistency)
3. ENTRY RULES: When should the bot copy a trade? (consider: wallet confidence, position size, timing patterns)
4. EXIT RULES: Derive stop-loss and take-profit from how these wallets actually trade — analyze their win/loss ratios, average gains on winners, average losses on losers
5. AVOID: Any patterns suggesting bad trades to skip
6. SCOUT CRITERIA: What makes a token worth buying WITHOUT a wallet signal? Derive from what winning wallets pick early — describe ideal token profile: preferred age range (minutes), market cap range, liquidity range, minimum buy volume, buy/sell ratio thresholds, and any other patterns. Be specific with numbers.
7. CONFIDENCE SCORE: 0-100 overall confidence in this strategy

CRITICAL: You MUST include these exact lines somewhere in your response so the bot can parse them:
SL:XX (stop-loss percentage derived from wallet behavior, e.g. SL:25)
TP:XX (take-profit percentage derived from wallet behavior, e.g. TP:80)
These should reflect how the tracked wallets actually exit trades, not arbitrary numbers.

Be concise, use numbers. Output as plain text, not markdown.`;

        const res = await fetch(CLAUDE_API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true',
          },
          body: JSON.stringify({
            model: currentModel,
            max_tokens: 1500,
            messages: [{ role: 'user', content: strategyPrompt }],
          }),
        });

        if (!res.ok) throw new Error('Claude API error: ' + res.status);
        const data = await res.json();
        const strategyText = data.content?.[0]?.text || 'Failed to generate strategy';

        alphaStrategy = strategyText;
        $('alpha-strategy').textContent = strategyText;
        saveAlphaState();

        alphaLog('✅ Strategy generated successfully');
        setAlphaStatus('idle', 'Study complete — ready to trade');
        toast('🧠 Strategy generated!');

      } catch (e) {
        alphaLog('Error studying wallets: ' + e.message, 'error');
        setAlphaStatus('error', 'Study failed: ' + e.message);
      }

      $('alpha-study-btn').disabled = false;
      $('alpha-study-btn').textContent = '📚 Study';
    }

    // ── Live Trading ──
    function alphaToggle() {
      if (alphaBotRunning) {
        stopAlphaBot();
      } else {
        startAlphaBot();
      }
    }

    function startAlphaBot() {
      if (!alphaBotWallet) {
        toast('Add a bot wallet first (Settings → Bot Wallet)'); return;
      }
      if (alphaWallets.length === 0) {
        toast('Add wallets to track first'); return;
      }

      alphaBotRunning = true;
      alphaDailyCount = 0;
      alphaLastBuyTime = 0;
      alphaRecentBuys = {};
      alphaPendingSignals = {};
      const pollSec = 15;

      // Record current last signatures for each wallet
      alphaInitLastSigs();

      setAlphaStatus('live', `Running — polling every ${pollSec}s`);
      $('alpha-start-btn').textContent = '⏹ Stop Bot';
      $('alpha-start-btn').className = 'alpha-btn stop';
      alphaLog('🟢 Bot started — monitoring ' + alphaWallets.length + ' wallets');
      alphaLog('🛡 Active: 30s cooldown · duplicate filter · wallet weighting · 5/10/20min time exits · dead-token dump · 15s position checks');

      // Start polling
      alphaPollTimer = setInterval(() => alphaPoll(), pollSec * 1000);

      // Also check positions for stop-loss/take-profit
      alphaCheckPositions();

      toast('🧠 Alpha Bot is live!');
    }

    function stopAlphaBot() {
      alphaBotRunning = false;
      if (alphaPollTimer) { clearInterval(alphaPollTimer); alphaPollTimer = null; }
      // Stop scout
      alphaScoutEnabled = false;
      if (alphaScoutTimer) { clearInterval(alphaScoutTimer); alphaScoutTimer = null; }
      const scoutBtn = $('alpha-scout-btn');
      if (scoutBtn) {
        scoutBtn.textContent = '🔍 Scout Mode: OFF';
        scoutBtn.style.background = 'linear-gradient(135deg,#1a1a3e,#0d2137)';
        scoutBtn.style.borderColor = '#2a4a6a';
      }
      setAlphaStatus('idle', 'Bot stopped');
      $('alpha-start-btn').textContent = '▶ Start Bot';
      $('alpha-start-btn').className = 'alpha-btn start';
      alphaLog('🔴 Bot stopped');
      toast('Alpha Bot stopped');
    }

    async function alphaInitLastSigs() {
      const conn = await getWorkingConnection();
      for (const w of alphaWallets) {
        try {
          const sigs = await conn.getSignaturesForAddress(new solanaWeb3.PublicKey(w.address), { limit: 1 });
          if (sigs.length > 0) alphaLastSigs[w.address] = sigs[0].signature;
        } catch (e) {}
      }
      saveAlphaState();
    }

    async function alphaPoll() {
      if (!alphaBotRunning) return;
      const maxDaily = parseInt($('alpha-max-daily').value) || 10;
      if (alphaDailyCount >= maxDaily) {
        alphaLog('Max daily trades reached, skipping poll', 'warn');
        return;
      }

      const conn = await getWorkingConnection();

      // Clean stale recent buys (older than 5 min)
      const now = Date.now();
      for (const m of Object.keys(alphaRecentBuys)) {
        if (now - alphaRecentBuys[m] > 5 * 60 * 1000) delete alphaRecentBuys[m];
      }

      for (const w of alphaWallets) {
        try {
          // Step 1: Get recent signatures (works on public RPC)
          const sigs = await conn.getSignaturesForAddress(new solanaWeb3.PublicKey(w.address), { limit: 3 });
          if (sigs.length === 0) continue;

          const lastKnown = alphaLastSigs[w.address];
          const newSigs = [];
          for (const s of sigs) {
            if (s.signature === lastKnown) break;
            newSigs.push(s);
          }
          if (newSigs.length === 0) continue;

          alphaLastSigs[w.address] = sigs[0].signature;
          saveAlphaState();

          // Step 2: Parse new transactions
          if (heliusKey) {
            // Path A: Helius parse endpoint
            try {
              const sigList = newSigs.slice(0, 3).map(s => s.signature);
              const parseRes = await fetch(`https://api.helius.xyz/v0/transactions?api-key=${heliusKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ transactions: sigList }),
              });
              if (parseRes.ok) {
                const parsed = await parseRes.json();
                const detectedSwaps = parseHeliusSwaps(parsed, w.address);
                for (const s of detectedSwaps) {
                  if (s.side === 'buy') {
                    alphaLog(`🔔 ${w.label} bought ${s.mint.slice(0, 6)}... (${s.solAmount.toFixed(3)} SOL)`);
                    await alphaEvaluateAndBuy(s.mint, w, s.solAmount);
                  } else if (s.side === 'sell') {
                    alphaLog(`🔔 ${w.label} sold ${s.mint.slice(0, 6)}... (+${s.solAmount.toFixed(3)} SOL)`);
                    if (alphaPositions[s.mint]) {
                      alphaLog(`🚨 COPY-SELL triggered — ${w.label} is exiting ${alphaPositions[s.mint].symbol}!`, 'warn');
                      await alphaExecuteSell(s.mint);
                    }
                  }
                }
                continue; // Done with this wallet via Helius
              }
            } catch (e) { /* fall through to RPC */ }
          }

          // Path B: RPC fallback
          for (const sigInfo of newSigs.slice(0, 2)) {
            await delay(200);
            try {
              const tx = await rpcGetTransaction(sigInfo.signature);
              if (!tx || !tx.meta) continue;

              const pre = tx.meta.preTokenBalances || [];
              const post = tx.meta.postTokenBalances || [];
              const preMap = {}, postMap = {};
              for (const b of pre) { if (b.owner === w.address) preMap[b.mint] = b.uiTokenAmount?.uiAmount || 0; }
              for (const b of post) { if (b.owner === w.address) postMap[b.mint] = b.uiTokenAmount?.uiAmount || 0; }

              const preSol = (tx.meta.preBalances?.[0] || 0) / 1e9;
              const postSol = (tx.meta.postBalances?.[0] || 0) / 1e9;
              const solDelta = postSol - preSol;

              for (const mint of Object.keys(postMap)) {
                if (mint === SOL_MINT) continue;
                const before = preMap[mint] || 0;
                const after = postMap[mint] || 0;
                if (after - before > 0.000001 && solDelta < -0.001) {
                  alphaLog(`🔔 ${w.label} bought ${mint.slice(0, 6)}... (${Math.abs(solDelta).toFixed(3)} SOL)`);
                  await alphaEvaluateAndBuy(mint, w, Math.abs(solDelta));
                }
              }

              for (const mint of Object.keys(preMap)) {
                if (mint === SOL_MINT) continue;
                const before = preMap[mint] || 0;
                const after = postMap[mint] || 0;
                if (before - after > 0.000001 && solDelta > 0.001) {
                  alphaLog(`🔔 ${w.label} sold ${mint.slice(0, 6)}... (+${solDelta.toFixed(3)} SOL)`);
                  if (alphaPositions[mint]) {
                    alphaLog(`🚨 COPY-SELL triggered — ${w.label} is exiting ${alphaPositions[mint].symbol}!`, 'warn');
                    await alphaExecuteSell(mint);
                  }
                }
              }
            } catch (e) { /* skip */ }
          }

        } catch (e) {
          alphaLog(`Error polling ${w.label}: ${e.message}`, 'error');
        }
      }
    }

    // ── Evaluate & Execute ──
    let _fetchAbortSafe = true; // assume AbortController works; flip on first DataCloneError
    async function fetchWithTimeout(url, opts = {}, timeoutMs = 12000) {
      if (_fetchAbortSafe) {
        try {
          const controller = new AbortController();
          const timer = setTimeout(() => controller.abort(), timeoutMs);
          const res = await fetch(url, { ...opts, signal: controller.signal });
          clearTimeout(timer);
          return res;
        } catch (e) {
          if (e.name === 'DataCloneError' || e.message?.includes('could not be cloned')) {
            _fetchAbortSafe = false; // sandbox detected — never use AbortController again
          } else {
            if (e.name === 'AbortError') throw new Error('Request timed out');
            throw e;
          }
        }
      }
      // Fallback: plain fetch with timeout race (no AbortController)
      return Promise.race([
        fetch(url, opts),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out')), timeoutMs))
      ]);
    }

    async function alphaEvaluateAndBuy(mint, trackedWallet, theirSolAmount) {
      const maxDaily = parseInt($('alpha-max-daily').value) || 10;
      if (alphaDailyCount >= maxDaily) {
        alphaLog('Skipped — daily limit reached', 'warn');
        return;
      }

      // ── 1. DUPLICATE PROTECTION: Skip if we already hold or recently bought ──
      if (alphaPositions[mint]) {
        alphaLog(`Skipped — already holding ${mint.slice(0, 6)}...`);
        return;
      }
      if (alphaRecentBuys[mint] && Date.now() - alphaRecentBuys[mint] < 5 * 60 * 1000) {
        alphaLog(`Skipped ${mint.slice(0, 6)}... — bought recently (cooldown)`);
        return;
      }

      // Lock mint immediately to prevent race condition double-buys
      alphaRecentBuys[mint] = Date.now();

      // ── 2. GLOBAL COOLDOWN: Min 30s between buys ──
      const cooldownMs = 30 * 1000;
      if (Date.now() - alphaLastBuyTime < cooldownMs) {
        const remaining = Math.ceil((cooldownMs - (Date.now() - alphaLastBuyTime)) / 1000);
        alphaLog(`Skipped ${mint.slice(0, 6)}... — cooldown (${remaining}s left)`);
        return;
      }

      // ── 3. WALLET WEIGHTING: Low-performers need confirmation ──
      const walletStats = trackedWallet.stats;
      const winRate = walletStats?.winRate || 0;
      const walletPnl = parseFloat(walletStats?.pnl || '0');

      if (winRate < 40 || walletPnl < -10) {
        // Low-confidence wallet — require a second wallet to also signal this token
        if (!alphaPendingSignals[mint]) {
          alphaPendingSignals[mint] = { wallets: [trackedWallet.label], firstSeen: Date.now() };
          alphaLog(`⏳ ${trackedWallet.label} (${winRate}% win) bought ${mint.slice(0, 6)}... — waiting for confirmation...`);
          return;
        } else if (!alphaPendingSignals[mint].wallets.includes(trackedWallet.label)) {
          alphaPendingSignals[mint].wallets.push(trackedWallet.label);
          alphaLog(`✅ Confirmed by ${trackedWallet.label} — ${alphaPendingSignals[mint].wallets.length} wallets`);
          // Fall through to buy
        } else {
          return; // Same wallet, already pending
        }
      }

      // Clean up pending signal
      delete alphaPendingSignals[mint];

      // Clean up stale pending signals (older than 3 min)
      const now = Date.now();
      for (const m of Object.keys(alphaPendingSignals)) {
        if (now - alphaPendingSignals[m].firstSeen > 3 * 60 * 1000) {
          delete alphaPendingSignals[m];
        }
      }

      // Check token on DexScreener
      try {
        const dsRes = await fetchWithTimeout(`${DEXSCREENER_API}/tokens/${mint}`);
        const dsData = await dsRes.json();
        const pairs = (dsData.pairs || []).filter(p => p.chainId === getChain().dexScreenerChain);
        if (pairs.length > 0) {
          const best = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
          const liq = best.liquidity?.usd || 0;
          const symbol = best.baseToken?.symbol || mint.slice(0, 6);
          const dexId = (best.dexId || '').toLowerCase();
          const isGraduated = dexId.includes('raydium') || dexId.includes('orca') || dexId.includes('meteora') || dexId.includes('pumpswap') || dexId.includes('phoenix') || dexId.includes('lifinity') || liq > 5000;

          const confidence = winRate >= 70 ? '🟢' : winRate >= 40 ? '🟡' : '🔵';
          alphaLog(`${confidence} ${symbol} — liq: $${liq.toFixed(0)} on ${dexId} (via ${trackedWallet.label}). Buying...`);
          await alphaExecuteBuy(mint, symbol, trackedWallet.label, isGraduated);
        } else {
          alphaLog(`⚡ ${mint.slice(0, 6)}... — no DEX data, pump.fun buy (via ${trackedWallet.label})...`);
          await alphaExecuteBuy(mint, mint.slice(0, 6), trackedWallet.label, false);
        }
      } catch (e) {
        alphaLog(`Could not check ${mint.slice(0, 6)}... — ${e.message}`, 'warn');
      }
    }

    // Verify transaction actually succeeded (confirmTransaction only checks inclusion, not success)
    async function verifyTransaction(sig) {
      await delay(2000); // Give RPC time to index
      for (let i = 0; i < 5; i++) {
        try {
          const tx = await rpcGetTransaction(sig);
          if (tx) {
            if (tx.meta?.err) {
              const errStr = typeof tx.meta.err === 'object' ? JSON.stringify(tx.meta.err) : String(tx.meta.err);
              return { success: false, error: errStr };
            }
            return { success: true, tx };
          }
        } catch (e) { /* retry */ }
        await delay(2500);
      }
      // Can't find tx — do NOT assume success
      return { success: false, error: 'unverified', unverified: true };
    }

    // Jupiter multi-endpoint helpers
    let jupLastWorking = 0; // index of last working endpoint

    async function jupQuote(inputMint, outputMint, amount, slipBps = 1500) {
      // Try last working endpoint first, then cycle through all
      const order = [jupLastWorking, ...Array.from({length: JUP_ENDPOINTS.length}, (_, i) => i).filter(i => i !== jupLastWorking)];
      for (const idx of order) {
        const ep = JUP_ENDPOINTS[idx];
        try {
          const url = `${ep}/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${slipBps}`;
          const res = await fetchWithTimeout(url, {}, 8000);
          if (!res.ok) continue;
          const quote = await res.json();
          if (!quote.outAmount || quote.outAmount === '0') continue;
          jupLastWorking = idx;
          return { quote, endpoint: ep };
        } catch (e) { continue; }
      }
      return null;
    }

    async function jupSwap(endpoint, quote, userPublicKey, priorityFee = 100000) {
      const swapRes = await fetchWithTimeout(`${endpoint}/swap`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          quoteResponse: quote,
          userPublicKey,
          wrapAndUnwrapSol: true,
          dynamicComputeUnitLimit: true,
          prioritizationFeeLamports: priorityFee,
        }),
      }, 15000);
      if (!swapRes.ok) throw new Error(`Swap build ${swapRes.status}`);
      const swapData = await swapRes.json();
      if (!swapData.swapTransaction) throw new Error('No swap tx');
      return swapData;
    }

    async function alphaExecuteBuy(mint, symbol, copiedFrom = 'unknown', isGraduated = true) {
      const botWallet = getAlphaBotWallet();
      if (!botWallet) { alphaLog('No bot wallet — add one in Settings', 'error'); return; }

      const buyAmt = parseFloat($('alpha-buy-amt').value) || 0.01;
      const slippage = parseFloat($('alpha-slip').value) || 15;
      const lamports = Math.round(buyAmt * 1e9);
      const slipBps = Math.round(slippage * 100);

      let sig = null;
      let method = '';
      let jupErr = null;
      let pumpErr = null;

      // ── Always try Jupiter first (multiple endpoints) ──
      try {
        alphaLog(`🔄 Jupiter quote for ${symbol}...`, 'info');
        const jupResult = await jupQuote(SOL_MINT, mint, lamports, slipBps);
        if (!jupResult) throw new Error('All Jupiter endpoints failed');

        const swapData = await jupSwap(jupResult.endpoint, jupResult.quote, botWallet.publicKey);

        const txBuf = Uint8Array.from(atob(swapData.swapTransaction), c => c.charCodeAt(0));
        const tx = solanaWeb3.VersionedTransaction.deserialize(txBuf);
        const secretKey = bs58Decode(botWallet.secretKey);
        const keypair = solanaWeb3.Keypair.fromSecretKey(secretKey);
        tx.sign([keypair]);

        const rawTx = tx.serialize();
        if (mevEnabled) {
          try { sig = await sendViaJito(rawTx); }
          catch (e) { const conn = await getWorkingConnection(); sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 }); }
        } else {
          const conn = await getWorkingConnection();
          sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
        }
        method = 'Jupiter';
      } catch (e) {
        jupErr = e.message;
      }

      // ── If Jupiter failed, try PumpPortal (bonding curve tokens only) ──
      if (!sig) {
        if (isGraduated) {
          alphaLog(`❌ Jupiter failed: ${jupErr}. Token is graduated — PumpPortal won't work.`, 'error');
          return;
        }

        // Try PumpPortal with increasing slippage (50%, then 80% on retry)
        const slippageLevels = [Math.max(slippage, 50), 80];
        for (let attempt = 0; attempt < slippageLevels.length; attempt++) {
          const pumpSlip = slippageLevels[attempt];
          try {
            alphaLog(`${attempt === 0 ? '⚠' : '🔄'} ${attempt === 0 ? 'Jupiter: ' + jupErr + '. ' : ''}PumpPortal attempt ${attempt + 1} (${pumpSlip}% slip)...`, attempt === 0 ? 'warn' : 'info');
            const pumpRes = await fetchWithTimeout(`${PUMPPORTAL_API}/trade-local`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                publicKey: botWallet.publicKey,
                action: 'buy',
                mint: mint,
                amount: buyAmt,
                denominatedInSol: 'true',
                slippage: pumpSlip,
                priorityFee: 0.001,
              }),
            }, 15000);

            if (!pumpRes.ok) {
              const errText = await pumpRes.text().catch(() => '');
              throw new Error(`${pumpRes.status}: ${errText.slice(0, 60)}`);
            }

            const txData = await pumpRes.arrayBuffer();
            const tx = solanaWeb3.VersionedTransaction.deserialize(new Uint8Array(txData));
            const secretKey = bs58Decode(botWallet.secretKey);
            const keypair = solanaWeb3.Keypair.fromSecretKey(secretKey);
            tx.sign([keypair]);

            const rawTx = tx.serialize();
            const sendConn = await getWorkingConnection();
            const trySig = await sendConn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });

            // Quick verify before accepting
            await delay(3000);
            const verifyResult = await verifyTransaction(trySig);
            if (verifyResult.success) {
              sig = trySig;
              method = 'PumpPortal';
              break; // Success!
            } else if (verifyResult.error && verifyResult.error.includes('6005') && attempt < slippageLevels.length - 1) {
              alphaLog(`⚠ Slippage exceeded (6005) — retrying with ${slippageLevels[attempt + 1]}%...`, 'warn');
              await delay(1000);
              continue; // Try next slippage level
            } else {
              // Check balance as last resort
              try {
                await delay(2000);
                const conn2 = await getWorkingConnection();
                const pubkey = new solanaWeb3.PublicKey(botWallet.publicKey);
                const tokenAccounts = await conn2.getParsedTokenAccountsByOwner(pubkey, {
                  programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
                });
                const ta = tokenAccounts.value.find(t => t.account.data.parsed.info.mint === mint);
                const bal = ta ? (ta.account.data.parsed.info.tokenAmount.uiAmount || 0) : 0;
                if (bal > 0) {
                  sig = trySig;
                  method = 'PumpPortal';
                  break;
                }
              } catch (e) { /* balance check failed */ }

              if (attempt < slippageLevels.length - 1) continue;
              pumpErr = verifyResult.error || 'tx failed on-chain';
            }
          } catch (e) {
            pumpErr = e.message;
            if (attempt < slippageLevels.length - 1) continue;
          }
        }
      }

      if (!sig) {
        alphaLog(`❌ Buy failed for ${symbol}: Jupiter — ${jupErr} | PumpPortal — ${pumpErr}`, 'error');
        return;
      }

      // ── Confirm & Verify ──
      try {
        let confirmed = false;
        let balanceConfirmed = false;

        if (method === 'PumpPortal') {
          // PumpPortal already verified in retry loop
          confirmed = true;
          alphaLog(`✅ ${symbol} verified via ${method}`, 'info');
        } else {
          // Jupiter needs full verification
          alphaLog(`📡 Confirming ${symbol} via ${method}...`, 'info');
          const confirmConn = await getWorkingConnection();
          try { await confirmConn.confirmTransaction(sig, 'confirmed'); } catch (e) { /* continue to verify */ }

          const result = await verifyTransaction(sig);
          confirmed = result.success;

          if (!confirmed) {
            try {
              await delay(2000);
              const conn2 = await getWorkingConnection();
              const pubkey = new solanaWeb3.PublicKey(botWallet.publicKey);
              const tokenAccounts = await conn2.getParsedTokenAccountsByOwner(pubkey, {
                programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
              });
              const ta = tokenAccounts.value.find(t => t.account.data.parsed.info.mint === mint);
              const bal = ta ? (ta.account.data.parsed.info.tokenAmount.uiAmount || 0) : 0;
              if (bal > 0) {
                confirmed = true;
                balanceConfirmed = true;
                alphaLog(`✅ ${symbol} confirmed via balance check (${bal.toLocaleString()} tokens)`, 'info');
              }
            } catch (e) { /* balance check failed too */ }
          }

          if (!confirmed) {
            alphaLog(`❌ ${symbol} tx FAILED — ${result.error || 'no tokens received'} — tx: ${sig.slice(0, 8)}...`, 'error');
            return;
          }
        }

        alphaPositions[mint] = {
          symbol, entrySOL: buyAmt, amount: 0,
          entryTime: Date.now(), sig, copiedFrom,
        };

        // Fetch actual token balance after buy
        if (!balanceConfirmed) {
          try {
            await delay(3000);
            const conn = await getWorkingConnection();
            const pubkey = new solanaWeb3.PublicKey(botWallet.publicKey);
            const tokenAccounts = await conn.getParsedTokenAccountsByOwner(pubkey, {
              programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
            });
            const ta = tokenAccounts.value.find(t => t.account.data.parsed.info.mint === mint);
            if (ta) {
              alphaPositions[mint].amount = ta.account.data.parsed.info.tokenAmount.uiAmount || 0;
            }
          } catch (e) { /* will get updated on next position check */ }
        }

        alphaDailyCount++;
        alphaLastBuyTime = Date.now();       // Global cooldown
        alphaRecentBuys[mint] = Date.now();  // Duplicate protection

        const trade = {
          side: 'buy', symbol, mint, sol: buyAmt,
          sig, time: Date.now(), wallet: botWallet.label, copiedFrom,
        };
        alphaBotTrades.unshift(trade);
        tradeHistory.unshift({
          side: 'buy', symbol, mint,
          amountIn: buyAmt + ' SOL', amountOut: symbol,
          sig, time: Date.now(),
        });
        lsSetJSON('ghost-trades', tradeHistory);
        saveAlphaState();

        alphaLog(`🟢 BOUGHT ${symbol} — ${buyAmt} SOL via ${method}${balanceConfirmed ? ' (balance ✓)' : ''} — tx: ${sig.slice(0, 8)}...`, 'trade');

      } catch (confirmErr) {
        alphaLog(`⚠ ${symbol} sent but unconfirmed: ${sig?.slice(0, 8)}... — ${confirmErr.message}`, 'warn');
      }
    }

    async function alphaExecuteSell(mint) {
      const botWallet = getAlphaBotWallet();
      if (!botWallet) return;

      const pos = alphaPositions[mint];
      const symbol = pos?.symbol || mint.slice(0, 6);
      const slippage = parseFloat($('alpha-slip').value) || 15;

      try {
        // Get token balance
        const conn = await getWorkingConnection();
        const pubkey = new solanaWeb3.PublicKey(botWallet.publicKey);
        const tokenAccounts = await conn.getParsedTokenAccountsByOwner(pubkey, {
          programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
        });

        const tokenAccount = tokenAccounts.value.find(ta =>
          ta.account.data.parsed.info.mint === mint
        );
        if (!tokenAccount) { alphaLog('No balance to sell for ' + symbol, 'warn'); delete alphaPositions[mint]; saveAlphaState(); return; }

        const balance = tokenAccount.account.data.parsed.info.tokenAmount;
        const tokenLamports = parseInt(balance.amount);
        if (tokenLamports <= 0) { delete alphaPositions[mint]; saveAlphaState(); return; }

        let sig = null;
        let solReceived = 0;
        let method = '';

        // ── Attempt 1: Jupiter Sell (multi-endpoint) ──
        try {
          const jupResult = await jupQuote(mint, SOL_MINT, tokenLamports, Math.round(slippage * 100));
          if (!jupResult) throw new Error('All Jupiter endpoints failed');

          const swapData = await jupSwap(jupResult.endpoint, jupResult.quote, botWallet.publicKey);

          const txBuf = Uint8Array.from(atob(swapData.swapTransaction), c => c.charCodeAt(0));
          const tx = solanaWeb3.VersionedTransaction.deserialize(txBuf);
          const secretKey = bs58Decode(botWallet.secretKey);
          const keypair = solanaWeb3.Keypair.fromSecretKey(secretKey);
          tx.sign([keypair]);

          const rawTx = tx.serialize();
          if (mevEnabled) {
            try { sig = await sendViaJito(rawTx); }
            catch (e) { sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 }); }
          } else {
            sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
          }
          solReceived = parseInt(jupResult.quote.outAmount) / 1e9;
          method = 'Jupiter';

        } catch (jupErr) {
          // ── Attempt 2: PumpPortal Sell ──
          alphaLog(`⚠ Jupiter sell failed: ${jupErr.message}. Trying PumpPortal...`, 'warn');
          try {
            const pumpRes = await fetchWithTimeout(`${PUMPPORTAL_API}/trade-local`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                publicKey: botWallet.publicKey,
                action: 'sell',
                mint: mint,
                amount: tokenLamports.toString(),
                denominatedInSol: 'false',
                slippage: Math.max(slippage, 50), // High slippage for guaranteed exit
                priorityFee: 0.0001,
              }),
            }, 15000);

            if (!pumpRes.ok) throw new Error(`PumpPortal ${pumpRes.status}`);

            const txData = await pumpRes.arrayBuffer();
            const tx = solanaWeb3.VersionedTransaction.deserialize(new Uint8Array(txData));
            const secretKey = bs58Decode(botWallet.secretKey);
            const keypair = solanaWeb3.Keypair.fromSecretKey(secretKey);
            tx.sign([keypair]);

            const rawTx = tx.serialize();
            sig = await conn.sendRawTransaction(rawTx, { skipPreflight: true, maxRetries: 3 });
            solReceived = pos?.entrySOL || 0; // estimate, will be updated
            method = 'PumpPortal';

          } catch (pumpErr) {
            throw new Error(`Jupiter: ${jupErr.message} | PumpPortal: ${pumpErr.message}`);
          }
        }

        try { await conn.confirmTransaction(sig, 'confirmed'); } catch (e) { /* continue to verify */ }

        // CRITICAL: Verify tx actually succeeded on-chain
        const result = await verifyTransaction(sig);
        let sellConfirmed = result.success;

        // Fallback: check if tokens are gone from wallet
        if (!sellConfirmed && result.unverified) {
          try {
            await delay(2000);
            const conn2 = await getWorkingConnection();
            const pubkey2 = new solanaWeb3.PublicKey(botWallet.publicKey);
            const ta2 = await conn2.getParsedTokenAccountsByOwner(pubkey2, {
              programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
            });
            const found = ta2.value.find(t => t.account.data.parsed.info.mint === mint);
            const remaining = found ? (found.account.data.parsed.info.tokenAmount.uiAmount || 0) : 0;
            if (remaining === 0 || remaining < (balance.uiAmount * 0.01)) {
              sellConfirmed = true;
              alphaLog(`✅ ${symbol} sell confirmed via balance check (tokens gone)`, 'info');
            }
          } catch (e) { /* balance check failed */ }
        }

        if (!sellConfirmed) {
          alphaLog(`❌ Sell for ${symbol} tx FAILED: ${result.error} — tx: ${sig.slice(0, 8)}...`, 'error');
          return; // Position remains open
        }

        const pnl = pos ? (solReceived - pos.entrySOL) : 0;
        const pnlPct = pos ? ((pnl / pos.entrySOL) * 100).toFixed(1) : '?';

        delete alphaPositions[mint];

        const trade = {
          side: 'sell', symbol, mint, sol: solReceived,
          pnl: pnl.toFixed(4), pnlPct, sig, time: Date.now(),
          copiedFrom: pos?.copiedFrom || 'unknown',
        };
        alphaBotTrades.unshift(trade);
        tradeHistory.unshift({
          side: 'sell', symbol, mint,
          amountIn: formatNum(balance.uiAmount) + ' ' + symbol,
          amountOut: solReceived.toFixed(4) + ' SOL',
          sig, time: Date.now(),
        });
        lsSetJSON('ghost-trades', tradeHistory);

        alphaClosedCount++;
        saveAlphaState();

        const pnlStr = pnl >= 0 ? `+${pnl.toFixed(4)} SOL (+${pnlPct}%)` : `${pnl.toFixed(4)} SOL (${pnlPct}%)`;
        alphaLog(`🔴 SOLD ${symbol} via ${method} — ${solReceived.toFixed(4)} SOL — PnL: ${pnlStr} — tx: ${sig.slice(0, 8)}...`, 'trade');

        // Check if auto-learn should trigger
        const learnEvery = 5;
        if (alphaClosedCount >= learnEvery && alphaBotRunning) {
          alphaClosedCount = 0;
          saveAlphaState();
          alphaAutoLearn();
        }

      } catch (e) {
        alphaLog(`❌ Sell failed for ${symbol}: ${e.message}`, 'error');
      }
    }

    // ── Parse TP/SL from AI Strategy Profile ──
    function getStrategyExitRules() {
      const text = (alphaStrategy || '').toLowerCase();
      let sl = 30, tp = 100; // sensible defaults

      // Parse SL — look for patterns like "SL:25", "stop-loss: 25%", "stop loss 20%", "sl 15"
      const slMatch = text.match(/(?:stop[- ]?loss|sl)\s*[:=]?\s*(\d{1,3})\s*%?/);
      if (slMatch) sl = parseInt(slMatch[1]);

      // Parse TP — look for patterns like "TP:80", "take-profit: 50%", "take profit 60%", "tp 40"
      const tpMatch = text.match(/(?:take[- ]?profit|tp)\s*[:=]?\s*(\d{1,3})\s*%?/);
      if (tpMatch) tp = parseInt(tpMatch[1]);

      // Sanity clamp
      sl = Math.max(5, Math.min(sl, 80));
      tp = Math.max(10, Math.min(tp, 500));

      return { sl, tp };
    }

    // ── Position Monitoring (Stop-Loss / Take-Profit) ──
    async function alphaCheckPositions() {
      if (!alphaBotRunning) return;
      const { sl, tp } = getStrategyExitRules();
      const botWallet = getAlphaBotWallet();

      const mints = Object.keys(alphaPositions);
      if (mints.length === 0) { setTimeout(() => alphaCheckPositions(), 15000); return; }

      for (const mint of mints) {
        const pos = alphaPositions[mint];
        if (!pos) continue;

        try {
          // Step 1: If we don't know the token amount yet, fetch from chain
          if (!pos.amount || pos.amount <= 0) {
            if (botWallet) {
              const conn = await getWorkingConnection();
              const pubkey = new solanaWeb3.PublicKey(botWallet.publicKey);
              const tokenAccounts = await conn.getParsedTokenAccountsByOwner(pubkey, {
                programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
              });
              const ta = tokenAccounts.value.find(t => t.account.data.parsed.info.mint === mint);
              if (ta) {
                pos.amount = ta.account.data.parsed.info.tokenAmount.uiAmount || 0;
                saveAlphaState();
              }
            }
            if (!pos.amount || pos.amount <= 0) continue; // Still no balance
          }

          // Step 2: Get current value in SOL via DexScreener priceNative
          let currentValueSOL = 0;
          try {
            const dsRes = await fetchWithTimeout(`${DEXSCREENER_API}/tokens/${mint}`, {}, 8000);
            const dsData = await dsRes.json();
            const pairs = (dsData.pairs || []).filter(p => p.chainId === getChain().dexScreenerChain);
            if (pairs.length > 0) {
              const best = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
              const priceNative = parseFloat(best.priceNative) || 0; // Price per token in SOL
              currentValueSOL = priceNative * pos.amount;
            }
          } catch (e) { /* DexScreener failed */ }

          // Step 3: Fallback — use Jupiter sell quote to get SOL value
          if (currentValueSOL <= 0) {
            try {
              const tokenDecimals = await getTokenDecimals(mint);
              const tokenLamports = Math.round(pos.amount * Math.pow(10, tokenDecimals));
              const jupResult = await jupQuote(mint, SOL_MINT, tokenLamports, 1500);
              if (jupResult) {
                currentValueSOL = parseInt(jupResult.quote.outAmount || '0') / 1e9;
              }
            } catch (e) { /* Jupiter also failed */ }
          }

          if (currentValueSOL <= 0) {
            // Can't determine value — track failures and dump if dead
            pos.priceFailCount = (pos.priceFailCount || 0) + 1;
            const ageMin = (Date.now() - pos.entryTime) / 60000;

            // After 3 failed price checks (~90 seconds) OR position older than 10 min with no price: emergency dump
            if (pos.priceFailCount >= 3 || ageMin >= 10) {
              alphaLog(`☠️ ${pos.symbol} — no price data after ${pos.priceFailCount} checks (${ageMin.toFixed(0)}min old) — emergency dump`, 'warn');
              await alphaExecuteSell(mint);
            } else {
              alphaLog(`⚠ ${pos.symbol} — can't get price (attempt ${pos.priceFailCount}/3)`, 'info');
            }
            continue;
          }

          // Reset fail counter on successful price fetch
          pos.priceFailCount = 0;

          // Step 4: Calculate PnL and check exit rules
          const pnlSOL = currentValueSOL - pos.entrySOL;
          const pnlPct = (pnlSOL / pos.entrySOL) * 100;

          if (pnlPct <= -sl) {
            alphaLog(`🛑 Stop-loss for ${pos.symbol}: ${pnlPct.toFixed(1)}% (${pnlSOL.toFixed(4)} SOL)`, 'warn');
            await alphaExecuteSell(mint);
          } else if (pnlPct >= tp) {
            alphaLog(`🎯 Take-profit for ${pos.symbol}: +${pnlPct.toFixed(1)}% (+${pnlSOL.toFixed(4)} SOL)`, 'trade');
            await alphaExecuteSell(mint);
          } else {
            // ── 4. TIME-BASED EXIT: Dump stale positions ──
            const ageMin = (Date.now() - pos.entryTime) / 60000;

            // After 5min: exit if losing
            if (ageMin >= 5 && pnlPct < 0) {
              alphaLog(`⏰ Time exit for ${pos.symbol}: ${ageMin.toFixed(0)}min old, ${pnlPct.toFixed(1)}% — cutting loss early`, 'warn');
              await alphaExecuteSell(mint);
            }
            // After 10min: exit if barely positive or flat
            else if (ageMin >= 10 && pnlPct < 20) {
              alphaLog(`⏰ Time exit for ${pos.symbol}: ${ageMin.toFixed(0)}min old, ${pnlPct.toFixed(1)}% — not running, exiting`, 'warn');
              await alphaExecuteSell(mint);
            }
            // After 20min: exit anything under +50%
            else if (ageMin >= 20 && pnlPct < 50) {
              alphaLog(`⏰ Time exit for ${pos.symbol}: ${ageMin.toFixed(0)}min old, +${pnlPct.toFixed(1)}% — taking what we have`, 'warn');
              await alphaExecuteSell(mint);
            }
          }

          await delay(500); // Rate limit between position checks
        } catch (e) { /* skip this position */ }
      }

      // Schedule next check — every 15 seconds for fast memecoin exits
      if (alphaBotRunning) setTimeout(() => alphaCheckPositions(), 15000);
    }

    // ── Auto-Learn — Bot Studies Its Own Performance ──
    async function alphaAutoLearn() {
      if (!apiKey) return;
      alphaLog('🧠 Auto-learning — analyzing bot performance...', 'info');
      setAlphaStatus('studying', 'Self-learning...');

      try {
        // Build bot's own performance data grouped by copied wallet
        const sellTrades = alphaBotTrades.filter(t => t.side === 'sell' && t.copiedFrom);
        const walletPerf = {};

        for (const t of sellTrades) {
          const from = t.copiedFrom || 'unknown';
          if (!walletPerf[from]) walletPerf[from] = { wins: 0, losses: 0, totalPnl: 0, trades: [] };
          const pnl = parseFloat(t.pnl) || 0;
          if (pnl > 0) walletPerf[from].wins++;
          else walletPerf[from].losses++;
          walletPerf[from].totalPnl += pnl;
          walletPerf[from].trades.push({
            symbol: t.symbol, pnl: t.pnl, pnlPct: t.pnlPct || '?',
            time: new Date(t.time).toISOString(),
          });
        }

        // Build tracked wallet current stats
        const walletStats = alphaWallets.map(w => ({
          label: w.label,
          address: w.address.slice(0, 8) + '...',
          stats: w.stats || {},
        }));

        // Current config
        const { sl: currentSL, tp: currentTP } = getStrategyExitRules();
        const currentConfig = {
          buyAmount: parseFloat($('alpha-buy-amt').value) || 0.01,
          slippage: parseFloat($('alpha-slip').value) || 15,
          derivedSL: currentSL,
          derivedTP: currentTP,
        };

        // Total bot stats
        const totalWins = sellTrades.filter(t => parseFloat(t.pnl) > 0).length;
        const totalLosses = sellTrades.filter(t => parseFloat(t.pnl) <= 0).length;
        const totalPnl = sellTrades.reduce((s, t) => s + (parseFloat(t.pnl) || 0), 0);

        const learnPrompt = `You are the brain of an autonomous copy-trading bot on Solana. You need to analyze the bot's OWN trading performance and adjust the strategy.

TRACKED WALLETS (smart money being copied):
${JSON.stringify(walletStats, null, 2)}

BOT'S OWN PERFORMANCE BY COPIED WALLET:
${JSON.stringify(walletPerf, null, 2)}

BOT TOTALS: ${totalWins} wins, ${totalLosses} losses, Total PnL: ${totalPnl.toFixed(4)} SOL

CURRENT CONFIG: ${JSON.stringify(currentConfig)}

PREVIOUS STRATEGY:
${alphaStrategy}

Based on the bot's ACTUAL results from copying these wallets, update the strategy:

1. PERFORMANCE REVIEW: How is the bot doing? Which copied wallets are profitable vs losing money?
2. WALLET ADJUSTMENTS: Which wallets should be prioritized, deprioritized, or ignored? Be specific.
3. EXIT RULES: Based on actual trade results, what SL and TP percentages work best? Analyze the PnL of closed trades to determine optimal exit points.
4. PATTERNS: Any patterns in wins vs losses? (token types, timing, sizes)
5. UPDATED RULES: New entry/exit rules based on what actually works
6. CONFIDENCE SCORE: 0-100 updated confidence

CRITICAL: You MUST include these exact lines somewhere in your response so the bot can parse them:
SL:XX (stop-loss percentage, e.g. SL:25)
TP:XX (take-profit percentage, e.g. TP:80)
Derive these from actual wallet behavior and bot results — not arbitrary numbers.

Be brutally honest. If a wallet is losing money, say so. Use numbers. Plain text, no markdown.`;

        const res = await fetch(CLAUDE_API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true',
          },
          body: JSON.stringify({
            model: currentModel,
            max_tokens: 1500,
            messages: [{ role: 'user', content: learnPrompt }],
          }),
        });

        if (!res.ok) throw new Error('Claude API error: ' + res.status);
        const data = await res.json();
        const newStrategy = data.content?.[0]?.text || alphaStrategy;

        alphaStrategy = newStrategy;
        $('alpha-strategy').textContent = newStrategy;
        saveAlphaState();

        alphaLog(`🧠 Self-learned from ${sellTrades.length} closed trades — strategy updated`, 'trade');
        setAlphaStatus('live', `Running — learned from ${sellTrades.length} trades`);
        toast('🧠 Bot updated its own strategy!');

      } catch (e) {
        alphaLog('Auto-learn error: ' + e.message, 'error');
        setAlphaStatus('live', 'Running — auto-learn failed');
      }
    }

    // ══════════════════════════════════════════════════
    // ══  SCOUT MODE — Autonomous Market Scanner     ══
    // ══════════════════════════════════════════════════

    function alphaToggleScout() {
      if (!alphaBotRunning) { toast('Start the bot first'); return; }
      if (!apiKey) { toast('API key required for Scout Mode (AI evaluation)'); return; }

      alphaScoutEnabled = !alphaScoutEnabled;
      const btn = $('alpha-scout-btn');

      if (alphaScoutEnabled) {
        btn.textContent = '🔍 Scout Mode: ON';
        btn.style.background = 'linear-gradient(135deg,#1a3a2a,#0d3720)';
        btn.style.borderColor = '#2a8a5a';
        alphaLog('🔍 Scout Mode ON — scanning market every 35s for autonomous picks', 'trade');
        alphaScoutSeen = new Set(Object.keys(alphaPositions)); // Don't re-evaluate held tokens
        // Add recent buys to seen set
        for (const m of Object.keys(alphaRecentBuys)) alphaScoutSeen.add(m);
        alphaScoutTimer = setInterval(() => alphaScoutScan(), 35000);
        alphaScoutScan(); // First scan immediately
      } else {
        btn.textContent = '🔍 Scout Mode: OFF';
        btn.style.background = 'linear-gradient(135deg,#1a1a3e,#0d2137)';
        btn.style.borderColor = '#2a4a6a';
        if (alphaScoutTimer) { clearInterval(alphaScoutTimer); alphaScoutTimer = null; }
        alphaLog('🔍 Scout Mode OFF');
      }
    }

    async function alphaScoutScan() {
      if (!alphaScoutEnabled || !alphaBotRunning) return;
      if (alphaScoutBuying) return; // AI eval in progress

      const maxDaily = parseInt($('alpha-max-daily').value) || 10;
      if (alphaDailyCount >= maxDaily) return;

      try {
        // ── Step 1: Fetch candidates from multiple sources ──
        const candidates = [];

        // Source A: DexScreener latest token profiles (new tokens with socials)
        try {
          const profRes = await fetchWithTimeout('https://api.dexscreener.com/token-profiles/latest/v1', {}, 8000);
          if (profRes.ok) {
            const profiles = await profRes.json();
            const solProfiles = (profiles || []).filter(p => p.chainId === 'solana').slice(0, 15);
            for (const p of solProfiles) {
              if (!alphaScoutSeen.has(p.tokenAddress) && !alphaPositions[p.tokenAddress] && !alphaRecentBuys[p.tokenAddress]) {
                candidates.push({ mint: p.tokenAddress, source: 'dex-profile', description: p.description || '', links: p.links || [] });
              }
            }
          }
        } catch (e) { /* DexScreener profiles failed */ }

        // Source B: DexScreener boosted tokens (community signal)
        try {
          const boostRes = await fetchWithTimeout('https://api.dexscreener.com/token-boosts/latest/v1', {}, 8000);
          if (boostRes.ok) {
            const boosts = await boostRes.json();
            const solBoosts = (boosts || []).filter(b => b.chainId === 'solana').slice(0, 10);
            for (const b of solBoosts) {
              if (!alphaScoutSeen.has(b.tokenAddress) && !alphaPositions[b.tokenAddress] && !alphaRecentBuys[b.tokenAddress]) {
                if (!candidates.find(c => c.mint === b.tokenAddress)) {
                  candidates.push({ mint: b.tokenAddress, source: 'dex-boost', totalAmount: b.totalAmount || 0 });
                }
              }
            }
          }
        } catch (e) { /* DexScreener boosts failed */ }

        // Source C: Pump.fun currently live (try without auth)
        try {
          const pumpRes = await fetchWithTimeout('https://frontend-api-v3.pump.fun/coins/currently-live?offset=0&limit=20&includeNsfw=false&order=DESC', {
            headers: { 'Accept': 'application/json' },
          }, 8000);
          if (pumpRes.ok) {
            const pumpTokens = await pumpRes.json();
            for (const t of (pumpTokens || []).slice(0, 15)) {
              if (t.mint && !alphaScoutSeen.has(t.mint) && !alphaPositions[t.mint] && !alphaRecentBuys[t.mint]) {
                if (!candidates.find(c => c.mint === t.mint)) {
                  candidates.push({
                    mint: t.mint, source: 'pump-live', symbol: t.symbol, name: t.name,
                    mcap: t.market_cap || 0, complete: t.complete || false,
                  });
                }
              }
            }
          }
        } catch (e) { /* Pump.fun needs auth — that's fine */ }

        if (candidates.length === 0) return; // Nothing new

        // ── Step 2: Get DexScreener pair data for all candidates ──
        const mintList = candidates.map(c => c.mint).slice(0, 20); // Max 20
        const enriched = [];

        // Batch in groups of 10 (DexScreener allows comma-separated, up to 30)
        for (let i = 0; i < mintList.length; i += 10) {
          const batch = mintList.slice(i, i + 10);
          try {
            const dsRes = await fetchWithTimeout(`${DEXSCREENER_API}/tokens/${batch.join(',')}`, {}, 10000);
            if (dsRes.ok) {
              const dsData = await dsRes.json();
              const pairs = dsData.pairs || dsData || [];
              for (const pair of pairs) {
                if (pair.chainId !== 'solana') continue;
                const mint = pair.baseToken?.address;
                if (!mint) continue;

                const cand = candidates.find(c => c.mint === mint);
                if (!cand) continue;

                const age = pair.pairCreatedAt ? (Date.now() - pair.pairCreatedAt) / 60000 : 9999;
                const liq = pair.liquidity?.usd || 0;
                const mcap = pair.marketCap || pair.fdv || 0;
                const vol24h = pair.volume?.h24 || 0;
                const vol1h = pair.volume?.h1 || 0;
                const txns24h = (pair.txns?.h24?.buys || 0) + (pair.txns?.h24?.sells || 0);
                const txns1h = (pair.txns?.h1?.buys || 0) + (pair.txns?.h1?.sells || 0);
                const buys1h = pair.txns?.h1?.buys || 0;
                const sells1h = pair.txns?.h1?.sells || 0;
                const priceChange5m = pair.priceChange?.m5 || 0;
                const priceChange1h = pair.priceChange?.h1 || 0;

                // Hard filters — skip obvious garbage
                if (age > 120) continue;          // Older than 2 hours
                if (liq < 500) continue;           // Less than $500 liq
                if (txns1h < 5) continue;          // Dead token
                if (mcap > 5000000) continue;      // Already too big

                enriched.push({
                  mint, symbol: pair.baseToken?.symbol || cand.symbol || mint.slice(0, 6),
                  name: pair.baseToken?.name || cand.name || '',
                  source: cand.source,
                  ageMin: Math.round(age),
                  liq: Math.round(liq),
                  mcap: Math.round(mcap),
                  vol1h: Math.round(vol1h),
                  vol24h: Math.round(vol24h),
                  txns1h, txns24h,
                  buyRatio1h: buys1h + sells1h > 0 ? Math.round((buys1h / (buys1h + sells1h)) * 100) : 50,
                  priceChange5m: Math.round(priceChange5m * 10) / 10,
                  priceChange1h: Math.round(priceChange1h * 10) / 10,
                  dexId: pair.dexId || 'unknown',
                  description: cand.description || '',
                  hasSocials: (cand.links?.length > 0) || false,
                });
              }
            }
          } catch (e) { /* batch failed */ }
          await delay(300);
        }

        // Mark all as seen regardless of enrichment
        for (const c of candidates) alphaScoutSeen.add(c.mint);

        // Prune seen set if too large (keep last 500)
        if (alphaScoutSeen.size > 500) {
          const arr = [...alphaScoutSeen];
          alphaScoutSeen = new Set(arr.slice(arr.length - 300));
        }

        if (enriched.length === 0) return;

        alphaLog(`🔍 Scout found ${enriched.length} candidates — sending to AI...`);

        // ── Step 3: AI Evaluation ──
        await alphaScoutEvaluate(enriched);

      } catch (e) {
        alphaLog(`Scout scan error: ${e.message}`, 'error');
      }
    }

    async function alphaScoutEvaluate(candidates) {
      if (alphaScoutBuying || !apiKey) return;
      alphaScoutBuying = true;

      try {
        const maxDaily = parseInt($('alpha-max-daily').value) || 10;
        const remaining = maxDaily - alphaDailyCount;
        if (remaining <= 0) { alphaScoutBuying = false; return; }

        // Build a concise candidate table for Claude
        const table = candidates.slice(0, 8).map((c, i) => (
          `${i + 1}. ${c.symbol} (${c.mint.slice(0, 8)}...) — mcap:$${c.mcap} liq:$${c.liq} age:${c.ageMin}min vol1h:$${c.vol1h} txns1h:${c.txns1h} buyRatio:${c.buyRatio1h}% 5m:${c.priceChange5m}% 1h:${c.priceChange1h}% dex:${c.dexId} src:${c.source}${c.hasSocials ? ' ✓socials' : ''}${c.description ? ' desc:' + c.description.slice(0, 60) : ''}`
        )).join('\n');

        const evalPrompt = `You are an autonomous memecoin scout on Solana. Your job: find the BEST token to buy RIGHT NOW from this list.

STRATEGY PROFILE (learned from tracked smart wallets):
${alphaStrategy || 'No strategy yet — use general memecoin best practices.'}

CURRENT CANDIDATES:
${table}

RULES:
- You have ${remaining} trades left today at ${parseFloat($('alpha-buy-amt').value) || 0.01} SOL each
- Look for: strong buy pressure (high buyRatio), fresh tokens (under 30min ideal), growing volume, reasonable liquidity
- Avoid: tokens dumping (negative 5m/1h change with high sells), extremely low liquidity (<$1K), tokens with no activity
- Cross-reference with the strategy profile patterns from tracked wallets
- The BEST picks typically have: rising buy ratio, accelerating volume, fresh age, healthy liquidity for size

RESPOND WITH EXACTLY ONE OF:
A) BUY:X (where X is the candidate number 1-${Math.min(candidates.length, 8)}) followed by a one-line reason
B) PASS (if nothing looks good enough)

Examples:
BUY:3 Strong buy pressure 78%, fresh at 8min, volume accelerating
PASS No candidates show strong enough momentum

Your response (one line only):`;

        const res = await fetch(CLAUDE_API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true',
          },
          body: JSON.stringify({
            model: currentModel,
            max_tokens: 150,
            messages: [{ role: 'user', content: evalPrompt }],
          }),
        });

        if (!res.ok) throw new Error('Claude API ' + res.status);
        const data = await res.json();
        const answer = (data.content?.[0]?.text || 'PASS').trim();

        // Parse response
        const buyMatch = answer.match(/BUY:(\d+)/i);
        if (buyMatch) {
          const idx = parseInt(buyMatch[1]) - 1;
          if (idx >= 0 && idx < candidates.length) {
            const pick = candidates[idx];
            const reason = answer.replace(/BUY:\d+/i, '').trim();
            alphaLog(`🤖 AI picked ${pick.symbol}: ${reason}`, 'trade');

            // Check cooldown + duplicate before buying
            const cooldownMs = 30 * 1000;
            if (Date.now() - alphaLastBuyTime < cooldownMs) {
              alphaLog(`⏳ Cooldown active — skipping ${pick.symbol}`);
            } else if (alphaPositions[pick.mint] || alphaRecentBuys[pick.mint]) {
              alphaLog(`⏭ Already holding/bought ${pick.symbol}`);
            } else {
              // Execute the buy
              const isGraduated = pick.dexId.includes('raydium') || pick.dexId.includes('orca') ||
                pick.dexId.includes('meteora') || pick.dexId.includes('pumpswap') || pick.liq > 5000;
              await alphaExecuteBuy(pick.mint, pick.symbol, 'Scout AI', isGraduated);
            }
          }
        } else {
          alphaLog(`🔍 Scout: AI passed — ${answer.slice(0, 80)}`);
        }

      } catch (e) {
        alphaLog(`Scout AI error: ${e.message}`, 'error');
      }

      alphaScoutBuying = false;
    }
    const LOCAL_COMMANDS = [
      { patterns: [/^open\s+trade/i, /^trade$/i, /^trading$/i, /^swap$/i], action: () => { setMode('trade'); return '⟡ Opened trade panel.'; } },
      { patterns: [/^open\s+launch/i, /^launch$/i, /^launcher$/i], action: () => { setMode('launch'); return '🚀 Opened token launcher.'; } },
      { patterns: [/^open\s+wallet/i, /^wallet$/i], action: () => { setMode('wallet'); return '◎ Opened wallet panel.'; } },
      { patterns: [/^open\s+tools/i, /^tools$/i, /^plugins$/i], action: () => { setMode('tools'); return '◈ Opened tools panel.'; } },
      { patterns: [/^open\s+sniper/i, /^sniper$/i], action: () => { setMode('sniper'); return '⚡ Opened sniper bot.'; } },
      { patterns: [/^open\s+history/i, /^history$/i], action: () => { setMode('history'); return '☰ Opened history.'; } },
      { patterns: [/^open\s+intel/i, /^intel$/i], action: () => { setMode('intel'); return '⬡ Opened token intel.'; } },
      { patterns: [/^open\s+portfolio/i, /^portfolio$/i, /^folio$/i], action: () => { setMode('portfolio'); return '◐ Opened portfolio.'; } },
      { patterns: [/^open\s+pnl/i, /^pnl$/i], action: () => { setMode('history'); setTimeout(() => setHistTab('pnl'), 50); return '📊 Opened PnL analytics.'; } },
      { patterns: [/^open\s+alpha/i, /^alpha$/i, /^alpha\s*bot$/i, /^bot$/i, /^copy\s*trade$/i], action: () => { setMode('alpha'); return '🧠 Opened Alpha Bot.'; } },
      { patterns: [/^open\s+watchlist/i, /^watchlist$/i, /^watch$/i], action: () => { setMode('watchlist'); return '⭐ Opened watchlist.'; } },
      { patterns: [/^open\s+perps/i, /^perps$/i, /^leverage$/i, /^lev$/i, /^futures$/i], action: () => { setMode('perps'); return '⚡ Opened leverage terminal.'; } },
      { patterns: [/^open\s+bundle/i, /^bundle$/i, /^bundle\s+check$/i, /^bundlecheck$/i, /^check\s+bundle$/i], action: () => { setMode('bundle'); return '🔍 Opened bundle checker.'; } },
      { patterns: [/^bundle\s+([1-9A-HJ-NP-Za-km-z]{32,44})$/i], action: (m) => { setMode('bundle'); setTimeout(() => { $('bundle-mint').value = m[1]; runBundleCheck(); }, 100); return '🔍 Scanning for bundle...'; } },

      { patterns: [/^start\s+alpha/i, /^start\s+bot$/i], action: () => { setMode('alpha'); setTimeout(startAlphaBot, 100); return '🧠 Starting Alpha Bot...'; } },
      { patterns: [/^stop\s+alpha/i, /^stop\s+bot$/i], action: () => { stopAlphaBot(); return '🧠 Alpha Bot stopped.'; } },
      { patterns: [/^study\s+wallets$/i, /^study$/i], action: () => { setMode('alpha'); setTimeout(alphaStudy, 100); return '📚 Studying tracked wallets...'; } },
      { patterns: [/^learn$/i, /^auto\s*learn$/i, /^self\s*study$/i], action: () => { setMode('alpha'); setTimeout(alphaAutoLearn, 100); return '🧠 Running self-analysis...'; } },
      { patterns: [/^scout\s+on$/i, /^enable\s+scout$/i, /^start\s+scout$/i], action: () => { setMode('alpha'); if (!alphaScoutEnabled) setTimeout(alphaToggleScout, 100); return '🔍 Scout Mode enabled.'; } },
      { patterns: [/^scout\s+off$/i, /^disable\s+scout$/i, /^stop\s+scout$/i], action: () => { if (alphaScoutEnabled) alphaToggleScout(); return '🔍 Scout Mode disabled.'; } },
      { patterns: [/^new\s+chat$/i, /^clear\s+chat$/i, /^reset$/i], action: () => { setTimeout(newChat, 100); return '✦ Starting new chat...'; } },
      { patterns: [/^connect\s+wallet$/i, /^connect$/i], action: () => { connectWallet(); return '👻 Connecting Phantom...'; } },
      { patterns: [/^disconnect\s+wallet$/i, /^disconnect$/i], action: () => { disconnectWallet(); return '👻 Disconnecting...'; } },
      { patterns: [/^sniper\s+on$/i, /^enable\s+sniper$/i], action: () => { if (!sniperEnabled) toggleSniper(); return '⚡ Sniper enabled.'; } },
      { patterns: [/^sniper\s+off$/i, /^disable\s+sniper$/i], action: () => { if (sniperEnabled) toggleSniper(); return '⚡ Sniper disabled.'; } },
      { patterns: [/^web\s+search\s+on$/i, /^search\s+on$/i], action: () => { if (!webSearchEnabled) toggleWebSearch(); return '🔍 Web search enabled.'; } },
      { patterns: [/^web\s+search\s+off$/i, /^search\s+off$/i], action: () => { if (webSearchEnabled) toggleWebSearch(); return '🔍 Web search disabled.'; } },
      { patterns: [/^dark\s+mode$/i, /^dark$/i], action: () => { if (document.documentElement.getAttribute('data-theme') !== 'dark') toggleTheme(); return '🌙 Dark mode.'; } },
      { patterns: [/^light\s+mode$/i, /^light$/i], action: () => { if (document.documentElement.getAttribute('data-theme') !== 'light') toggleTheme(); return '☀️ Light mode.'; } },
      { patterns: [/^help$/i, /^commands$/i], action: () => {
        return `⚡ **Agent Commands:**\n\nopen trade / launch / wallet / tools / sniper / history / intel / portfolio / pnl / alpha / watchlist / perps / bundle\nnew chat · connect wallet · disconnect wallet\nsniper on / off · web search on / off\ndark mode / light mode\n\n⟡ **Trading:**\nbuy [amount] [mint] · sell [mint]\nset slippage [%] · set priority [SOL]\n🛡️ MEV Protection via Jito (toggle in trade panel)\n🎯 Auto SL/TP — set stop-loss & take-profit in trade panel\n📊 Partial sells — 25% / 50% / 75% / 100% sell buttons\n📥 CSV export — download trade history\n\n⚡ **Leverage:**\nperps / leverage / futures — open leverage terminal\nSOL, BTC, ETH up to 250x via Jupiter Perps\n\n🔍 **Quick Lookup:**\nPaste any contract address — instant token card\n/p [ticker] or price [ticker] — price check\nscan [mint] — full token intel\nbundle [mint] — check for bundled launch\nwatchlist — your saved tokens\n\n🧠 **Alpha Bot:**\nalpha / bot / copytrade — open Alpha Bot\nstudy — analyze tracked wallets\nlearn — bot studies its own trades\nstart bot / stop bot — toggle auto-trading\n\n⌨️ **Keyboard Shortcuts:**\nCtrl+T — Trade · Ctrl+L — Launch · Ctrl+P — Perps\nCtrl+B — Alpha Bot · Ctrl+K — Focus chat · Esc — Back\n\nOr just describe what you want — Ghost will figure it out.`;
      }},
    ];

    // Trade commands that need parameter parsing
    function tryTradeCommand(text) {
      // Auto-detect bare Solana contract address → show token card
      if (/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(text.trim()) && text.trim() !== SOL_MINT) {
        const mint = text.trim();
        setTimeout(() => quickTokenCard(mint), 50);
        return `🔍 Scanning ${mint.slice(0, 6)}...${mint.slice(-4)}`;
      }

      // Quick price: "/p SOL" or "price WIF" or "/price SOL"
      const priceMatch = text.match(/^(?:\/p(?:rice)?|price)\s+(.+)/i);
      if (priceMatch) {
        const ticker = priceMatch[1].trim();
        quickPriceLookup(ticker);
        return '🔍 Looking up ' + ticker + '...';
      }

      // Scan token: "scan [mint/ticker]"
      const scanMatch = text.match(/^scan\s+(.+)/i);
      if (scanMatch) {
        const target = scanMatch[1].trim();
        $('intel-mint').value = target;
        setMode('intel');
        setTimeout(fetchTokenIntel, 100);
        return '⬡ Scanning ' + target + '...';
      }

      // "buy 0.1 [mint]" or "buy 0.1 sol of [mint]"
      const buyMatch = text.match(/^buy\s+([\d.]+)\s*(?:sol\s+(?:of\s+)?)?([1-9A-HJ-NP-Za-km-z]{32,44})/i);
      if (buyMatch) {
        const amount = parseFloat(buyMatch[1]);
        const mint = buyMatch[2];
        setMode('trade');
        $('tr-mint').value = mint;
        onMintInput(mint);
        setTimeout(() => { setTradeAmt(amount); }, 500);
        return `⟡ Setting up buy: ${amount} SOL → ${mint.slice(0,6)}...${mint.slice(-4)}\nOpened trade panel. Hit BUY when ready.`;
      }

      // "sell [mint]" or "sell all [mint]"
      const sellMatch = text.match(/^sell\s+(?:all\s+)?([1-9A-HJ-NP-Za-km-z]{32,44})/i);
      if (sellMatch) {
        const mint = sellMatch[1];
        setMode('trade');
        $('tr-mint').value = mint;
        onMintInput(mint);
        return `⟡ Setting up sell: ${mint.slice(0,6)}...${mint.slice(-4)}\nOpened trade panel. Hit SELL when ready.`;
      }

      // "set slippage 2" or "slippage 5%"
      const slipMatch = text.match(/(?:set\s+)?slippage\s+([\d.]+)/i);
      if (slipMatch) {
        $('tr-slippage').value = parseFloat(slipMatch[1]);
        return `⚙️ Slippage set to ${slipMatch[1]}%`;
      }

      // "set priority 0.001"
      const prioMatch = text.match(/(?:set\s+)?priority\s+([\d.]+)/i);
      if (prioMatch) {
        $('tr-priority').value = parseFloat(prioMatch[1]);
        return `⚙️ Priority fee set to ${prioMatch[1]} SOL`;
      }

      return null;
    }

    // Quick price lookup via DexScreener
    async function quickPriceLookup(query) {
      try {
        let url;
        if (/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(query)) {
          url = `${DEXSCREENER_API}/tokens/${query}`;
        } else {
          url = `${DEXSCREENER_API}/search/?q=${encodeURIComponent(query)}`;
        }

        const res = await fetch(url);
        const data = await res.json();
        let pairs = (data.pairs || []).filter(p => p.chainId === getChain().dexScreenerChain);

        if (pairs.length === 0) {
          addMsg('system', `⬡ No Solana token found for "${query}"`);
          return;
        }

        // Highest liquidity pair
        const pair = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
        const symbol = pair.baseToken?.symbol || '???';
        const name = pair.baseToken?.name || symbol;
        const price = pair.priceUsd ? parseFloat(pair.priceUsd) : 0;
        const change1h = pair.priceChange?.h1 || 0;
        const change24h = pair.priceChange?.h24 || 0;
        const vol24h = pair.volume?.h24 || 0;
        const liq = pair.liquidity?.usd || 0;
        const mcap = pair.marketCap || pair.fdv || 0;
        const mint = pair.baseToken?.address || '';

        const fmtUsd = (n) => {
          if (n >= 1e9) return '$' + (n / 1e9).toFixed(1) + 'B';
          if (n >= 1e6) return '$' + (n / 1e6).toFixed(1) + 'M';
          if (n >= 1e3) return '$' + (n / 1e3).toFixed(1) + 'K';
          return '$' + n.toFixed(0);
        };
        const fmtPrice = (p) => {
          if (p === 0) return '$0';
          if (p < 0.000001) return '$' + p.toFixed(10);
          if (p < 0.01) return '$' + p.toFixed(6);
          if (p < 1) return '$' + p.toFixed(4);
          return '$' + p.toFixed(2);
        };

        const c1h = change1h >= 0 ? `🟢 +${change1h.toFixed(1)}%` : `🔴 ${change1h.toFixed(1)}%`;
        const c24h = change24h >= 0 ? `🟢 +${change24h.toFixed(1)}%` : `🔴 ${change24h.toFixed(1)}%`;

        addMsg('system', `⬡ **${name}** ($${symbol})\n\n💰 Price: **${fmtPrice(price)}**\n📊 1h: ${c1h} · 24h: ${c24h}\n📈 Vol 24h: ${fmtUsd(vol24h)} · MCap: ${fmtUsd(mcap)}\n💧 Liquidity: ${fmtUsd(liq)}\n\n\`${mint}\`\n\nType \`scan ${mint}\` for full intel or \`buy [amount] ${mint}\` to trade.`);
      } catch (e) {
        addMsg('system', `⚠️ Error looking up "${query}": ${e.message}`);
      }
    }

    // ── Add raw HTML message to chat (for rich cards) ──
    function addHtmlMsg(role, html) {
      const div = document.createElement('div'); div.className = 'message ' + role;
      if (role === 'assistant' || role === 'user') {
        const h = document.createElement('div'); h.className = 'mh';
        h.innerHTML = `<span class="mr">${role === 'user' ? 'YOU' : 'GHOST'}</span>${role === 'assistant' ? `<span class="mt">SCAN</span>` : ''}`;
        div.appendChild(h);
      }
      const c = document.createElement('div'); c.className = 'mc';
      c.innerHTML = html;
      div.appendChild(c);
      $('messages').appendChild(div); $('messages').scrollTop = $('messages').scrollHeight;
      return c;
    }

    // ═══════ FC — INLINE CHART COMMAND ═══════
    const FC_BINANCE_MAP = {
      sol:'SOLUSDT', btc:'BTCUSDT', eth:'ETHUSDT', bnb:'BNBUSDT', doge:'DOGEUSDT',
      xrp:'XRPUSDT', ada:'ADAUSDT', avax:'AVAXUSDT', dot:'DOTUSDT', matic:'MATICUSDT',
      link:'LINKUSDT', uni:'UNIUSDT', atom:'ATOMUSDT', near:'NEARUSDT', arb:'ARBUSDT',
      op:'OPUSDT', sui:'SUIUSDT', apt:'APTUSDT', sei:'SEIUSDT', inj:'INJUSDT',
      fil:'FILUSDT', ltc:'LTCUSDT', bch:'BCHUSDT', etc:'ETCUSDT', icp:'ICPUSDT',
      render:'RENDERUSDT', fet:'FETUSDT', wif:'WIFUSDT', pepe:'PEPEUSDT', bonk:'BONKUSDT',
      shib:'SHIBUSDT', floki:'FLOKIUSDT', jup:'JUPUSDT', pyth:'PYTHUSDT', jto:'JTOUSDT',
      ray:'RAYUSDT', ondo:'ONDOUSDT', pendle:'PENDLEUSDT', tia:'TIAUSDT', aave:'AAVEUSDT',
      mkr:'MKRUSDT', crv:'CRVUSDT', ldo:'LDOUSDT', snx:'SNXUSDT', trx:'TRXUSDT',
      ton:'TONUSDT', pol:'POLUSDT', hbar:'HBARUSDT', algo:'ALGOUSDT', xlm:'XLMUSDT',
      vet:'VETUSDT', ftm:'FTMUSDT', sand:'SANDUSDT', mana:'MANAUSDT', gala:'GALAUSDT',
      trump:'TRUMPUSDT', fartcoin:'FARTCOINUSDT', ai16z:'AI16ZUSDT', virtual:'VIRTUALUSDT',
      bitcoin:'BTCUSDT', solana:'SOLUSDT', ethereum:'ETHUSDT', binance:'BNBUSDT',
    };
    const FC_VALID_TF = ['1m','3m','5m','15m','30m','1h','2h','4h','6h','8h','12h','1d','3d','1w'];

    function isChartCommand(text) {
      const t = text.trim().toLowerCase();
      return t.startsWith('fc ') || t === 'fc';
    }

    async function handleChartCommand(text) {
      const parts = text.trim().toLowerCase().split(/\s+/);
      // fc <symbol> [timeframe]
      const symbol = parts[1] || '';
      let tf = parts[2] || '5m';
      if (!FC_VALID_TF.includes(tf)) tf = '5m';
      if (!symbol) {
        addHtmlMsg('assistant', '<div class="fc-card"><div class="fc-error">Usage: <b>fc &lt;symbol&gt; [timeframe]</b><br>Examples: fc sol 5m • fc btc 1h • fc eth 4h • fc pepe 15m<br>Timeframes: 1m 3m 5m 15m 30m 1h 2h 4h 6h 12h 1d 3d 1w<br><br>Also works with token addresses:<br>fc &lt;mint_address&gt; [timeframe]</div></div>');
        return;
      }

      // If symbol looks like a token address, go straight to DexScreener
      const isAddress = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(symbol) || /^0x[a-fA-F0-9]{40}$/.test(symbol);

      const chartId = 'fc-' + Date.now();
      const mc = addHtmlMsg('assistant', `<div class="fc-card" id="${chartId}"><div class="fc-loading">📊 Loading ${symbol.toUpperCase()} ${tf} chart...</div></div>`);

      // Try Binance first for known symbols (not addresses)
      const binancePair = !isAddress && FC_BINANCE_MAP[symbol];
      if (binancePair) {
        try {
          const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binancePair}&interval=${tf}&limit=120`);
          if (!res.ok) throw new Error('Binance API error');
          const candles = await res.json();
          if (!candles.length) throw new Error('No data');
          renderFcChart(chartId, symbol.toUpperCase(), tf, candles, binancePair);
          return;
        } catch(e) { console.warn('Binance failed for', symbol, e); }
      }

      // Fallback: try DexScreener search → embed chart
      try {
        const searchQ = isAddress ? symbol : symbol;
        const dsEndpoint = isAddress
          ? `https://api.dexscreener.com/latest/dex/tokens/${symbol}`
          : `https://api.dexscreener.com/latest/dex/search?q=${symbol}`;
        const dsRes = await fetch(dsEndpoint);
        const dsData = await dsRes.json();
        const pairs = (dsData.pairs || []).slice(0, 1);
        if (pairs.length > 0) {
          const pair = pairs[0];
          const chain = pair.chainId || 'solana';
          const pAddr = pair.pairAddress;
          const price = pair.priceUsd ? parseFloat(pair.priceUsd) : 0;
          const chg = pair.priceChange?.h24 || 0;
          const vol = pair.volume?.h24 || 0;
          const liq = pair.liquidity?.usd || 0;
          const name = pair.baseToken?.symbol || symbol.toUpperCase();
          const chgClass = chg >= 0 ? 'up' : 'down';
          const chgSign = chg >= 0 ? '+' : '';
          const fP = price < 0.001 ? price.toFixed(8) : price < 1 ? price.toFixed(5) : price < 1000 ? price.toFixed(2) : price.toLocaleString('en-US', {maximumFractionDigits:2});
          const fV = vol >= 1e6 ? (vol/1e6).toFixed(1)+'M' : vol >= 1e3 ? (vol/1e3).toFixed(1)+'K' : vol.toFixed(0);
          const fL = liq >= 1e6 ? (liq/1e6).toFixed(1)+'M' : liq >= 1e3 ? (liq/1e3).toFixed(1)+'K' : liq.toFixed(0);

          document.getElementById(chartId).innerHTML = `
            <div class="fc-header">
              <div>
                <div class="fc-pair">${name}/USD</div>
                <div class="fc-price-row">
                  <span class="fc-price">$${fP}</span>
                  <span class="fc-change ${chgClass}">${chgSign}${chg.toFixed(2)}%</span>
                </div>
              </div>
              <span class="fc-tf">${tf.toUpperCase()} • DEX</span>
            </div>
            <div class="fc-canvas-wrap">
              <iframe class="fc-embed-chart" src="https://dexscreener.com/${chain}/${pAddr}?embed=1&theme=dark&trades=0&info=0" sandbox="allow-scripts allow-same-origin" loading="lazy"></iframe>
            </div>
            <div class="fc-stats">
              <div class="fc-stat"><div class="fc-stat-label">VOL 24H</div><div class="fc-stat-val">$${fV}</div></div>
              <div class="fc-stat"><div class="fc-stat-label">LIQ</div><div class="fc-stat-val">$${fL}</div></div>
              <div class="fc-stat"><div class="fc-stat-label">DEX</div><div class="fc-stat-val">${pair.dexId || '?'}</div></div>
              <div class="fc-stat"><div class="fc-stat-label">CHAIN</div><div class="fc-stat-val">${chain.toUpperCase()}</div></div>
            </div>
            <div class="fc-actions">
              <button class="fc-btn buy" onclick="setInput('/buy ${pair.baseToken?.address || pAddr}')">⟡ BUY</button>
              <button class="fc-btn" onclick="window.open('https://dexscreener.com/${chain}/${pAddr}','_blank')">📊 FULL</button>
              <button class="fc-btn" onclick="quickTokenCard('${pair.baseToken?.address || pAddr}')">🔍 SCAN</button>
            </div>`;
          return;
        }
        throw new Error('No pairs found');
      } catch(e) {
        // Final fallback: direct DexScreener embed for known symbols (no API needed)
        const FC_DS_EMBEDS = {
          sol: {chain:'solana',pair:'So11111111111111111111111111111111111111112',name:'SOL'},
          btc: {chain:'solana',pair:'3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh',name:'BTC'},
          eth: {chain:'ethereum',pair:'0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640',name:'ETH'},
          bnb: {chain:'bsc',pair:'0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE',name:'BNB'},
          doge: {chain:'solana',pair:'BPDShvpWtdWgUBfcjBTRfSGEWn2FRbmzR31NQHP1r3jv',name:'DOGE'},
          xrp: {chain:'solana',pair:'FfKR5GtTkCS5VBpEnRDcmiSRxeg8GRDqnByqJahKcbPg',name:'XRP'},
          pepe: {chain:'ethereum',pair:'0xa43fe16908251ee70ef74718545e4fe6c5ccec9f',name:'PEPE'},
          wif: {chain:'solana',pair:'EP2ib6dYdEeqD8MfE2ezHCxX3kP3K2eLKkirfPm5eyMx',name:'WIF'},
          bonk: {chain:'solana',pair:'BjZKz1z4UMjGPGRbGnSm7tX4DCbMTQGnhKKo2epump',name:'BONK'},
          jup: {chain:'solana',pair:'C1MgLojNMsi1r3pkU2cEaGFgRMA1gLDRd559JH7ePump',name:'JUP'},
          trump: {chain:'solana',pair:'HnMYFWMusiqKamPXNFkajLMaGHajpJWqRWfWnzNyBCAa',name:'TRUMP'},
          ai16z: {chain:'solana',pair:'HB97VsfGNKMBjcT3BmBBxiNkQF2aUDmLTpS3mDmepump',name:'AI16Z'},
          fartcoin: {chain:'solana',pair:'9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM',name:'FARTCOIN'},
          render: {chain:'solana',pair:'8tFuPAxFbUDqLsZBcoPnQvF8P7RU2oYoBaHqFxTPpump',name:'RENDER'},
          virtual: {chain:'base',pair:'0xb0b0c05b9dd18fb94e3f0f5e4eab10a7c8c1a0ef',name:'VIRTUAL'},
          ray: {chain:'solana',pair:'AVs9TA4nWDzfPJE9IeHUJJT6w66pmHt5TNhEB7hhsVcx',name:'RAY'},
          pyth: {chain:'solana',pair:'H3kVpGRzMBrEcCaeFuXHMbT8G55E4U1Sf5ZsAZbBpump',name:'PYTH'},
        };
        const embed = FC_DS_EMBEDS[symbol];
        if (embed) {
          const darkMode = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
          document.getElementById(chartId).innerHTML = `
            <div class="fc-header">
              <div><div class="fc-pair">${embed.name}/USD</div></div>
              <span class="fc-tf">${tf.toUpperCase()} • DEXSCREENER</span>
            </div>
            <div class="fc-canvas-wrap" style="padding:0;">
              <iframe class="fc-embed-chart" src="https://dexscreener.com/${embed.chain}/${embed.pair}?embed=1&theme=${darkMode}&trades=0&info=0" sandbox="allow-scripts allow-same-origin" loading="lazy"></iframe>
            </div>
            <div class="fc-actions">
              <button class="fc-btn" onclick="window.open('https://dexscreener.com/${embed.chain}/${embed.pair}','_blank')">📊 FULL CHART</button>
              <button class="fc-btn" onclick="window.open('https://www.binance.com/en/trade/${(FC_BINANCE_MAP[symbol]||'').replace('USDT','_USDT')}','_blank')">🅱 BINANCE</button>
            </div>`;
          return;
        }
        // If also an address, try direct embed
        if (isAddress) {
          const addrChain = /^0x/.test(symbol) ? 'ethereum' : 'solana';
          const darkMode = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
          document.getElementById(chartId).innerHTML = `
            <div class="fc-header">
              <div><div class="fc-pair">${symbol.slice(0,6)}...${symbol.slice(-4)}</div></div>
              <span class="fc-tf">${tf.toUpperCase()} • DEXSCREENER</span>
            </div>
            <div class="fc-canvas-wrap" style="padding:0;">
              <iframe class="fc-embed-chart" src="https://dexscreener.com/${addrChain}/${symbol}?embed=1&theme=${darkMode}&trades=0&info=0" sandbox="allow-scripts allow-same-origin" loading="lazy"></iframe>
            </div>
            <div class="fc-actions">
              <button class="fc-btn" onclick="window.open('https://dexscreener.com/${addrChain}/${symbol}','_blank')">📊 FULL CHART</button>
            </div>`;
          return;
        }
        document.getElementById(chartId).innerHTML = `<div class="fc-error">❌ Could not find chart for "${symbol}"<br><span style="font-size:10px;color:var(--text-faint);">Try: fc sol 5m • fc btc 1h • fc pepe 15m • or paste a token address</span></div>`;
      }
    }

    function renderFcChart(chartId, symbol, tf, candles, binancePair) {
      // candles = [[openTime, open, high, low, close, volume, ...], ...]
      const opens = candles.map(c => parseFloat(c[1]));
      const highs = candles.map(c => parseFloat(c[2]));
      const lows = candles.map(c => parseFloat(c[3]));
      const closes = candles.map(c => parseFloat(c[4]));
      const vols = candles.map(c => parseFloat(c[5]));
      const times = candles.map(c => c[0]);

      const curPrice = closes[closes.length - 1];
      const openPrice = opens[0];
      const change = ((curPrice - openPrice) / openPrice * 100);
      const hi = Math.max(...highs);
      const lo = Math.min(...lows);
      const totalVol = vols.reduce((a,b) => a+b, 0);
      const chgClass = change >= 0 ? 'up' : 'down';
      const chgSign = change >= 0 ? '+' : '';
      const fP = curPrice < 0.001 ? curPrice.toFixed(8) : curPrice < 1 ? curPrice.toFixed(5) : curPrice < 1000 ? curPrice.toFixed(2) : curPrice.toLocaleString('en-US',{maximumFractionDigits:2});
      const fH = hi < 1 ? hi.toFixed(5) : hi.toFixed(2);
      const fL = lo < 1 ? lo.toFixed(5) : lo.toFixed(2);
      const fV = totalVol >= 1e9 ? (totalVol/1e9).toFixed(1)+'B' : totalVol >= 1e6 ? (totalVol/1e6).toFixed(1)+'M' : totalVol >= 1e3 ? (totalVol/1e3).toFixed(1)+'K' : totalVol.toFixed(0);

      const canvasId = 'cv-' + Date.now();
      const el = document.getElementById(chartId);
      el.innerHTML = `
        <div class="fc-header">
          <div>
            <div class="fc-pair">${symbol}/USDT</div>
            <div class="fc-price-row">
              <span class="fc-price">$${fP}</span>
              <span class="fc-change ${chgClass}">${chgSign}${change.toFixed(2)}%</span>
            </div>
          </div>
          <span class="fc-tf">${tf.toUpperCase()} • BINANCE</span>
        </div>
        <div class="fc-canvas-wrap">
          <canvas id="${canvasId}" width="980" height="380"></canvas>
        </div>
        <div class="fc-stats">
          <div class="fc-stat"><div class="fc-stat-label">HIGH</div><div class="fc-stat-val">$${fH}</div></div>
          <div class="fc-stat"><div class="fc-stat-label">LOW</div><div class="fc-stat-val">$${fL}</div></div>
          <div class="fc-stat"><div class="fc-stat-label">VOL</div><div class="fc-stat-val">${fV}</div></div>
          <div class="fc-stat"><div class="fc-stat-label">CANDLES</div><div class="fc-stat-val">${candles.length}</div></div>
        </div>
        <div class="fc-actions">
          <button class="fc-btn" onclick="handleChartCommand('fc ${symbol.toLowerCase()} 1m')">1M</button>
          <button class="fc-btn" onclick="handleChartCommand('fc ${symbol.toLowerCase()} 5m')">5M</button>
          <button class="fc-btn" onclick="handleChartCommand('fc ${symbol.toLowerCase()} 15m')">15M</button>
          <button class="fc-btn" onclick="handleChartCommand('fc ${symbol.toLowerCase()} 1h')">1H</button>
          <button class="fc-btn" onclick="handleChartCommand('fc ${symbol.toLowerCase()} 4h')">4H</button>
          <button class="fc-btn" onclick="handleChartCommand('fc ${symbol.toLowerCase()} 1d')">1D</button>
          <button class="fc-btn" onclick="window.open('https://www.binance.com/en/trade/${binancePair}','_blank')">📊 FULL</button>
        </div>`;

      // Draw candlestick chart
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      const padL = 10, padR = 70, padT = 10, padB = 50;
      const chartW = W - padL - padR, chartH = H - padT - padB;
      const volH = chartH * 0.18;

      // Background
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      ctx.fillStyle = isDark ? '#0a0f1a' : '#f0f2f5';
      ctx.fillRect(0, 0, W, H);

      const priceMin = lo * 0.9995;
      const priceMax = hi * 1.0005;
      const priceRange = priceMax - priceMin || 1;
      const volMax = Math.max(...vols) || 1;

      const toY = (p) => padT + chartH - volH - ((p - priceMin) / priceRange) * (chartH - volH);
      const n = candles.length;
      const candleW = Math.max(1, (chartW / n) * 0.7);
      const gap = chartW / n;

      // Grid lines
      ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 5; i++) {
        const y = padT + (chartH - volH) * i / 4;
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W - padR, y); ctx.stroke();
        const pLabel = priceMax - (priceRange * i / 4);
        ctx.fillStyle = isDark ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.4)';
        ctx.font = '10px "Fira Code", monospace';
        ctx.textAlign = 'left';
        ctx.fillText(pLabel < 1 ? pLabel.toFixed(5) : pLabel.toFixed(2), W - padR + 6, y + 4);
      }

      // Time labels
      const labelEvery = Math.max(1, Math.floor(n / 6));
      ctx.fillStyle = isDark ? 'rgba(255,255,255,0.25)' : 'rgba(0,0,0,0.35)';
      ctx.font = '9px "Fira Code", monospace';
      ctx.textAlign = 'center';
      for (let i = 0; i < n; i += labelEvery) {
        const x = padL + i * gap + gap / 2;
        const d = new Date(times[i]);
        const label = tf.includes('d') || tf.includes('w')
          ? `${d.getMonth()+1}/${d.getDate()}`
          : `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
        ctx.fillText(label, x, H - padB + 16);
      }

      // Volume bars
      for (let i = 0; i < n; i++) {
        const x = padL + i * gap + (gap - candleW) / 2;
        const vH = (vols[i] / volMax) * volH;
        const bull = closes[i] >= opens[i];
        ctx.fillStyle = bull ? 'rgba(34,197,94,0.18)' : 'rgba(239,68,68,0.18)';
        ctx.fillRect(x, padT + chartH - vH, candleW, vH);
      }

      // Candles
      for (let i = 0; i < n; i++) {
        const x = padL + i * gap + gap / 2;
        const bull = closes[i] >= opens[i];
        const color = bull ? '#22c55e' : '#ef4444';

        // Wick
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, toY(highs[i]));
        ctx.lineTo(x, toY(lows[i]));
        ctx.stroke();

        // Body
        const bodyTop = toY(Math.max(opens[i], closes[i]));
        const bodyBot = toY(Math.min(opens[i], closes[i]));
        const bodyH = Math.max(1, bodyBot - bodyTop);
        ctx.fillStyle = color;
        ctx.fillRect(x - candleW/2, bodyTop, candleW, bodyH);
      }

      // Current price line
      const curY = toY(curPrice);
      ctx.setLineDash([4, 3]);
      ctx.strokeStyle = change >= 0 ? '#22c55e' : '#ef4444';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(padL, curY); ctx.lineTo(W - padR, curY); ctx.stroke();
      ctx.setLineDash([]);

      // Price label badge
      ctx.fillStyle = change >= 0 ? '#22c55e' : '#ef4444';
      const badgeW = 62, badgeH = 18;
      ctx.beginPath();
      ctx.roundRect(W - padR + 2, curY - badgeH/2, badgeW, badgeH, 4);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px "Fira Code", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('$' + fP, W - padR + 2 + badgeW/2, curY + 4);
    }

    // ── Rick-style Token Card ──
    let _lastDexScreenerCall = 0;
    const DEXSCREENER_MIN_INTERVAL = 500; // ms between calls

    async function quickTokenCard(mint) {
      // Rate limit DexScreener calls
      const now = Date.now();
      if (now - _lastDexScreenerCall < DEXSCREENER_MIN_INTERVAL) {
        await new Promise(r => setTimeout(r, DEXSCREENER_MIN_INTERVAL - (now - _lastDexScreenerCall)));
      }
      _lastDexScreenerCall = Date.now();

      if ($('empty-state')) $('empty-state').style.display = 'none';
      addHtmlMsg('assistant', '<div class="tk-card" style="padding:14px;text-align:center;color:var(--text-muted);font-size:12px;">Scanning token...</div>');

      try {
        const dsRes = await fetch(`${DEXSCREENER_API}/tokens/${mint}`);
        const dsData = await dsRes.json();
        let pairs = (dsData.pairs || []).filter(p => p.chainId === getChain().dexScreenerChain);

        if (pairs.length === 0) {
          // Try pump.fun / new token — might not be on DEX yet
          const lastMsg = $('messages').lastElementChild;
          if (lastMsg) lastMsg.querySelector('.mc').innerHTML = `<div class="tk-card" style="padding:14px;text-align:center;color:var(--text-muted);font-size:12px;">⚠️ No ${getChain().name} DEX data found for this token.<br>It may be too new or not yet listed.</div>`;
          return;
        }

        // Best pair by liquidity
        const pair = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
        const symbol = pair.baseToken?.symbol || '???';
        const name = pair.baseToken?.name || symbol;
        const price = pair.priceUsd ? parseFloat(pair.priceUsd) : 0;
        const fdv = pair.fdv || pair.marketCap || 0;
        const mcap = pair.marketCap || fdv;
        const liq = pair.liquidity?.usd || 0;
        const vol24 = pair.volume?.h24 || 0;
        const vol6 = pair.volume?.h6 || 0;
        const vol1 = pair.volume?.h1 || 0;
        const vol5m = pair.volume?.m5 || 0;
        const chg5m = pair.priceChange?.m5 || 0;
        const chg1h = pair.priceChange?.h1 || 0;
        const chg6h = pair.priceChange?.h6 || 0;
        const chg24h = pair.priceChange?.h24 || 0;
        const txns24 = pair.txns?.h24 || {};
        const buys24 = txns24.buys || 0;
        const sells24 = txns24.sells || 0;
        const pairAge = pair.pairCreatedAt ? timeSince(pair.pairCreatedAt) : '?';
        const dexId = pair.dexId || '?';
        const pairAddr = pair.pairAddress || '';
        const imgUrl = pair.info?.imageUrl || '';

        const fU = (n) => {
          if (n >= 1e9) return '$' + (n / 1e9).toFixed(2) + 'B';
          if (n >= 1e6) return '$' + (n / 1e6).toFixed(2) + 'M';
          if (n >= 1e3) return '$' + (n / 1e3).toFixed(1) + 'K';
          return '$' + n.toFixed(0);
        };
        const fP = (p) => {
          if (p === 0) return '$0';
          if (p < 0.0000001) return '$' + p.toExponential(2);
          if (p < 0.000001) return '$' + p.toFixed(10);
          if (p < 0.01) return '$' + p.toFixed(6);
          if (p < 1) return '$' + p.toFixed(4);
          return '$' + p.toFixed(2);
        };
        const chgHtml = (v) => {
          if (v === 0 || v === undefined) return '<span style="color:var(--text-faint)">0%</span>';
          return v > 0 ? `<span class="tk-chg-val up">+${v.toFixed(1)}%</span>` : `<span class="tk-chg-val down">${v.toFixed(1)}%</span>`;
        };

        const colors = ['#9b8ce8','#00ffc8','#ff6b6b','#ffd93d','#6bcbff','#ff8f5c'];
        const color = colors[Math.abs(symbol.charCodeAt(0)) % colors.length];
        const initial = symbol.slice(0, 2).toUpperCase();

        // Liquidity score
        let safetyLabel = '', safetyColor = '';
        if (liq > 100000) { safetyLabel = '🟢 HIGH LIQ'; safetyColor = 'var(--green)'; }
        else if (liq > 10000) { safetyLabel = '🟡 MED LIQ'; safetyColor = '#ffd93d'; }
        else { safetyLabel = '🔴 LOW LIQ'; safetyColor = 'var(--red)'; }

        const cardHtml = `<div class="tk-card">
          <div class="tk-head">
            ${imgUrl ? `<img src="${imgUrl}" style="width:36px;height:36px;border-radius:50%;object-fit:cover;" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"><div class="tk-icon" style="background:${color};display:none;">${initial}</div>` : `<div class="tk-icon" style="background:${color};">${initial}</div>`}
            <div class="tk-title">
              <div class="tk-name">${escapeHtml(name)}</div>
              <div class="tk-ticker">$${escapeHtml(symbol)} · ${escapeHtml(dexId.toUpperCase())} · <span style="color:${safetyColor};font-size:10px;">${safetyLabel}</span></div>
            </div>
            <div class="tk-price-big">${fP(price)}</div>
            <button onclick="quickTokenCardRefresh('${mint}')" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:14px;padding:4px;flex-shrink:0;" title="Refresh">↻</button>
          </div>

          <div class="tk-changes">
            <div class="tk-chg"><div class="tk-chg-label">5m</div>${chgHtml(chg5m)}</div>
            <div class="tk-chg"><div class="tk-chg-label">1h</div>${chgHtml(chg1h)}</div>
            <div class="tk-chg"><div class="tk-chg-label">6h</div>${chgHtml(chg6h)}</div>
            <div class="tk-chg"><div class="tk-chg-label">24h</div>${chgHtml(chg24h)}</div>
          </div>

          <div class="tk-grid">
            <div class="tk-cell"><div class="tk-label">FDV</div><div class="tk-val">${fU(fdv)}</div></div>
            <div class="tk-cell"><div class="tk-label">Market Cap</div><div class="tk-val">${fU(mcap)}</div></div>
            <div class="tk-cell"><div class="tk-label">Liquidity</div><div class="tk-val">${fU(liq)}</div></div>
            <div class="tk-cell"><div class="tk-label">Vol 24h</div><div class="tk-val">${fU(vol24)}</div></div>
            <div class="tk-cell"><div class="tk-label">Vol 1h</div><div class="tk-val">${fU(vol1)}</div></div>
            <div class="tk-cell"><div class="tk-label">Age</div><div class="tk-val">${pairAge}</div></div>
            <div class="tk-cell"><div class="tk-label">Buys 24h</div><div class="tk-val green">${buys24}</div></div>
            <div class="tk-cell"><div class="tk-label">Sells 24h</div><div class="tk-val red">${sells24}</div></div>
          </div>

          <div class="tk-addr" onclick="navigator.clipboard.writeText('${mint}');toast('📋 Copied!')" title="Click to copy">${mint}</div>

          <div class="qt-section">
            <div class="qt-label">⚡ QUICK BUY</div>
            <div class="qt-row">
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.01,'${escapeHtml(symbol)}',this)">0.01 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.05,'${escapeHtml(symbol)}',this)">0.05 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.1,'${escapeHtml(symbol)}',this)">0.1 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.5,'${escapeHtml(symbol)}',this)">0.5 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',1,'${escapeHtml(symbol)}',this)">1 SOL</button>
            </div>
            <div class="qt-label" style="margin-top:8px;">⚡ QUICK SELL</div>
            <div class="qt-row">
              <button class="qt-sell-btn" onclick="quickSell('${mint}',25,'${escapeHtml(symbol)}',this)">25%</button>
              <button class="qt-sell-btn" onclick="quickSell('${mint}',50,'${escapeHtml(symbol)}',this)">50%</button>
              <button class="qt-sell-btn" onclick="quickSell('${mint}',75,'${escapeHtml(symbol)}',this)">75%</button>
              <button class="qt-sell-btn" onclick="quickSell('${mint}',100,'${escapeHtml(symbol)}',this)">100%</button>
            </div>
            <div class="qt-status"></div>
          </div>

          <div class="tk-actions">
            <button class="tk-btn" onclick="setMode('trade');$('tr-mint').value='${mint}';onMintInput('${mint}');">⟡ ADVANCED</button>
            <button class="tk-btn" onclick="$('intel-mint').value='${mint}';setMode('intel');fetchTokenIntel();">⬡ SCAN</button>
            <button class="tk-btn" onclick="openChart('${mint}','${symbol}')">📊 CHART</button>
            <button class="tk-btn" onclick="addToWatchlist('${mint}')">⭐ WATCH</button>
          </div>
        </div>`;

        // Replace the loading card
        const lastMsg = $('messages').lastElementChild;
        if (lastMsg) lastMsg.querySelector('.mc').innerHTML = cardHtml;
        chatMessages.push({ role: 'assistant', content: `Token scan: ${name} ($${symbol}) — Price: ${fP(price)}, FDV: ${fU(fdv)}, Liq: ${fU(liq)}, Vol 24h: ${fU(vol24)}` });
        saveCurrentSession();

      } catch (e) {
        const lastMsg = $('messages').lastElementChild;
        if (lastMsg) lastMsg.querySelector('.mc').innerHTML = `<div class="tk-card" style="padding:14px;text-align:center;color:var(--red);font-size:12px;">⚠️ Error scanning token: ${e.message}</div>`;
      }
    }

    async function quickTokenCardRefresh(mint) {
      // Find the card that triggered refresh and replace it in-place
      const cards = document.querySelectorAll('.tk-card');
      const card = cards[cards.length - 1]; // Latest card, or find by mint
      for (const c of cards) {
        if (c.querySelector('.tk-addr') && c.querySelector('.tk-addr').textContent.trim() === mint) {
          c.innerHTML = '<div style="padding:14px;text-align:center;color:var(--text-muted);font-size:12px;">Refreshing...</div>';
          break;
        }
      }

      try {
        const dsRes = await fetch(`${DEXSCREENER_API}/tokens/${mint}`);
        const dsData = await dsRes.json();
        let pairs = (dsData.pairs || []).filter(p => p.chainId === getChain().dexScreenerChain);
        if (pairs.length === 0) { toast('No data found'); return; }

        const pair = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
        const symbol = pair.baseToken?.symbol || '???';
        const name = pair.baseToken?.name || symbol;
        const price = pair.priceUsd ? parseFloat(pair.priceUsd) : 0;
        const fdv = pair.fdv || pair.marketCap || 0;
        const mcap = pair.marketCap || fdv;
        const liq = pair.liquidity?.usd || 0;
        const vol24 = pair.volume?.h24 || 0;
        const vol1 = pair.volume?.h1 || 0;
        const chg5m = pair.priceChange?.m5 || 0;
        const chg1h = pair.priceChange?.h1 || 0;
        const chg6h = pair.priceChange?.h6 || 0;
        const chg24h = pair.priceChange?.h24 || 0;
        const buys24 = pair.txns?.h24?.buys || 0;
        const sells24 = pair.txns?.h24?.sells || 0;
        const pairAge = pair.pairCreatedAt ? timeSince(pair.pairCreatedAt) : '?';
        const dexId = pair.dexId || '?';
        const imgUrl = pair.info?.imageUrl || '';

        const fU = (n) => n >= 1e9 ? '$'+(n/1e9).toFixed(2)+'B' : n >= 1e6 ? '$'+(n/1e6).toFixed(2)+'M' : n >= 1e3 ? '$'+(n/1e3).toFixed(1)+'K' : '$'+n.toFixed(0);
        const fP = (p) => p===0?'$0':p<0.0000001?'$'+p.toExponential(2):p<0.000001?'$'+p.toFixed(10):p<0.01?'$'+p.toFixed(6):p<1?'$'+p.toFixed(4):'$'+p.toFixed(2);
        const chgHtml = (v) => !v ? '<span style="color:var(--text-faint)">0%</span>' : v > 0 ? `<span class="tk-chg-val up">+${v.toFixed(1)}%</span>` : `<span class="tk-chg-val down">${v.toFixed(1)}%</span>`;

        const colors = ['#9b8ce8','#00ffc8','#ff6b6b','#ffd93d','#6bcbff','#ff8f5c'];
        const color = colors[Math.abs(symbol.charCodeAt(0)) % colors.length];
        const initial = symbol.slice(0,2).toUpperCase();
        let safetyLabel='',safetyColor='';
        if(liq>100000){safetyLabel='🟢 HIGH LIQ';safetyColor='var(--green)';}
        else if(liq>10000){safetyLabel='🟡 MED LIQ';safetyColor='#ffd93d';}
        else{safetyLabel='🔴 LOW LIQ';safetyColor='var(--red)';}

        const newHtml = `
          <div class="tk-head">
            ${imgUrl ? `<img src="${imgUrl}" style="width:36px;height:36px;border-radius:50%;object-fit:cover;" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"><div class="tk-icon" style="background:${color};display:none;">${initial}</div>` : `<div class="tk-icon" style="background:${color};">${initial}</div>`}
            <div class="tk-title">
              <div class="tk-name">${escapeHtml(name)}</div>
              <div class="tk-ticker">$${escapeHtml(symbol)} · ${escapeHtml(dexId.toUpperCase())} · <span style="color:${safetyColor};font-size:10px;">${safetyLabel}</span></div>
            </div>
            <div class="tk-price-big">${fP(price)}</div>
            <button onclick="quickTokenCardRefresh('${mint}')" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:14px;padding:4px;flex-shrink:0;" title="Refresh">↻</button>
          </div>
          <div class="tk-changes">
            <div class="tk-chg"><div class="tk-chg-label">5m</div>${chgHtml(chg5m)}</div>
            <div class="tk-chg"><div class="tk-chg-label">1h</div>${chgHtml(chg1h)}</div>
            <div class="tk-chg"><div class="tk-chg-label">6h</div>${chgHtml(chg6h)}</div>
            <div class="tk-chg"><div class="tk-chg-label">24h</div>${chgHtml(chg24h)}</div>
          </div>
          <div class="tk-grid">
            <div class="tk-cell"><div class="tk-label">FDV</div><div class="tk-val">${fU(fdv)}</div></div>
            <div class="tk-cell"><div class="tk-label">Market Cap</div><div class="tk-val">${fU(mcap)}</div></div>
            <div class="tk-cell"><div class="tk-label">Liquidity</div><div class="tk-val">${fU(liq)}</div></div>
            <div class="tk-cell"><div class="tk-label">Vol 24h</div><div class="tk-val">${fU(vol24)}</div></div>
            <div class="tk-cell"><div class="tk-label">Vol 1h</div><div class="tk-val">${fU(vol1)}</div></div>
            <div class="tk-cell"><div class="tk-label">Age</div><div class="tk-val">${pairAge}</div></div>
            <div class="tk-cell"><div class="tk-label">Buys 24h</div><div class="tk-val green">${buys24}</div></div>
            <div class="tk-cell"><div class="tk-label">Sells 24h</div><div class="tk-val red">${sells24}</div></div>
          </div>
          <div class="tk-addr" onclick="navigator.clipboard.writeText('${mint}');toast('📋 Copied!')" title="Click to copy">${mint}</div>
          <div class="qt-section">
            <div class="qt-label">⚡ QUICK BUY</div>
            <div class="qt-row">
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.01,'${escapeHtml(symbol)}',this)">0.01 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.05,'${escapeHtml(symbol)}',this)">0.05 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.1,'${escapeHtml(symbol)}',this)">0.1 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',0.5,'${escapeHtml(symbol)}',this)">0.5 SOL</button>
              <button class="qt-buy-btn" onclick="quickBuy('${mint}',1,'${escapeHtml(symbol)}',this)">1 SOL</button>
            </div>
            <div class="qt-label" style="margin-top:8px;">⚡ QUICK SELL</div>
            <div class="qt-row">
              <button class="qt-sell-btn" onclick="quickSell('${mint}',25,'${escapeHtml(symbol)}',this)">25%</button>
              <button class="qt-sell-btn" onclick="quickSell('${mint}',50,'${escapeHtml(symbol)}',this)">50%</button>
              <button class="qt-sell-btn" onclick="quickSell('${mint}',75,'${escapeHtml(symbol)}',this)">75%</button>
              <button class="qt-sell-btn" onclick="quickSell('${mint}',100,'${escapeHtml(symbol)}',this)">100%</button>
            </div>
            <div class="qt-status"></div>
          </div>
          <div class="tk-actions">
            <button class="tk-btn" onclick="setMode('trade');$('tr-mint').value='${mint}';onMintInput('${mint}');">⟡ ADVANCED</button>
            <button class="tk-btn" onclick="$('intel-mint').value='${mint}';setMode('intel');fetchTokenIntel();">⬡ SCAN</button>
            <button class="tk-btn" onclick="openChart('${mint}','${symbol}')">📊 CHART</button>
            <button class="tk-btn" onclick="addToWatchlist('${mint}')">⭐ WATCH</button>
          </div>`;

        // Find and update the card with this mint
        const allCards = document.querySelectorAll('.tk-card');
        for (const c of allCards) {
          const addr = c.querySelector('.tk-addr');
          if ((addr && addr.textContent.trim() === mint) || c.innerHTML.includes('Refreshing')) {
            c.innerHTML = newHtml;
            toast('↻ Refreshed');
            return;
          }
        }
      } catch (e) {
        toast('Refresh failed: ' + e.message);
      }
    }

    function timeSince(timestamp) {
      const ms = Date.now() - timestamp;
      const s = Math.floor(ms / 1000);
      if (s < 60) return s + 's';
      const m = Math.floor(ms / 60000);
      if (m < 60) return m + 'm';
      const h = Math.floor(m / 60);
      if (h < 24) return h + 'h';
      const d = Math.floor(h / 24);
      if (d < 30) return d + 'd';
      const mo = Math.floor(d / 30);
      return mo + 'mo';
    }

    function tryLocalCommand(text) {
      // Check instant commands
      for (const cmd of LOCAL_COMMANDS) {
        for (const pattern of cmd.patterns) {
          if (pattern.test(text)) return cmd.action();
        }
      }
      // Check trade commands
      return tryTradeCommand(text);
    }

    // Parse Claude's agent response for action tags
    function parseAndExecuteActions(responseText) {
      const actionRegex = /\{\{ACTION:([^}]+)\}\}/g;
      let match;
      let cleanText = responseText;
      while ((match = actionRegex.exec(responseText)) !== null) {
        const actionStr = match[1];
        const parts = actionStr.split('|');
        const action = parts[0];
        cleanText = cleanText.replace(match[0], '');
        try {
          switch (action) {
            case 'open_trade': setMode('trade'); break;
            case 'open_launch': setMode('launch'); break;
            case 'open_wallet': setMode('wallet'); break;
            case 'open_tools': setMode('tools'); break;
            case 'open_sniper': setMode('sniper'); break;
            case 'open_history': setMode('history'); break;
            case 'new_chat': setTimeout(newChat, 200); break;
            case 'connect_wallet': connectWallet(); break;
            case 'sniper_on': if (!sniperEnabled) toggleSniper(); break;
            case 'sniper_off': if (sniperEnabled) toggleSniper(); break;
            case 'web_search_on': if (!webSearchEnabled) toggleWebSearch(); break;
            case 'web_search_off': if (webSearchEnabled) toggleWebSearch(); break;
            case 'setup_buy':
              if (parts[1]) { setMode('trade'); $('tr-mint').value = parts[1]; onMintInput(parts[1]); }
              if (parts[2]) setTimeout(() => setTradeAmt(parseFloat(parts[2])), 500);
              break;
            case 'setup_sell':
              if (parts[1]) { setMode('trade'); $('tr-mint').value = parts[1]; onMintInput(parts[1]); }
              break;
            case 'set_slippage':
              if (parts[1]) $('tr-slippage').value = parseFloat(parts[1]);
              break;
            case 'dark_mode': if (document.documentElement.getAttribute('data-theme') !== 'dark') toggleTheme(); break;
            case 'light_mode': if (document.documentElement.getAttribute('data-theme') !== 'light') toggleTheme(); break;
            case 'open_alpha': setMode('alpha'); break;
            case 'start_alpha': setMode('alpha'); setTimeout(startAlphaBot, 200); break;
            case 'stop_alpha': stopAlphaBot(); break;
            case 'study_wallets': setMode('alpha'); setTimeout(alphaStudy, 200); break;
            case 'auto_learn': setMode('alpha'); setTimeout(alphaAutoLearn, 200); break;
            case 'open_watchlist': setMode('watchlist'); break;
            case 'open_perps': setMode('perps'); break;
            case 'open_bundle': setMode('bundle'); break;
            case 'check_bundle':
              setMode('bundle');
              if (parts[1]) { setTimeout(() => { $('bundle-mint').value = parts[1]; runBundleCheck(); }, 200); }
              break;
            case 'open_chart':
              if (parts[1]) openChart(parts[1], parts[2] || '');
              break;
          }
        } catch(e) { console.warn('Action failed:', action, e); }
      }
      return cleanText.trim();
    }

    // ═══════ CLAUDE API KEY ═══════
    function getModelLabel(model) {
      if (model.includes('sonnet-4')) return 'Sonnet 4';
      if (model.includes('haiku-4')) return 'Haiku 4.5';
      if (model.includes('opus-4')) return 'Opus 4.5';
      return model;
    }

    function checkApiKey() {
      if (apiKey && apiKey.startsWith('sk-ant-')) {
        $('api-s').className = 'sbadge on';
        $('api-st').textContent = getModelLabel(currentModel).toUpperCase();
      } else {
        $('api-s').className = 'sbadge off';
        $('api-st').textContent = 'NO KEY';
      }
    }

    function promptApiKey() {
      const overlay = document.createElement('div');
      overlay.className = 'key-overlay';
      overlay.innerHTML = `
        <div class="key-modal">
          <div class="key-modal-icon">🔑</div>
          <h3>Claude API Key</h3>
          <p>Enter your Anthropic API key. It's stored in your browser only — never sent anywhere except api.anthropic.com.</p>
          <input type="password" id="key-input" placeholder="sk-ant-api03-..." value="${apiKey || ''}">
          <div class="key-btns">
            <button class="key-cancel" onclick="this.closest('.key-overlay').remove()">Cancel</button>
            <button class="key-save" onclick="saveApiKey()">Save Key</button>
          </div>
        </div>`;
      overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
      document.body.appendChild(overlay);
      setTimeout(() => document.getElementById('key-input')?.focus(), 50);
    }

    function saveApiKey() {
      const val = document.getElementById('key-input')?.value?.trim();
      if (!val) { toast('Please enter an API key'); return; }
      if (!val.startsWith('sk-ant-')) { toast('Key should start with sk-ant-...'); return; }
      apiKey = val;
      lsSet('ghost-claude-key', apiKey);
      document.querySelector('.key-overlay')?.remove();
      checkApiKey();
      toast('API key saved ✓');
    }

    $('model-sel').addEventListener('change', e => {
      currentModel = e.target.value;
      lsSet('ghost-model', currentModel);
      checkApiKey();
    });

    // ═══════ CHAT ═══════
    async function sendMessage() {
      const text = $('input').value.trim();
      if (!text || isGenerating) return;

      if ($('empty-state')) $('empty-state').style.display = 'none';
      if (!currentSessionId) currentSessionId = generateId();

      // ── CONTRACT ADDRESS DETECTION (both modes) ──
      const trimmed = text.trim();
      if (/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(trimmed) && trimmed !== SOL_MINT) {
        addMsg('user', text); $('input').value = '';
        chatMessages.push({ role: 'user', content: text });
        saveCurrentSession();
        quickTokenCard(trimmed);
        $('input').focus();
        return;
      }

      // ── FC CHART COMMAND ──
      if (isChartCommand(trimmed)) {
        addMsg('user', text); $('input').value = '';
        chatMessages.push({ role: 'user', content: text });
        saveCurrentSession();
        handleChartCommand(trimmed);
        $('input').focus();
        return;
      }

      // ── AGENT MODE: try local command first ──
      if (chatMode === 'agent') {
        const localResult = tryLocalCommand(text);
        if (localResult) {
          addMsg('user', text); $('input').value = '';
          addMsg('system', localResult);
          chatMessages.push({ role: 'user', content: text });
          chatMessages.push({ role: 'assistant', content: localResult });
          saveCurrentSession();
          $('input').focus();
          return;
        }
      }

      // Need API key for Claude calls
      if (!apiKey || !apiKey.startsWith('sk-ant-')) {
        promptApiKey();
        return;
      }

      addMsg('user', text); $('input').value = '';
      const el = addMsg('assistant', '', true);
      isGenerating = true; $('send-btn').disabled = true;

      // Build system prompt based on mode
      let sysPrompt;
      if (chatMode === 'agent') {
        sysPrompt = `You are Ghost, a crypto-native AI agent running a Solana trading terminal. You live and breathe crypto — Solana, memecoins, DeFi, DEXs, NFTs, smart money, on-chain analysis. You speak like a degen trader who also happens to be extremely knowledgeable.

You can execute actions by including action tags in your response.

AVAILABLE ACTIONS (include these in your response to trigger them):
{{ACTION:open_trade}} - Open the trade/swap panel
{{ACTION:open_launch}} - Open the token launcher
{{ACTION:open_wallet}} - Open the wallet panel
{{ACTION:open_tools}} - Open the tools panel
{{ACTION:open_sniper}} - Open the sniper bot settings
{{ACTION:open_history}} - Open history panel
{{ACTION:new_chat}} - Start a new chat
{{ACTION:connect_wallet}} - Connect wallet (Phantom, MetaMask, or Trust Wallet)
{{ACTION:sniper_on}} / {{ACTION:sniper_off}} - Toggle sniper
{{ACTION:web_search_on}} / {{ACTION:web_search_off}} - Toggle web search
{{ACTION:setup_buy|MINT_ADDRESS|AMOUNT}} - Open trade and prefill a buy
{{ACTION:setup_sell|MINT_ADDRESS}} - Open trade and prefill a sell
{{ACTION:set_slippage|PERCENT}} - Set slippage
{{ACTION:dark_mode}} / {{ACTION:light_mode}} - Switch theme
{{ACTION:open_alpha}} - Open Alpha Bot panel
{{ACTION:start_alpha}} - Start the Alpha copy-trading bot
{{ACTION:stop_alpha}} - Stop the Alpha bot
{{ACTION:study_wallets}} - Analyze tracked wallets and generate strategy
{{ACTION:auto_learn}} - Bot analyzes its own performance
{{ACTION:open_watchlist}} - Open token watchlist
{{ACTION:open_chart|MINT}} - Open embedded chart for a token
{{ACTION:open_perps}} - Open leverage trading terminal (Jupiter Perps)
{{ACTION:open_bundle}} - Open bundle checker
{{ACTION:check_bundle:MINT}} - Check if a token launch was bundled (scam detection)

RULES:
- CRYPTO ONLY. You are a crypto trading assistant. Keep all responses focused on crypto, blockchain, DeFi, trading, and related topics. If someone asks off-topic questions, steer back to crypto.
- When the user asks to do something (trade, open a panel, change settings), include the relevant ACTION tag AND a brief confirmation.
- Be concise and crypto-native. Use degen language naturally (ngmi, wagmi, lfg, ape in, rug, ser, anon, gm).
- If the user asks to buy/sell a specific token, use setup_buy or setup_sell with the mint address.
- Always warn about risks for trades. Remind about DYOR.
- The action tags will be hidden from the user — they only see your text.
- When someone pastes a contract address, they'll get an auto-scan. If they ask about a token by name, help them find it.
${webSearchEnabled ? '- You have web search — use it for real-time prices, news, and alpha.' : ''}
User wallet: ${walletAddress || 'not connected'}. Platform: Ghost Crypto v1.0. Alpha Bot: ${alphaBotRunning ? 'RUNNING (' + alphaWallets.length + ' wallets, ' + alphaBotTrades.filter(t=>t.side==='sell').length + ' closed trades, auto-learns every 5)' : 'inactive'}.`;
      } else {
        sysPrompt = `You are Ghost, a crypto-native AI built into a Solana trading terminal. You specialize in: Solana ecosystem, memecoins, DeFi protocols, DEX trading, token analysis, smart money tracking, on-chain data, technical analysis, yield farming, NFTs, and crypto culture.

PERSONALITY: Direct, sharp, degen-fluent. Use crypto slang naturally (ser, anon, ape, ngmi, wagmi, gm, lfg, rug, based). Be opinionated about markets but always remind users to DYOR. You're like a smart trading buddy who lives on-chain.

CRYPTO ONLY: Keep all responses focused on crypto and blockchain topics. If someone asks off-topic, briefly redirect: "ser I'm a crypto bot, let me help you with something on-chain instead."

${webSearchEnabled ? 'You have web search enabled — use it aggressively for real-time prices, news, narratives, and alpha.' : ''} User wallet: ${walletAddress || 'not connected'}. Platform: Ghost Crypto v1.0.`;
      }

      try {
        const apiMessages = chatMessages.slice(-20).map(m => ({ role: m.role, content: m.content }));

        const reqBody = {
          model: currentModel,
          max_tokens: 4096,
          system: sysPrompt,
          messages: apiMessages,
          stream: true,
        };

        if (webSearchEnabled) {
          reqBody.tools = [{ type: 'web_search_20250305', name: 'web_search', max_uses: 5 }];
        }

        const res = await fetch(CLAUDE_API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true',
          },
          body: JSON.stringify(reqBody),
        });

        if (!res.ok) {
          const errBody = await res.text();
          if (res.status === 401) throw new Error('Invalid API key — click 🔑 to update');
          if (res.status === 429) throw new Error('Rate limited — wait a moment and try again');
          if (res.status === 529) throw new Error('Claude is overloaded — try again shortly');
          throw new Error(`API error ${res.status}: ${errBody.slice(0, 100)}`);
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let full = '';
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6).trim();
              if (data === '[DONE]') continue;
              try {
                const evt = JSON.parse(data);

                if (evt.type === 'content_block_start' && evt.content_block?.type === 'tool_use' && evt.content_block?.name === 'web_search') {
                  updateMsg(el, '🔍 Searching the web...');
                }
                if (evt.type === 'content_block_start' && evt.content_block?.type === 'web_search_tool_result') {
                  updateMsg(el, '🔍 Processing search results...');
                }
                if (evt.type === 'content_block_delta' && evt.delta?.type === 'text_delta' && evt.delta?.text) {
                  full += evt.delta.text;
                  // Strip action tags from display in real-time
                  const displayText = full.replace(/\{\{ACTION:[^}]+\}\}/g, '').trim();
                  updateMsg(el, displayText);
                }
              } catch(e) {}
            }
          }
        }

        if (!full) {
          updateMsg(el, '⚠️ Empty response from Claude. Try again.');
        } else {
          // In agent mode, parse and execute action tags
          let cleanResponse = full;
          if (chatMode === 'agent') {
            cleanResponse = parseAndExecuteActions(full);
          }
          updateMsg(el, cleanResponse);
          chatMessages.push({ role: 'assistant', content: cleanResponse });
        }
      } catch(e) {
        updateMsg(el, `❌ ${e.message}`);
      }
      isGenerating = false; $('send-btn').disabled = false; $('input').focus();
      saveCurrentSession();
    }

    function addMsg(role, content, streaming) {
      const div = document.createElement('div'); div.className = 'message ' + role;
      if (role === 'user' || role === 'assistant') {
        const h = document.createElement('div'); h.className = 'mh';
        h.innerHTML = `<span class="mr">${role === 'user' ? 'YOU' : 'GHOST'}</span>${role === 'assistant' ? `<span class="mt">${getModelLabel(currentModel)}</span>` : ''}`;
        div.appendChild(h);
      }
      const c = document.createElement('div'); c.className = 'mc';
      if (streaming && !content) { c.innerHTML = '<div class="typing"><span>●</span><span>●</span><span>●</span></div>'; }
      else { c.innerHTML = content.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>').replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank">$1</a>'); }
      div.appendChild(c);
      $('messages').appendChild(div); $('messages').scrollTop = $('messages').scrollHeight;
      if (role === 'user') chatMessages.push({ role, content });
      return c;
    }

    function updateMsg(el, content) {
      el.innerHTML = content
        .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
        .replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>')
        .replace(/`([^`]+)`/g,'<code style="background:var(--bg-elevated);padding:1px 5px;border-radius:4px;font-size:0.9em;">$1</code>')
        .replace(/^### (.+)$/gm,'<strong style="font-size:1.05em;">$1</strong>')
        .replace(/^## (.+)$/gm,'<strong style="font-size:1.1em;">$1</strong>')
        .replace(/\n/g,'<br>')
        .replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank" style="color:var(--accent);">$1</a>');
      $('messages').scrollTop = $('messages').scrollHeight;
    }

    function setInput(text) { $('input').value = text; $('input').focus(); }
    $('input').addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
    $('intel-mint').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); fetchTokenIntel(); } });
    $('alpha-addr').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); addAlphaWallet(); } });
    $('watch-input').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); addToWatchlist($('watch-input').value.trim()); } });

    // ═══════ MEV PROTECTION (JITO) ═══════
    let mevEnabled = lsGet('ghost-mev', '') !== 'false'; // default on
    if ($('mev-toggle')) $('mev-toggle').classList.toggle('on', mevEnabled);

    function toggleMev() {
      mevEnabled = !mevEnabled;
      lsSet('ghost-mev', mevEnabled);
      $('mev-toggle').classList.toggle('on', mevEnabled);
      toast(mevEnabled ? '🛡️ MEV Protection ON — Jito bundles' : '⚠️ MEV Protection OFF');
    }

    async function sendViaJito(rawTx) {
      const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      function toBase58(bytes) {
        let num = BigInt(0);
        for (const b of bytes) num = num * 256n + BigInt(b);
        let str = '';
        while (num > 0n) { str = base58Chars[Number(num % 58n)] + str; num = num / 58n; }
        for (const b of bytes) { if (b === 0) str = '1' + str; else break; }
        return str || '1';
      }
      const b58 = toBase58(rawTx);
      const res = await fetch('https://mainnet.block-engine.jito.wtf/api/v1/transactions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          jsonrpc: '2.0', id: 1,
          method: 'sendTransaction',
          params: [b58, { encoding: 'base58' }]
        })
      });
      const data = await res.json();
      if (data.error) throw new Error('Jito: ' + (data.error.message || JSON.stringify(data.error)));
      return data.result;
    }

    // ═══════ WATCHLIST ═══════
    let watchlist = lsGetJSON('ghost-watchlist', []);

    function saveWatchlist() {
      lsSetJSON('ghost-watchlist', watchlist);
    }

    async function addToWatchlist(mint) {
      if (!mint || mint.length < 32) { toast('Paste a valid token address'); return; }
      mint = mint.trim();
      if (watchlist.find(w => w.mint === mint)) { toast('Already on watchlist'); return; }

      try {
        const res = await fetch(`${DEXSCREENER_API}/tokens/${mint}`);
        const data = await res.json();
        const pairs = (data.pairs || []).filter(p => p.chainId === 'solana');
        if (pairs.length === 0) { toast('Token not found on DEX'); return; }

        const pair = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
        watchlist.push({
          mint,
          symbol: pair.baseToken?.symbol || '???',
          name: pair.baseToken?.name || mint.slice(0, 8),
          addedPrice: pair.priceUsd ? parseFloat(pair.priceUsd) : 0,
          addedAt: Date.now(),
        });
        saveWatchlist();
        if ($('watch-input')) $('watch-input').value = '';
        toast('⭐ Added to watchlist');
        renderWatchlist();
        refreshWatchlistPrices();
      } catch (e) {
        toast('Error: ' + e.message);
      }
    }

    function removeFromWatchlist(mint) {
      watchlist = watchlist.filter(w => w.mint !== mint);
      saveWatchlist();
      renderWatchlist();
    }

    function renderWatchlist() {
      const el = $('watchlist-list');
      if (watchlist.length === 0) {
        el.innerHTML = `<div style="text-align:center;padding:40px;color:var(--text-muted);font-size:12px;">
          <div style="font-size:28px;margin-bottom:10px;">⭐</div>
          Your watchlist is empty.<br>Paste a contract address above or tap ⭐ on any token card.
        </div>`;
        return;
      }

      const colors = ['#9b8ce8','#00ffc8','#ff6b6b','#ffd93d','#6bcbff','#ff8f5c'];
      let html = '';
      watchlist.forEach(w => {
        const color = colors[Math.abs(w.symbol.charCodeAt(0)) % colors.length];
        const initial = w.symbol.slice(0, 2).toUpperCase();
        const priceStr = w.currentPrice ? formatWatchPrice(w.currentPrice) : '...';
        const chg24 = w.change24h;
        const chgHtml = chg24 !== undefined
          ? `<div class="watch-chg ${chg24 >= 0 ? 'up' : 'down'}">${chg24 >= 0 ? '+' : ''}${chg24.toFixed(1)}%</div>`
          : `<div class="watch-chg" style="color:var(--text-faint)">—</div>`;

        html += `<div class="watch-card">
          <div class="watch-icon" style="background:${color};cursor:pointer;" onclick="quickTokenCard('${w.mint}');setMode('chat')">${initial}</div>
          <div class="watch-info" style="cursor:pointer;" onclick="quickTokenCard('${w.mint}');setMode('chat')">
            <div class="watch-name">${w.name} <span style="color:var(--accent);font-size:10px;">$${w.symbol}</span></div>
            <div class="watch-mint">${w.mint.slice(0, 6)}...${w.mint.slice(-4)}</div>
          </div>
          <div class="watch-right">
            <div class="watch-price">${priceStr}</div>
            ${chgHtml}
          </div>
          <button class="tk-btn" onclick="openChart('${w.mint}','${w.symbol}')" style="flex:none;padding:5px 8px;font-size:9px;">📊</button>
          <button class="watch-del" onclick="removeFromWatchlist('${w.mint}')" title="Remove">✕</button>
        </div>`;
      });
      el.innerHTML = html;
    }

    function formatWatchPrice(p) {
      if (p === 0) return '$0';
      if (p < 0.0000001) return '$' + p.toExponential(2);
      if (p < 0.000001) return '$' + p.toFixed(10);
      if (p < 0.01) return '$' + p.toFixed(6);
      if (p < 1) return '$' + p.toFixed(4);
      return '$' + p.toFixed(2);
    }

    async function refreshWatchlistPrices() {
      if (watchlist.length === 0) return;
      try {
        const mints = watchlist.map(w => w.mint);
        // Batch fetch from DexScreener (max 30 addresses comma-separated)
        const chunks = [];
        for (let i = 0; i < mints.length; i += 30) chunks.push(mints.slice(i, i + 30));

        for (const chunk of chunks) {
          const res = await fetch(`${DEXSCREENER_API}/tokens/${chunk.join(',')}`);
          const data = await res.json();
          const pairs = (data.pairs || []).filter(p => p.chainId === 'solana');

          // Best pair per token
          const best = {};
          for (const p of pairs) {
            const addr = p.baseToken?.address;
            if (!addr) continue;
            if (!best[addr] || (p.liquidity?.usd || 0) > (best[addr].liquidity?.usd || 0)) best[addr] = p;
          }

          for (const w of watchlist) {
            const p = best[w.mint];
            if (p) {
              w.currentPrice = p.priceUsd ? parseFloat(p.priceUsd) : 0;
              w.change24h = p.priceChange?.h24 || 0;
            }
          }
        }
        saveWatchlist();
        renderWatchlist();
      } catch (e) {
        console.error('Watchlist refresh error:', e);
      }
    }

    // ═══════ EMBEDDED CHART ═══════
    function openChart(mint, symbol) {
      $('chart-embed').src = `https://dexscreener.com/${getChain().dexScreenerChain}/${mint}?embed=1&theme=dark&trades=0&info=0`;
      $('chart-token-label').textContent = symbol ? `$${symbol}` : mint.slice(0, 8);
      // Wire up action buttons
      $('chart-buy-btn').onclick = () => { setMode('trade'); $('tr-mint').value = mint; onMintInput(mint); };
      $('chart-scan-btn').onclick = () => { $('intel-mint').value = mint; setMode('intel'); fetchTokenIntel(); };
      $('chart-solscan-btn').onclick = () => window.open(getChain().explorerAddr + mint, '_blank');
      $('chart-watch-btn').onclick = () => addToWatchlist(mint);
      setMode('chart');
    }

    // ═══════ BUNDLE CHECKER ═══════
    let bundleScanning = false;

    function bundleLog(msg, type = 'info') {
      const log = $('bundle-log');
      if (!log) return;
      log.style.display = 'block';
      const colors = { info: 'var(--text-muted)', warn: '#fbbf24', error: 'var(--red)', ok: 'var(--green)' };
      const dotColors = { info: 'var(--text-ghost)', warn: '#fbbf24', error: 'var(--red)', ok: 'var(--green)' };
      log.innerHTML += `<div class="bundle-log-line"><span class="bundle-log-dot" style="background:${dotColors[type]}"></span><span style="color:${colors[type]}">${msg}</span></div>`;
      log.scrollTop = log.scrollHeight;
    }

    async function runBundleCheck() {
      const mint = $('bundle-mint').value.trim();
      if (!mint || !/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(mint)) {
        toast('Enter a valid Solana mint address'); return;
      }
      if (bundleScanning) return;
      bundleScanning = true;
      $('bundle-go').disabled = true;
      $('bundle-go').textContent = '⏳ SCANNING...';
      $('bundle-log').style.display = 'block';
      $('bundle-log').innerHTML = '';
      $('bundle-results').innerHTML = '<div class="bundle-empty"><div class="bundle-empty-icon" style="animation:pulse 1s infinite;">🔍</div><div class="bundle-empty-text">Analyzing token launch...</div></div>';

      const result = {
        mint,
        name: '', symbol: '', age: '', liquidity: 0, marketCap: 0, dexId: '',
        totalSupply: 0,
        holders: [],
        top5Pct: 0, top10Pct: 0,
        creationSlot: 0,
        sameSlotTxs: 0,
        earlyBuyers: [],
        freshWallets: 0,
        commonFunders: [],
        score: 0,
        flags: [],
      };

      try {
        // ── Step 1: Token Info from DexScreener ──
        bundleLog('Fetching token info from DexScreener...', 'info');
        try {
          const dsRes = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`);
          const dsData = await dsRes.json();
          const pairs = (dsData.pairs || []).filter(p => p.chainId === 'solana');
          if (pairs.length > 0) {
            const pair = pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0))[0];
            result.name = pair.baseToken?.name || '';
            result.symbol = pair.baseToken?.symbol || '';
            result.liquidity = pair.liquidity?.usd || 0;
            result.marketCap = pair.marketCap || pair.fdv || 0;
            result.dexId = pair.dexId || '';
            if (pair.pairCreatedAt) {
              const ageMs = Date.now() - pair.pairCreatedAt;
              if (ageMs < 3600000) result.age = Math.floor(ageMs / 60000) + 'm';
              else if (ageMs < 86400000) result.age = Math.floor(ageMs / 3600000) + 'h';
              else result.age = Math.floor(ageMs / 86400000) + 'd';
            }
            bundleLog(`Token: ${result.name} ($${result.symbol})`, 'ok');
          } else {
            bundleLog('No DexScreener data — may be very new or delisted', 'warn');
          }
        } catch (e) { bundleLog('DexScreener lookup failed: ' + e.message, 'warn'); }
        await delay(200);

        // ── Step 2: Holder Concentration ──
        bundleLog('Analyzing holder concentration...', 'info');
        try {
          const conn = await getWorkingConnection();
          const mintPubkey = new solanaWeb3.PublicKey(mint);
          const [largestAccounts, supplyRes] = await Promise.all([
            conn.getTokenLargestAccounts(mintPubkey),
            conn.getTokenSupply(mintPubkey),
          ]);
          result.totalSupply = supplyRes.value.uiAmount || 1;

          for (let i = 0; i < Math.min(largestAccounts.value.length, 20); i++) {
            const acc = largestAccounts.value[i];
            const pct = (acc.uiAmount / result.totalSupply) * 100;
            result.holders.push({
              address: acc.address.toString(),
              amount: acc.uiAmount,
              pct: pct,
            });
          }

          result.top5Pct = result.holders.slice(0, 5).reduce((s, h) => s + h.pct, 0);
          result.top10Pct = result.holders.slice(0, 10).reduce((s, h) => s + h.pct, 0);
          bundleLog(`Top 5 holders: ${result.top5Pct.toFixed(1)}% | Top 10: ${result.top10Pct.toFixed(1)}%`, result.top5Pct > 50 ? 'warn' : 'ok');

          if (result.top5Pct > 60) result.flags.push({ icon: '🚩', text: `Top 5 wallets hold <strong>${result.top5Pct.toFixed(1)}%</strong> of supply — extreme concentration` });
          else if (result.top5Pct > 40) result.flags.push({ icon: '⚠️', text: `Top 5 wallets hold <strong>${result.top5Pct.toFixed(1)}%</strong> — high concentration` });
        } catch (e) {
          bundleLog('Holder analysis failed: ' + e.message, 'error');
        }
        await delay(300);

        // ── Step 3: Get Earliest Transactions (Bundle Detection) ──
        bundleLog('Scanning for early transactions...', 'info');
        let allSigs = [];
        try {
          const conn = await getWorkingConnection();
          const mintPubkey = new solanaWeb3.PublicKey(mint);

          // Paginate backwards to find oldest transactions
          let before = undefined;
          let pages = 0;
          while (pages < 10) { // max 10 pages = 1000 sigs
            const opts = { limit: 100 };
            if (before) opts.before = before;
            const sigs = await conn.getSignaturesForAddress(mintPubkey, opts);
            if (sigs.length === 0) break;
            allSigs = allSigs.concat(sigs);
            before = sigs[sigs.length - 1].signature;
            pages++;
            if (sigs.length < 100) break; // reached the end
            await delay(200);
          }

          bundleLog(`Found ${allSigs.length} total transactions`, 'info');

          // Sort by slot (oldest first)
          allSigs.sort((a, b) => (a.slot || 0) - (b.slot || 0));

          if (allSigs.length > 0) {
            result.creationSlot = allSigs[0].slot;
            const firstSlot = allSigs[0].slot;

            // Count transactions in the first few slots
            const sameSlot = allSigs.filter(s => s.slot === firstSlot);
            const nearSlots = allSigs.filter(s => s.slot <= firstSlot + 2);
            result.sameSlotTxs = sameSlot.length;

            bundleLog(`Creation slot: ${firstSlot}`, 'info');
            bundleLog(`Same-slot transactions: ${sameSlot.length}`, sameSlot.length > 3 ? 'warn' : 'ok');
            bundleLog(`First 3 slots: ${nearSlots.length} transactions`, nearSlots.length > 8 ? 'warn' : 'ok');

            if (sameSlot.length >= 5) {
              result.flags.push({ icon: '🚩', text: `<strong>${sameSlot.length} transactions</strong> in creation slot — strong bundle indicator (Jito bundle)` });
            } else if (sameSlot.length >= 3) {
              result.flags.push({ icon: '⚠️', text: `<strong>${sameSlot.length} transactions</strong> in creation slot — possible bundle` });
            }

            if (nearSlots.length >= 10) {
              result.flags.push({ icon: '⚠️', text: `<strong>${nearSlots.length} txs</strong> in first 3 slots — coordinated buying activity` });
            }
          }
        } catch (e) {
          bundleLog('Transaction scan failed: ' + e.message, 'error');
        }
        await delay(300);

        // ── Step 4: Parse Early Buyers ──
        bundleLog('Identifying early buyer wallets...', 'info');
        const earlyTxSigs = allSigs.slice(0, 12); // first 12 transactions
        const buyerWallets = new Set();

        for (let i = 0; i < Math.min(earlyTxSigs.length, 12); i++) {
          try {
            const tx = await rpcGetTransaction(earlyTxSigs[i].signature);
            if (!tx || !tx.meta || tx.meta.err) continue;

            // Find wallets that received tokens
            const postBalances = tx.meta.postTokenBalances || [];
            const preBalances = tx.meta.preTokenBalances || [];

            for (const post of postBalances) {
              if (post.mint === mint && post.owner) {
                const pre = preBalances.find(p => p.owner === post.owner && p.mint === mint);
                const preAmt = pre?.uiTokenAmount?.uiAmount || 0;
                const postAmt = post.uiTokenAmount?.uiAmount || 0;
                if (postAmt > preAmt) {
                  buyerWallets.add(post.owner);
                }
              }
            }
            await delay(250);
          } catch (e) { /* skip */ }
        }

        result.earlyBuyers = [...buyerWallets];
        bundleLog(`Found ${result.earlyBuyers.length} unique early buyers`, result.earlyBuyers.length > 5 ? 'warn' : 'ok');
        await delay(200);

        // ── Step 5: Check Wallet Ages (Fresh Wallet Detection) ──
        if (result.earlyBuyers.length > 0) {
          bundleLog('Checking wallet ages...', 'info');
          let freshCount = 0;
          const walletDetails = [];

          for (let i = 0; i < Math.min(result.earlyBuyers.length, 8); i++) {
            try {
              const conn = await getWorkingConnection();
              const walletPk = new solanaWeb3.PublicKey(result.earlyBuyers[i]);
              const sigs = await conn.getSignaturesForAddress(walletPk, { limit: 10 });

              const isFresh = sigs.length <= 5;
              if (isFresh) freshCount++;

              walletDetails.push({
                address: result.earlyBuyers[i],
                txCount: sigs.length,
                isFresh,
              });

              await delay(250);
            } catch (e) { /* skip */ }
          }

          result.freshWallets = freshCount;
          const freshPct = walletDetails.length > 0 ? (freshCount / walletDetails.length * 100) : 0;
          bundleLog(`Fresh wallets (≤5 txs): ${freshCount}/${walletDetails.length} (${freshPct.toFixed(0)}%)`, freshPct > 50 ? 'warn' : 'ok');

          if (freshPct >= 60) {
            result.flags.push({ icon: '🚩', text: `<strong>${freshPct.toFixed(0)}%</strong> of early buyers are fresh wallets (≤5 transactions) — likely sybil wallets` });
          } else if (freshPct >= 30) {
            result.flags.push({ icon: '⚠️', text: `<strong>${freshPct.toFixed(0)}%</strong> of early buyers are relatively new wallets` });
          }
        }
        await delay(200);

        // ── Step 6: Check Common Funding Sources ──
        if (result.earlyBuyers.length >= 2) {
          bundleLog('Tracing funding sources...', 'info');
          const funders = {};

          for (let i = 0; i < Math.min(result.earlyBuyers.length, 6); i++) {
            try {
              const conn = await getWorkingConnection();
              const walletPk = new solanaWeb3.PublicKey(result.earlyBuyers[i]);
              const sigs = await conn.getSignaturesForAddress(walletPk, { limit: 5 });

              // Check last few transactions for SOL transfers in
              for (const sig of sigs.slice(0, 3)) {
                const tx = await rpcGetTransaction(sig.signature);
                if (!tx || !tx.meta || tx.meta.err) continue;

                // Look at SOL balance changes to find who funded this wallet
                const accountKeys = tx.transaction?.message?.accountKeys || [];
                const preSOL = tx.meta.preBalances || [];
                const postSOL = tx.meta.postBalances || [];

                for (let k = 0; k < accountKeys.length; k++) {
                  const key = typeof accountKeys[k] === 'string' ? accountKeys[k] : accountKeys[k]?.pubkey?.toString() || '';
                  if (key === result.earlyBuyers[i]) continue;
                  // If this account sent SOL (balance decreased) and our wallet received
                  const sentSOL = (preSOL[k] || 0) - (postSOL[k] || 0);
                  if (sentSOL > 0.01 * 1e9) { // sent > 0.01 SOL
                    if (!funders[key]) funders[key] = [];
                    if (!funders[key].includes(result.earlyBuyers[i])) {
                      funders[key].push(result.earlyBuyers[i]);
                    }
                  }
                }
                await delay(200);
              }
            } catch (e) { /* skip */ }
          }

          // Find common funders (funded 2+ early buyers)
          for (const [funder, funded] of Object.entries(funders)) {
            if (funded.length >= 2) {
              result.commonFunders.push({ funder, funded: funded.length });
            }
          }

          if (result.commonFunders.length > 0) {
            const topFunder = result.commonFunders.sort((a, b) => b.funded - a.funded)[0];
            bundleLog(`⚠ Common funder detected! ${topFunder.funder.slice(0, 6)}... funded ${topFunder.funded} early buyers`, 'warn');
            result.flags.push({ icon: '🚩', text: `<strong>Common funder detected:</strong> wallet ${topFunder.funder.slice(0, 6)}...${topFunder.funder.slice(-4)} funded <strong>${topFunder.funded} early buyers</strong> — strong bundle evidence` });
          } else {
            bundleLog('No common funding sources found', 'ok');
          }
        }

        // ── Step 7: Calculate Risk Score ──
        bundleLog('Calculating bundle risk score...', 'info');

        // Same-slot transactions (0-35)
        if (result.sameSlotTxs >= 8) result.score += 35;
        else if (result.sameSlotTxs >= 5) result.score += 28;
        else if (result.sameSlotTxs >= 3) result.score += 18;
        else if (result.sameSlotTxs >= 2) result.score += 8;

        // Holder concentration (0-20)
        if (result.top5Pct >= 70) result.score += 20;
        else if (result.top5Pct >= 50) result.score += 15;
        else if (result.top5Pct >= 35) result.score += 8;

        // Fresh wallets (0-20)
        const freshRatio = result.earlyBuyers.length > 0 ? result.freshWallets / Math.min(result.earlyBuyers.length, 8) : 0;
        if (freshRatio >= 0.7) result.score += 20;
        else if (freshRatio >= 0.5) result.score += 14;
        else if (freshRatio >= 0.3) result.score += 6;

        // Common funders (0-25)
        if (result.commonFunders.length > 0) {
          const maxFunded = Math.max(...result.commonFunders.map(f => f.funded));
          if (maxFunded >= 4) result.score += 25;
          else if (maxFunded >= 3) result.score += 20;
          else if (maxFunded >= 2) result.score += 12;
        }

        result.score = Math.min(result.score, 100);

        const scoreClass = result.score <= 25 ? 'safe' : result.score <= 55 ? 'warn' : 'danger';
        const scoreLabel = result.score <= 25 ? 'LIKELY CLEAN' : result.score <= 55 ? 'SUSPICIOUS' : 'LIKELY BUNDLED';

        bundleLog(`Bundle risk score: ${result.score}/100 — ${scoreLabel}`, result.score > 55 ? 'error' : result.score > 25 ? 'warn' : 'ok');

        // Add positive flags if clean
        if (result.sameSlotTxs <= 1) result.flags.push({ icon: '✅', text: 'Only 1 transaction in creation slot — no bundle detected' });
        if (freshRatio < 0.2 && result.earlyBuyers.length > 2) result.flags.push({ icon: '✅', text: 'Early buyers are established wallets with transaction history' });
        if (result.commonFunders.length === 0 && result.earlyBuyers.length >= 2) result.flags.push({ icon: '✅', text: 'No common funding sources found among early buyers' });
        if (result.top5Pct < 30) result.flags.push({ icon: '✅', text: `Healthy holder distribution — top 5 hold only ${result.top5Pct.toFixed(1)}%` });

        // ── Render Results ──
        renderBundleResults(result, scoreClass, scoreLabel);

      } catch (e) {
        bundleLog('Fatal error: ' + e.message, 'error');
        $('bundle-results').innerHTML = `<div class="bundle-empty"><div class="bundle-empty-icon">❌</div><div class="bundle-empty-text">Scan failed: ${e.message}<br>Check the mint address and try again.</div></div>`;
      }

      bundleScanning = false;
      $('bundle-go').disabled = false;
      $('bundle-go').textContent = '🔍 SCAN';
    }

    function renderBundleResults(r, scoreClass, scoreLabel) {
      const fmtUsd = (n) => {
        if (n >= 1e9) return '$' + (n / 1e9).toFixed(1) + 'B';
        if (n >= 1e6) return '$' + (n / 1e6).toFixed(1) + 'M';
        if (n >= 1e3) return '$' + (n / 1e3).toFixed(1) + 'K';
        return '$' + n.toFixed(0);
      };

      let flagsHtml = r.flags.map(f => `
        <div class="bundle-flag">
          <span class="bundle-flag-icon">${f.icon}</span>
          <span class="bundle-flag-text">${f.text}</span>
        </div>
      `).join('');

      // Build top holders HTML
      let holdersHtml = '';
      for (let i = 0; i < Math.min(r.holders.length, 10); i++) {
        const h = r.holders[i];
        const pctColor = h.pct > 10 ? 'var(--red)' : h.pct > 5 ? 'var(--yellow)' : 'var(--text-secondary)';
        holdersHtml += `
          <div class="bundle-wallet-row">
            <span style="font-size:9px;color:var(--text-ghost);width:16px;">#${i + 1}</span>
            <span class="bundle-wallet-addr" onclick="navigator.clipboard.writeText('${h.address}');toast('📋 Copied!')" title="${h.address}">${h.address.slice(0, 6)}...${h.address.slice(-4)}</span>
            <span class="bundle-wallet-pct" style="color:${pctColor}">${h.pct.toFixed(1)}%</span>
          </div>`;
      }

      // Build early buyers HTML
      let buyersHtml = '';
      if (r.earlyBuyers.length > 0) {
        for (let i = 0; i < Math.min(r.earlyBuyers.length, 8); i++) {
          const addr = r.earlyBuyers[i];
          const isHolder = r.holders.some(h => h.address.includes(addr.slice(0, 20)));
          buyersHtml += `
            <div class="bundle-wallet-row">
              <span style="font-size:9px;color:var(--text-ghost);width:16px;">${i + 1}</span>
              <span class="bundle-wallet-addr" onclick="navigator.clipboard.writeText('${addr}');toast('📋 Copied!')" title="${addr}">${addr.slice(0, 6)}...${addr.slice(-4)}</span>
              ${isHolder ? '<span class="bundle-wallet-tag bundled">HOLDER</span>' : ''}
            </div>`;
        }
      }

      // Common funders HTML
      let fundersHtml = '';
      if (r.commonFunders.length > 0) {
        for (const cf of r.commonFunders) {
          fundersHtml += `
            <div class="bundle-wallet-row">
              <span class="bundle-wallet-addr" onclick="navigator.clipboard.writeText('${cf.funder}');toast('📋 Copied!')" title="${cf.funder}">
                ${cf.funder.slice(0, 6)}...${cf.funder.slice(-4)}
              </span>
              <span class="bundle-wallet-tag bundled">FUNDED ${cf.funded} BUYERS</span>
            </div>`;
        }
      }

      // Verdict message
      let verdictMsg = '';
      if (r.score <= 25) verdictMsg = '✅ This token launch appears clean. No strong indicators of bundling or coordinated fake buying detected.';
      else if (r.score <= 55) verdictMsg = '⚠️ Some suspicious signals detected. The launch may have involved coordinated buying or wallet creation. Proceed with caution and do additional research.';
      else verdictMsg = '🚩 Strong indicators of a bundled launch. The dev likely used multiple wallets to fake volume and holder count. High risk of manipulation — trade with extreme caution.';

      $('bundle-results').innerHTML = `
        <!-- Score Card -->
        <div class="bundle-card">
          <div class="bundle-card-header">
            <div>
              <div class="bundle-token-name">${r.name || 'Unknown Token'}</div>
              <div class="bundle-token-ticker">${r.symbol ? '$' + r.symbol : ''} ${r.dexId ? '· ' + r.dexId.toUpperCase() : ''} ${r.age ? '· ' + r.age + ' old' : ''}</div>
            </div>
            <div class="bundle-score-wrap">
              <div class="bundle-score ${scoreClass}">${r.score}</div>
              <div class="bundle-score-label ${scoreClass}">${scoreLabel}</div>
            </div>
          </div>
          <div class="bundle-stat-grid">
            <div class="bundle-stat"><div class="bundle-stat-label">Market Cap</div><div class="bundle-stat-val">${r.marketCap ? fmtUsd(r.marketCap) : '—'}</div></div>
            <div class="bundle-stat"><div class="bundle-stat-label">Liquidity</div><div class="bundle-stat-val">${r.liquidity ? fmtUsd(r.liquidity) : '—'}</div></div>
            <div class="bundle-stat"><div class="bundle-stat-label">Same-Slot TXs</div><div class="bundle-stat-val" style="color:${r.sameSlotTxs >= 5 ? 'var(--red)' : r.sameSlotTxs >= 3 ? 'var(--yellow)' : 'var(--green)'}">${r.sameSlotTxs}</div></div>
            <div class="bundle-stat"><div class="bundle-stat-label">Early Buyers</div><div class="bundle-stat-val">${r.earlyBuyers.length}</div></div>
          </div>
        </div>

        <!-- Verdict -->
        <div class="bundle-verdict ${scoreClass}">
          ${verdictMsg}
        </div>

        <!-- Flags -->
        ${r.flags.length ? `
        <div class="bundle-section">
          <div class="bundle-stitle">🔍 Analysis Findings</div>
          ${flagsHtml}
        </div>` : ''}

        <!-- Common Funders -->
        ${r.commonFunders.length ? `
        <div class="bundle-section">
          <div class="bundle-stitle">🔗 Common Funding Sources</div>
          ${fundersHtml}
        </div>` : ''}

        <!-- Top Holders -->
        ${holdersHtml ? `
        <div class="bundle-section">
          <div class="bundle-stitle">👥 Top Holders (${r.top5Pct.toFixed(1)}% in top 5)</div>
          ${holdersHtml}
        </div>` : ''}

        <!-- Early Buyers -->
        ${buyersHtml ? `
        <div class="bundle-section">
          <div class="bundle-stitle">⚡ Early Buyer Wallets (${r.freshWallets} fresh)</div>
          ${buyersHtml}
        </div>` : ''}

        <!-- Actions -->
        <div style="padding:8px 14px 14px;display:flex;gap:6px;">
          <button class="tk-btn buy" onclick="$('intel-mint').value='${r.mint}';setMode('intel');fetchTokenIntel();">⬡ Full Intel</button>
          <button class="tk-btn" onclick="window.open('https://solscan.io/token/${r.mint}','_blank')">🔍 Solscan</button>
          <button class="tk-btn" onclick="navigator.clipboard.writeText('${r.mint}');toast('📋 Copied!')">📋 Copy CA</button>
        </div>
      `;
    }

    // Bundle checker keyboard listener
    $('bundle-mint').addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); runBundleCheck(); }
    });

    // ═══════ PERPS TERMINAL ═══════
    let perpsMarket = 'SOL';
    let perpsSide = 'long';
    let perpsOrderType = 'market';
    let perpsLeverage = 5;
    let perpsTimeframe = '60';
    let perpsPrices = { SOL: 0, BTC: 0, ETH: 0 };
    let perpsPrev = { SOL: 0, BTC: 0, ETH: 0 };
    let perps24h = { SOL: {}, BTC: {}, ETH: {} };
    let perpsWs = null;
    let perpsPositions = lsGetJSON('ghost-perps-positions', []);
    let perpsWsRetries = 0;

    // ═══════ JUPITER PERPS ON-CHAIN CONSTANTS ═══════
    const PERPS_PROGRAM_ID = 'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu';
    const PERPS_POOL = '5BUwFW4nRbftYTDMbgxykoFWqWHPzahFSNAaaaJtVKsq';
    const TOKEN_PROGRAM = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
    const ATA_PROGRAM = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL';
    const SYSTEM_PROGRAM = '11111111111111111111111111111111';

    const PERPS_CUSTODIES = {
      SOL:  '7xS2gz2bTp3fwCC7knJvUWTEU9Tycczu6VhJYKgi1wdz',
      ETH:  'AQCGyheWPLeo6Qp9WpYS9m3Qj479t7R636N9ey1rEjEn',
      BTC:  '5Pv3gM9JrFFH883SWAhvJC9RPYmo8UNxuFtv5bMMALkm',
      USDC: 'G18jKKXQwBbrHeiK3C9MRXhkHsLHf7XgCSisykV46EZa',
      USDT: '4vkNeXiYEUizLdrpdPS1eC2mccyM4NUPRtERrk6ZETkk',
    };

    const PERPS_MINTS = {
      SOL:  'So11111111111111111111111111111111111111112',
      ETH:  '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs',
      BTC:  '3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh',
      USDC: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      USDT: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB',
    };

    const PERPS_SYMBOLS = {
      SOL: { binance: 'SOLUSDT', jup: 'SOL', decimals: 2, color: '#9945FF', tokenDecimals: 9, collateralLong: 'SOL', collateralShort: 'USDC' },
      BTC: { binance: 'BTCUSDT', jup: 'BTC', decimals: 1, color: '#f7931a', tokenDecimals: 8, collateralLong: 'BTC', collateralShort: 'USDC' },
      ETH: { binance: 'ETHUSDT', jup: 'ETH', decimals: 2, color: '#627eea', tokenDecimals: 8, collateralLong: 'ETH', collateralShort: 'USDC' },
    };

    // Collateral options available per market/side (mirrors Jupiter Perps)
    const COLLATERAL_OPTIONS = {
      SOL: { long: ['SOL', 'USDC', 'USDT'], short: ['USDC', 'USDT'] },
      BTC: { long: ['BTC', 'SOL', 'USDC', 'USDT'], short: ['USDC', 'USDT'] },
      ETH: { long: ['ETH', 'SOL', 'USDC', 'USDT'], short: ['USDC', 'USDT'] },
    };

    const COLLATERAL_COLORS = {
      SOL: '#9945FF', BTC: '#f7931a', ETH: '#627eea', USDC: '#2775ca', USDT: '#26a17b',
    };

    // Stablecoins are denominated in USD
    const STABLECOINS = ['USDC', 'USDT'];

    let perpsCollateralToken = 'SOL';

    let perpsPnlInterval = null;
    function initPerpsPanel() {
      connectPerpsWs();
      loadPerpsChart();
      buildCollatDropdown();
      updatePerpsOrder();
      renderPerpsPositions();
      fetchPerps24hStats();
      if (perpsPnlInterval) clearInterval(perpsPnlInterval);
      perpsPnlInterval = setInterval(() => {
        const open = perpsPositions.filter(p => p.status === 'open' || p.status === 'keeper_pending');
        if (open.length > 0) {
          renderPerpsPositions();
          // Periodic liquidation check independent of WebSocket
          for (const key of Object.keys(PERPS_SYMBOLS)) {
            if (perpsPrices[key]) checkPerpsLiquidations(key);
          }
        }
      }, 2000);
    }

    // ── Binance WebSocket for Live Prices ──
    function connectPerpsWs() {
      if (perpsWs && perpsWs.readyState < 2) return;

      // Try multiple WebSocket endpoints
      const wsEndpoints = [
        'wss://stream.binance.com:9443',
        'wss://stream.binance.com:443',
        'wss://data-stream.binance.vision',
      ];

      function tryConnect(idx) {
        if (idx >= wsEndpoints.length) {
          console.warn('All WS endpoints failed, using REST polling');
          toast('⚠️ Live prices degraded — using 5s polling', 5000);
          startPerpsPolling();
          return;
        }

        try {
          const streams = Object.values(PERPS_SYMBOLS).map(s => `${s.binance.toLowerCase()}@ticker`).join('/');
          perpsWs = new WebSocket(`${wsEndpoints[idx]}/stream?streams=${streams}`);

          const timeout = setTimeout(() => {
            if (perpsWs.readyState !== 1) {
              perpsWs.close();
              tryConnect(idx + 1);
            }
          }, 5000);

          perpsWs.onopen = () => {
            clearTimeout(timeout);
            perpsWsRetries = 0;
            const el = $('perps-connection');
            if (el) { el.style.color = 'var(--green)'; el.textContent = '● LIVE'; }
          };

          perpsWs.onmessage = (e) => {
            try {
              const msg = JSON.parse(e.data);
              if (!msg.data) return;
              const d = msg.data;
              const sym = d.s;

              for (const [key, cfg] of Object.entries(PERPS_SYMBOLS)) {
                if (cfg.binance === sym) {
                  perpsPrev[key] = perpsPrices[key];
                  perpsPrices[key] = parseFloat(d.c);
                  perps24h[key] = {
                    change: parseFloat(d.P),
                    high: parseFloat(d.h),
                    low: parseFloat(d.l),
                    volume: parseFloat(d.q),
                  };
                  updatePerpsMarketPrice(key);
                  if (key === perpsMarket) updatePerpsDisplay();
                  checkPerpsLiquidations(key);
                  break;
                }
              }
            } catch (err) {}
          };

          perpsWs.onclose = () => {
            clearTimeout(timeout);
            const el = $('perps-connection');
            if (el) { el.style.color = 'var(--yellow)'; el.textContent = '○ RECONNECTING'; }
            if (perpsWsRetries < 5) {
              perpsWsRetries++;
              setTimeout(() => connectPerpsWs(), 3000 * perpsWsRetries);
            } else {
              startPerpsPolling();
            }
          };

          perpsWs.onerror = () => {
            clearTimeout(timeout);
            perpsWs.close();
            tryConnect(idx + 1);
          };
        } catch (e) {
          tryConnect(idx + 1);
        }
      }

      tryConnect(0);
    }

    // REST polling fallback if WebSocket fails
    let perpsPollingTimer = null;
    function startPerpsPolling() {
      if (perpsPollingTimer) return;
      const el = $('perps-connection');
      if (el) { el.style.color = 'var(--yellow)'; el.textContent = '● POLLING'; }
      fetchPerps24hStats();
      perpsPollingTimer = setInterval(fetchPerps24hStats, 5000);
    }

    function stopPerpsPolling() {
      if (perpsPollingTimer) { clearInterval(perpsPollingTimer); perpsPollingTimer = null; }
    }

    function disconnectPerpsWs() {
      stopPerpsPolling();
      if (perpsWs) { perpsWs.close(); perpsWs = null; }
    }

    function fetchPerps24hStats() {
      // Try Binance REST first, then CoinGecko as fallback
      let loaded = 0;
      const total = Object.keys(PERPS_SYMBOLS).length;

      for (const [key, cfg] of Object.entries(PERPS_SYMBOLS)) {
        fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${cfg.binance}`)
          .then(r => { if (!r.ok) throw new Error('Binance fail'); return r.json(); })
          .then(d => {
            perpsPrices[key] = parseFloat(d.lastPrice);
            perps24h[key] = {
              change: parseFloat(d.priceChangePercent),
              high: parseFloat(d.highPrice),
              low: parseFloat(d.lowPrice),
              volume: parseFloat(d.quoteVolume),
            };
            updatePerpsMarketPrice(key);
            if (key === perpsMarket) updatePerpsDisplay();
            loaded++;
          })
          .catch(() => {
            // Fallback: try data-api.binance.vision
            fetch(`https://data-api.binance.vision/api/v3/ticker/24hr?symbol=${cfg.binance}`)
              .then(r => r.json())
              .then(d => {
                perpsPrices[key] = parseFloat(d.lastPrice);
                perps24h[key] = {
                  change: parseFloat(d.priceChangePercent),
                  high: parseFloat(d.highPrice),
                  low: parseFloat(d.lowPrice),
                  volume: parseFloat(d.quoteVolume),
                };
                updatePerpsMarketPrice(key);
                if (key === perpsMarket) updatePerpsDisplay();
                loaded++;
              })
              .catch(() => {
                loaded++;
                // Final fallback: CoinGecko
                if (loaded >= total && perpsPrices.SOL === 0) fetchFromCoinGecko();
              });
          });
      }
    }

    function fetchFromCoinGecko() {
      fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana,bitcoin,ethereum&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true&include_24hr_high=true&include_24hr_low=true')
        .then(r => r.json())
        .then(d => {
          const map = { SOL: 'solana', BTC: 'bitcoin', ETH: 'ethereum' };
          for (const [key, cgId] of Object.entries(map)) {
            if (d[cgId]) {
              perpsPrices[key] = d[cgId].usd || 0;
              perps24h[key] = {
                change: d[cgId].usd_24h_change || 0,
                high: d[cgId].usd_24h_high || 0,
                low: d[cgId].usd_24h_low || 0,
                volume: d[cgId].usd_24h_vol || 0,
              };
              updatePerpsMarketPrice(key);
              if (key === perpsMarket) updatePerpsDisplay();
            }
          }
          const el = $('perps-connection');
          if (el) { el.style.color = 'var(--yellow)'; el.textContent = '● CG'; }
        })
        .catch(() => {
          const el = $('perps-connection');
          if (el) { el.style.color = 'var(--red)'; el.textContent = '○ OFFLINE'; }
        });
    }

    function updatePerpsMarketPrice(key) {
      const el = $('perps-mp-' + key);
      if (!el) return;
      const price = perpsPrices[key];
      const chg = perps24h[key]?.change || 0;
      const cfg = PERPS_SYMBOLS[key];
      el.textContent = '$' + formatPerpsPrice(price, cfg.decimals);
      el.className = 'perps-market-price ' + (chg >= 0 ? 'up' : 'down');
    }

    function updatePerpsDisplay() {
      const price = perpsPrices[perpsMarket];
      const prev = perpsPrev[perpsMarket];
      const stats = perps24h[perpsMarket] || {};
      const cfg = PERPS_SYMBOLS[perpsMarket];

      // Big price with flash animation
      const bigEl = $('perps-big-price');
      if (bigEl) {
        bigEl.textContent = '$' + formatPerpsPrice(price, cfg.decimals);
        if (prev && price !== prev) {
          bigEl.classList.remove('flash-green', 'flash-red');
          void bigEl.offsetWidth; // force reflow
          bigEl.classList.add(price > prev ? 'flash-green' : 'flash-red');
          setTimeout(() => bigEl.classList.remove('flash-green', 'flash-red'), 800);
        }
      }

      // 24h stats
      const chgEl = $('perps-24h-chg');
      if (chgEl && stats.change !== undefined) {
        const pct = stats.change;
        chgEl.textContent = (pct >= 0 ? '+' : '') + pct.toFixed(2) + '%';
        chgEl.style.color = pct >= 0 ? 'var(--green)' : 'var(--red)';
      }
      const highEl = $('perps-24h-high');
      if (highEl && stats.high) highEl.textContent = '$' + formatPerpsPrice(stats.high, cfg.decimals);
      const lowEl = $('perps-24h-low');
      if (lowEl && stats.low) lowEl.textContent = '$' + formatPerpsPrice(stats.low, cfg.decimals);

      // Update order summary
      updatePerpsOrder();
    }

    function formatPerpsPrice(price, decimals) {
      if (!price || isNaN(price)) return '—';
      if (price >= 1000) return price.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
      if (price >= 1) return price.toFixed(decimals);
      return price.toFixed(4);
    }

    // ── Market Selection ──
    function selectPerpsMarket(market) {
      perpsMarket = market;
      document.querySelectorAll('.perps-market-btn').forEach(b =>
        b.classList.toggle('active', b.dataset.market === market)
      );
      loadPerpsChart();
      updatePerpsDisplay();
      updatePerpsOrder();

      // Update collateral token options for new market
      const options = COLLATERAL_OPTIONS[market]?.[perpsSide] || ['USDC'];
      if (!options.includes(perpsCollateralToken)) {
        perpsCollateralToken = options[0];
      }
      buildCollatDropdown();
    }

    // ── Chart ──
    function loadPerpsChart() {
      const iframe = $('perps-chart-iframe');
      if (!iframe) return;
      const sym = PERPS_SYMBOLS[perpsMarket].binance;
      iframe.src = `https://s.tradingview.com/widgetembed/?frameElementId=perps-chart-iframe&symbol=BINANCE%3A${sym}&interval=${perpsTimeframe}&hidesidetoolbar=1&hidetoptoolbar=0&symboledit=0&saveimage=0&toolbarbg=060910&theme=dark&style=1&timezone=Etc%2FUTC&withdateranges=0&locale=en`;
    }

    function setPerpsTimeframe(tf) {
      perpsTimeframe = tf;
      document.querySelectorAll('.perps-tf-btn').forEach(b => b.classList.remove('active'));
      event.target.classList.add('active');
      loadPerpsChart();
    }

    // ── Trading Controls ──
    function setPerpsPosition(side) {
      perpsSide = side;
      $('perps-long-btn').className = 'perps-side-btn' + (side === 'long' ? ' long-active' : '');
      $('perps-short-btn').className = 'perps-side-btn' + (side === 'short' ? ' short-active' : '');

      const execBtn = $('perps-exec-btn');
      if (execBtn) {
        execBtn.className = 'perps-exec ' + (side === 'long' ? 'long-btn' : 'short-btn');
      }

      // Update collateral token label based on side
      const options = COLLATERAL_OPTIONS[perpsMarket]?.[side] || ['USDC'];
      if (!options.includes(perpsCollateralToken)) {
        perpsCollateralToken = options[0];
      }
      buildCollatDropdown();

      updatePerpsOrder();
    }

    function setPerpsOrderType(type) {
      perpsOrderType = type;
      document.querySelectorAll('.perps-otype-btn').forEach(b => b.classList.remove('active'));
      event.target.classList.add('active');

      const limitRow = $('perps-limit-row');
      if (limitRow) limitRow.className = 'perps-limit-row' + (type === 'limit' ? ' visible' : '');
      updatePerpsOrder();
    }

    function updatePerpsLeverage(val) {
      perpsLeverage = parseInt(val);
      const levEl = $('perps-lev-val');
      if (levEl) levEl.textContent = perpsLeverage + 'x';

      // Update preset buttons
      document.querySelectorAll('.perps-lev-preset').forEach(b => b.classList.remove('active'));

      // Color the leverage value
      if (levEl) {
        if (perpsLeverage <= 5) levEl.style.color = 'var(--green)';
        else if (perpsLeverage <= 25) levEl.style.color = '#fbbf24';
        else levEl.style.color = 'var(--red)';
      }

      updatePerpsOrder();
    }

    function setPerpsLeverage(val) {
      perpsLeverage = val;
      $('perps-lev-slider').value = val;
      updatePerpsLeverage(val);
      document.querySelectorAll('.perps-lev-preset').forEach(b => {
        b.classList.toggle('active', parseInt(b.textContent) === val);
      });
    }

    function setPerpsCollateral(val) {
      $('perps-collateral').value = val;
      updatePerpsOrder();
    }

    // ── Collateral Token Selector (inline buttons) ──
    function buildCollatDropdown() {
      const options = COLLATERAL_OPTIONS[perpsMarket]?.[perpsSide] || ['USDC'];
      const row = $('perps-token-row');
      const tokenLabel = $('perps-collat-token');
      if (!row || !tokenLabel) return;

      tokenLabel.textContent = perpsCollateralToken;

      row.innerHTML = options.map(token => `
        <button class="perps-token-btn ${token === perpsCollateralToken ? 'active' : ''}" onclick="selectCollatToken('${token}')">
          <span class="collat-dot" style="background: ${COLLATERAL_COLORS[token] || '#888'}"></span>
          ${token}
        </button>
      `).join('');
    }

    function selectCollatToken(token) {
      perpsCollateralToken = token;
      $('perps-collat-token').textContent = token;
      buildCollatDropdown();
      updatePerpsOrder();
    }

    // Helper: get collateral value in USD
    function getCollatPriceUSD(token) {
      if (STABLECOINS.includes(token)) return 1;
      return perpsPrices[token] || 0;
    }

    // ── Order Calculation ──
    function updatePerpsOrder() {
      const price = perpsPrices[perpsMarket] || 0;
      const collateral = parseFloat($('perps-collateral')?.value) || 0;
      const leverage = perpsLeverage;
      const side = perpsSide;
      const cfg = PERPS_SYMBOLS[perpsMarket];

      // Calculate collateral value in USD based on selected token
      const collatPriceUSD = getCollatPriceUSD(perpsCollateralToken);
      const collateralUSD = collateral * collatPriceUSD;
      let positionSizeUSD = collateralUSD * leverage;

      // Entry price
      const entryPrice = perpsOrderType === 'limit'
        ? (parseFloat($('perps-limit-price')?.value) || price)
        : price;

      // Liquidation price calculation
      // Long: liqPrice = entryPrice * (1 - 1/leverage) * 1.01 (1% buffer)
      // Short: liqPrice = entryPrice * (1 + 1/leverage) * 0.99
      let liqPrice = 0;
      if (leverage > 0 && entryPrice > 0) {
        if (side === 'long') {
          liqPrice = entryPrice * (1 - 0.9 / leverage);
        } else {
          liqPrice = entryPrice * (1 + 0.9 / leverage);
        }
      }

      // Open fee: 0.07% of position size (Jupiter Perps standard)
      const openFee = positionSizeUSD * 0.0007;

      // Borrow rate
      const hourlyBorrow = positionSizeUSD * 0.00012; // ~0.012%/hr

      // Update DOM
      const sizeEl = $('perps-pos-size');
      if (sizeEl) sizeEl.textContent = '$' + (positionSizeUSD > 0 ? positionSizeUSD.toLocaleString('en-US', { maximumFractionDigits: 2 }) : '0.00');

      const entryEl = $('perps-entry-price');
      if (entryEl) entryEl.textContent = '$' + formatPerpsPrice(entryPrice, cfg.decimals);

      const liqEl = $('perps-liq-price');
      if (liqEl) {
        liqEl.textContent = liqPrice > 0 ? '$' + formatPerpsPrice(liqPrice, cfg.decimals) : '$—';
        liqEl.style.color = 'var(--red)';
      }

      const feeEl = $('perps-open-fee');
      if (feeEl) feeEl.textContent = openFee > 0 ? '$' + openFee.toFixed(4) : '—';

      const borrowEl = $('perps-borrow-disp');
      if (borrowEl) borrowEl.textContent = hourlyBorrow > 0 ? '$' + hourlyBorrow.toFixed(4) + '/hr' : '—';

      // Execute button text
      const execBtn = $('perps-exec-btn');
      if (execBtn) {
        const sideText = side === 'long' ? 'LONG' : 'SHORT';
        const emoji = side === 'long' ? '🟢' : '🔴';
        const sizeStr = positionSizeUSD > 0 ? '$' + positionSizeUSD.toLocaleString('en-US', { maximumFractionDigits: 0 }) : '$0';
        execBtn.textContent = `${emoji} OPEN ${sideText} ${perpsMarket} — ${sizeStr}`;
        execBtn.disabled = collateral <= 0 || price <= 0;
      }
    }

    // ═══════ JUPITER TRADE BRIDGE ═══════
    let jupModalData = null;

    function openJupModal(jupUrl, posData) {
      jupModalData = { url: jupUrl, pos: posData };
      $('jup-url-text').textContent = jupUrl.replace('https://', '');
      $('jup-track').textContent = posData ? `● Tracking ${posData.side.toUpperCase()} ${posData.market} ${posData.leverage}x` : '';

      const s = posData.side;
      const sideClass = s === 'long' ? 'long' : 'short';
      const sideEmoji = s === 'long' ? '🟢' : '🔴';
      const cfg = PERPS_SYMBOLS[posData.market];

      $('jup-body').innerHTML = `
        <div class="jup-brief">
          <div class="jup-brief-title">YOUR ORDER — ENTER THIS ON JUPITER</div>
          <div class="jup-order-card">
            <div class="jup-order-header">
              <span class="jup-order-side ${sideClass}">${sideEmoji} ${s.toUpperCase()}</span>
              <span class="jup-order-market">${posData.market}/USD</span>
            </div>
            <div class="jup-order-grid">
              <div class="jup-order-item">
                <div class="jup-order-label">COLLATERAL (YOU'RE PAYING)</div>
                <div class="jup-order-val accent">${posData.collateral}<span class="jup-order-unit">${posData.collateralToken}</span></div>
              </div>
              <div class="jup-order-item">
                <div class="jup-order-label">LEVERAGE</div>
                <div class="jup-order-val green">${posData.leverage}x</div>
              </div>
              <div class="jup-order-item">
                <div class="jup-order-label">POSITION SIZE</div>
                <div class="jup-order-val">$${posData.positionSizeUSD.toLocaleString('en-US', { maximumFractionDigits: 0 })}</div>
              </div>
              <div class="jup-order-item">
                <div class="jup-order-label">ENTRY PRICE</div>
                <div class="jup-order-val">$${formatPerpsPrice(posData.entryPrice, cfg.decimals)}</div>
              </div>
            </div>
          </div>
          <div class="jup-steps">
            <div class="jup-step"><span class="jup-step-num">1</span> Jupiter opens → enter <strong>${posData.collateral} ${posData.collateralToken}</strong> as collateral</div>
            <div class="jup-step"><span class="jup-step-num">2</span> Set leverage to <strong>${posData.leverage}x</strong></div>
            <div class="jup-step"><span class="jup-step-num">3</span> Hit <strong>${s.toUpperCase()}</strong> and confirm in Phantom</div>
          </div>
          <button class="jup-go-btn ${sideClass}" onclick="launchJupiter()">
            ↗ Open Jupiter — ${s.toUpperCase()} ${posData.market}
          </button>
          <div style="font-size:10px;color:var(--text-ghost);margin-top:12px;">
            Ghost is tracking this position with live prices ⚡
          </div>
        </div>
      `;

      $('jup-modal').style.display = 'flex';
    }

    function launchJupiter() {
      if (!jupModalData) return;
      const w = 480, h = 760;
      const left = window.screenX + window.innerWidth - w - 40;
      const top = window.screenY + 60;
      window.open(
        jupModalData.url, 'jupiter_perps',
        `width=${w},height=${h},left=${left},top=${top},toolbar=no,menubar=no,scrollbars=yes,resizable=yes`
      );
      toast('↗ Jupiter opened — match the settings and confirm', 4000);
    }

    function closeJupModal() {
      $('jup-modal').style.display = 'none';
      $('jup-body').innerHTML = '';
      jupModalData = null;
    }

    function reopenJupFor(posId) {
      const pos = perpsPositions.find(p => p.id === posId);
      if (pos && pos.jupUrl) openJupModal(pos.jupUrl, pos);
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && $('jup-modal').style.display === 'flex') closeJupModal();
    });

    // ── Execute Trade — Jupiter Bridge ──
    let perpsExecuting = false;

    async function executePerps() {
      const price = perpsPrices[perpsMarket];
      const collateral = parseFloat($('perps-collateral')?.value) || 0;

      if (!price || collateral <= 0) {
        toast('Enter a collateral amount'); return;
      }
      if (perpsExecuting) return;
      perpsExecuting = true;

      const side = perpsSide;
      const leverage = perpsLeverage;
      const market = perpsMarket;
      const cfg = PERPS_SYMBOLS[market];
      const execBtn = $('perps-exec-btn');
      const origText = execBtn.textContent;
      execBtn.disabled = true;
      execBtn.textContent = '⏳ OPENING JUPITER...';

      try {
        const collateralToken = perpsCollateralToken;
        const collatPriceUSD = getCollatPriceUSD(collateralToken);
        const collateralUSD = collateral * collatPriceUSD;
        let positionSizeUSD = collateralUSD * leverage;
        const openFee = positionSizeUSD * 0.0007;

        // Build Jupiter Perps URL with selected collateral
        const jupMarket = market === 'BTC' ? 'WBTC' : market;
        let jupCollateral = collateralToken;
        if (collateralToken === 'BTC') jupCollateral = 'WBTC';
        const jupUrl = `https://jup.ag/perps/${side}/${jupMarket}-${jupCollateral}`;

        // Track position locally
        const pos = {
          id: Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
          market, side, leverage, collateral, collateralToken,
          entryPrice: price, positionSizeUSD, openFee,
          liqPrice: side === 'long'
            ? price * (1 - 0.9 / leverage)
            : price * (1 + 0.9 / leverage),
          openTime: Date.now(),
          status: 'open',
          onChain: true,
          jupUrl,
        };

        perpsPositions.unshift(pos);
        lsSetJSON('ghost-perps-positions', perpsPositions);
        renderPerpsPositions();

        // Show the order briefing modal
        openJupModal(jupUrl, pos);

        const sideEmoji = side === 'long' ? '🟢' : '🔴';
        toast(`${sideEmoji} Complete your ${side.toUpperCase()} on Jupiter`, 3000);

        if ($('empty-state')) $('empty-state').style.display = 'none';
        addMsg('success', `${sideEmoji} **${side.toUpperCase()} ${market} ${leverage}x — CONFIRM ON JUPITER**\n\nEnter **${collateral} ${collateralToken}** at **${leverage}x** leverage\nSize: ~$${positionSizeUSD.toLocaleString('en-US', { maximumFractionDigits: 0 })} | Liq: ~$${formatPerpsPrice(pos.liqPrice, cfg.decimals)}\n\n⚡ Ghost is tracking this position with live P&L`);

      } catch(e) {
        console.error('Perps error:', e);
        toast('❌ Failed — ' + (e.message || 'Unknown error'), 5000);
        addMsg('system', `❌ Failed to open position\n\n${e.message || 'Unknown error'}`);
      } finally {
        perpsExecuting = false;
        execBtn.disabled = false;
        execBtn.textContent = origText;
        updatePerpsOrder();
      }
    }

    // Helper: write u64 little-endian
    function writeU64LE(buf, offset, val) {
      let v = BigInt(val);
      for (let i = 0; i < 8; i++) {
        buf[offset + i] = Number(v & 0xFFn);
        v >>= 8n;
      }
    }

    // Helper: get or derive ATA
    async function getOrCreateATA(conn, owner, mint) {
      const [ata] = solanaWeb3.PublicKey.findProgramAddressSync(
        [owner.toBytes(), new solanaWeb3.PublicKey(TOKEN_PROGRAM).toBytes(), mint.toBytes()],
        new solanaWeb3.PublicKey(ATA_PROGRAM)
      );
      return ata;
    }

    // Helper: build wSOL wrap instructions
    async function buildWrapSolIxs(conn, owner, wsolMint, lamports) {
      const ata = await getOrCreateATA(conn, owner, wsolMint);
      const ixs = [];

      // Create ATA if needed (idempotent create)
      ixs.push(
        new solanaWeb3.TransactionInstruction({
          programId: new solanaWeb3.PublicKey(ATA_PROGRAM),
          keys: [
            { pubkey: owner, isSigner: true, isWritable: true },
            { pubkey: ata, isSigner: false, isWritable: true },
            { pubkey: owner, isSigner: false, isWritable: false },
            { pubkey: wsolMint, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(SYSTEM_PROGRAM), isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(TOKEN_PROGRAM), isSigner: false, isWritable: false },
          ],
          data: new Uint8Array([1]), // CreateIdempotent
        })
      );

      // Transfer SOL to wSOL ATA
      ixs.push(
        solanaWeb3.SystemProgram.transfer({
          fromPubkey: owner,
          toPubkey: ata,
          lamports: lamports,
        })
      );

      // Sync native (instruction 17 on Token program)
      ixs.push(
        new solanaWeb3.TransactionInstruction({
          programId: new solanaWeb3.PublicKey(TOKEN_PROGRAM),
          keys: [{ pubkey: ata, isSigner: false, isWritable: true }],
          data: new Uint8Array([17]), // SyncNative
        })
      );

      return ixs;
    }

    // ── Positions ──
    function renderPerpsPositions() {
      const list = $('perps-positions-list');
      if (!list) return;

      const open = perpsPositions.filter(p => p.status !== 'closed' && p.status !== 'liquidated');
      if (open.length === 0) {
        list.innerHTML = '<div class="perps-pos-empty">No open positions</div>';
        return;
      }

      list.innerHTML = open.map(pos => {
        const cfg = PERPS_SYMBOLS[pos.market];
        const currentPrice = perpsPrices[pos.market] || pos.entryPrice;
        let pnlPct = 0;
        if (pos.side === 'long') {
          pnlPct = ((currentPrice - pos.entryPrice) / pos.entryPrice) * pos.leverage * 100;
        } else {
          pnlPct = ((pos.entryPrice - currentPrice) / pos.entryPrice) * pos.leverage * 100;
        }
        const pnlUsd = pos.positionSizeUSD * (pnlPct / 100);
        const isProfit = pnlPct >= 0;
        const age = timeSince(pos.openTime);
        const statusLabel = pos.onChain === true ? ' <span style="color:var(--green);font-size:9px;">⛓️ JUPITER</span>' : (pos.status === 'keeper_pending' ? ' <span style="color:#fbbf24;font-size:9px;">⏳ PENDING</span>' : ' <span style="color:var(--accent);font-size:9px;">● TRACKING</span>');

        return `
          <div class="perps-pos-card">
            <div class="perps-pos-top">
              <div class="perps-pos-sym">
                ${pos.market}/USD
                <span class="perps-pos-side ${pos.side}">${pos.side.toUpperCase()}</span>
                <span class="perps-pos-lev">${pos.leverage}x</span>
                ${statusLabel}
              </div>
              <span style="font-size:12px;font-weight:800;font-family:'Fira Code',monospace;color:${isProfit ? 'var(--green)' : 'var(--red)'};">${isProfit ? '+' : ''}${pnlPct.toFixed(2)}%</span>
            </div>
            <div class="perps-pos-grid">
              <div class="perps-pos-stat">
                <span class="perps-pos-stat-label">Size</span>
                <span class="perps-pos-stat-val">$${pos.positionSizeUSD.toFixed(0)}</span>
              </div>
              <div class="perps-pos-stat">
                <span class="perps-pos-stat-label">Entry</span>
                <span class="perps-pos-stat-val">$${formatPerpsPrice(pos.entryPrice, cfg.decimals)}</span>
              </div>
              <div class="perps-pos-stat">
                <span class="perps-pos-stat-label">Mark</span>
                <span class="perps-pos-stat-val">$${formatPerpsPrice(currentPrice, cfg.decimals)}</span>
              </div>
              <div class="perps-pos-stat">
                <span class="perps-pos-stat-label">Liq. Price</span>
                <span class="perps-pos-stat-val" style="color:var(--red);">$${formatPerpsPrice(pos.liqPrice, cfg.decimals)}</span>
              </div>
              <div class="perps-pos-stat">
                <span class="perps-pos-stat-label">PnL</span>
                <span class="perps-pos-stat-val" style="color:${isProfit ? 'var(--green)' : 'var(--red)'};">${isProfit ? '+' : ''}$${pnlUsd.toFixed(2)}</span>
              </div>
              <div class="perps-pos-stat">
                <span class="perps-pos-stat-label">Age</span>
                <span class="perps-pos-stat-val">${age}</span>
              </div>
            </div>
            <div style="display:flex;gap:6px;margin-top:8px;">
              ${pos.jupUrl ? `<button style="flex:1;padding:7px;background:var(--accent-dim);border:1px solid rgba(34,209,238,0.2);border-radius:8px;font-size:10px;font-weight:700;color:var(--accent);cursor:pointer;font-family:'Plus Jakarta Sans',sans-serif;transition:all 0.15s;" onclick="reopenJupFor('${pos.id}')">↗ Jupiter</button>` : ''}
              <button class="perps-pos-close" style="flex:2;margin-top:0;" onclick="closePerpsPosition('${pos.id}')">✕ Close</button>
            </div>
          </div>
        `;
      }).join('');
    }

    function closePerpsPosition(id) {
      const pos = perpsPositions.find(p => p.id === id);
      if (!pos) return;

      const cfg = PERPS_SYMBOLS[pos.market];
      const currentPrice = perpsPrices[pos.market] || pos.entryPrice;

      let pnlPct = 0;
      if (pos.side === 'long') {
        pnlPct = ((currentPrice - pos.entryPrice) / pos.entryPrice) * pos.leverage * 100;
      } else {
        pnlPct = ((pos.entryPrice - currentPrice) / pos.entryPrice) * pos.leverage * 100;
      }
      const pnlUsd = pos.positionSizeUSD * (pnlPct / 100);

      // Open Jupiter to close on-chain position
      if (pos.onChain && pos.jupUrl) {
        openJupModal(pos.jupUrl, pos);
      }

      pos.status = 'closed';
      pos.closePrice = currentPrice;
      pos.closeTime = Date.now();

      lsSetJSON('ghost-perps-positions', perpsPositions);
      renderPerpsPositions();

      const isProfit = pnlPct >= 0;
      const emoji = isProfit ? '🟢' : '🔴';
      toast(`${emoji} Closed ${pos.side.toUpperCase()} ${pos.market} — ${isProfit ? '+' : ''}${pnlPct.toFixed(2)}%`, 4000);

      if ($('empty-state')) $('empty-state').style.display = 'none';
      addMsg(isProfit ? 'success' : 'system',
        `${emoji} POSITION CLOSED\n\n${pos.side.toUpperCase()} ${pos.market}/USD ${pos.leverage}x\nEntry: $${formatPerpsPrice(pos.entryPrice, cfg.decimals)}\nExit: $${formatPerpsPrice(currentPrice, cfg.decimals)}\nPnL: ${isProfit ? '+' : ''}${pnlPct.toFixed(2)}% (${isProfit ? '+' : ''}$${pnlUsd.toFixed(2)})\n\n⚠️ **Close on Jupiter too** if you haven't already.`
      );
    }

    // ── Liquidation Checker ──
    function checkPerpsLiquidations(market) {
      const price = perpsPrices[market];
      if (!price) return;

      let changed = false;
      perpsPositions.forEach(pos => {
        if (pos.market !== market || pos.status !== 'open') return;

        let liquidated = false;
        if (pos.side === 'long' && price <= pos.liqPrice) liquidated = true;
        if (pos.side === 'short' && price >= pos.liqPrice) liquidated = true;

        if (liquidated) {
          pos.status = 'liquidated';
          pos.closePrice = pos.liqPrice;
          pos.closeTime = Date.now();
          changed = true;

          toast(`💀 LIQUIDATED — ${pos.side.toUpperCase()} ${pos.market} ${pos.leverage}x at $${formatPerpsPrice(price, PERPS_SYMBOLS[pos.market].decimals)}`, 6000);
          addMsg('system', `💀 POSITION LIQUIDATED\n\n${pos.side.toUpperCase()} ${pos.market}/USD ${pos.leverage}x\nEntry: $${formatPerpsPrice(pos.entryPrice, PERPS_SYMBOLS[pos.market].decimals)}\nLiq. Price: $${formatPerpsPrice(pos.liqPrice, PERPS_SYMBOLS[pos.market].decimals)}\nLoss: -$${pos.positionSizeUSD.toFixed(2)}`);
        }
      });

      if (changed) {
        lsSetJSON('ghost-perps-positions', perpsPositions);
        renderPerpsPositions();
      }
    }

    function refreshPerpsPositions() {
      fetchPerps24hStats();
      renderPerpsPositions();
      toast('Positions refreshed');
    }

    // ═══════ KEYBOARD SHORTCUTS ═══════
    document.addEventListener('keydown', (e) => {
      const tag = document.activeElement?.tagName;
      if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 't': e.preventDefault(); setMode('trade'); break;
          case 'l': e.preventDefault(); setMode('launch'); break;
          case 'k': e.preventDefault(); $('input').focus(); break;
          case 'p': e.preventDefault(); setMode('perps'); break;
          case 'b': e.preventDefault(); setMode('alpha'); break;
        }
      } else if (e.key === 'Escape') {
        if (currentMode !== 'chat') { goBack(); e.preventDefault(); }
      }
    });

    // ═══════ INIT ═══════
    $('theme-btn').textContent = document.documentElement.getAttribute('data-theme') === 'dark' ? '☀️' : '🌙';
    $('model-sel').value = currentModel;
    checkApiKey();
    renderTradeHistory();
    updateWsBtn();
    updateSniperSwitch();
    setChatMode(chatMode);
    if ($('sltp-toggle')) $('sltp-toggle').classList.toggle('on', sltpEnabled);
    if (sltpEnabled && Object.keys(manualPositions).length > 0) startManualSltpMonitor();

    // Restore chain state on init
    if (activeChain !== 'solana') {
      switchChain(activeChain);
    }

    // Restore last mode
    const savedMode = lsGet('ghost-mode', '');
    if (savedMode && savedMode !== 'chat') {
      setTimeout(() => setMode(savedMode), 100);
    }

    // Restore last chat session
    if (currentSessionId) {
      const session = chatSessions.find(s => s.id === currentSessionId);
      if (session && session.messages && session.messages.length > 0) {
        chatMessages = [...session.messages];
        $('messages').innerHTML = '';
        const es = $('empty-state');
        if (es) es.style.display = 'none';
        for (const msg of chatMessages) {
          if (msg.role === 'user' || msg.role === 'assistant') {
            // Render without triggering addMsg's push to chatMessages
            const div = document.createElement('div'); div.className = 'message ' + msg.role;
            const h = document.createElement('div'); h.className = 'mh';
            h.innerHTML = `<span class="mr">${msg.role === 'user' ? 'YOU' : 'GHOST'}</span>${msg.role === 'assistant' ? `<span class="mt">${getModelLabel(currentModel)}</span>` : ''}`;
            div.appendChild(h);
            const c = document.createElement('div'); c.className = 'mc';
            c.innerHTML = msg.content
              .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
              .replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>')
              .replace(/`([^`]+)`/g,'<code style="background:var(--bg-elevated);padding:1px 5px;border-radius:4px;font-size:0.9em;">$1</code>')
              .replace(/^### (.+)$/gm,'<strong style="font-size:1.05em;">$1</strong>')
              .replace(/^## (.+)$/gm,'<strong style="font-size:1.1em;">$1</strong>')
              .replace(/\n/g,'<br>')
              .replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank" style="color:var(--accent);">$1</a>');
            div.appendChild(c);
            $('messages').appendChild(div);
          }
        }
        $('messages').scrollTop = $('messages').scrollHeight;
      }
    }

    // Restore Alpha Bot state
    if (alphaStrategy) {
      const el = $('alpha-strategy');
      if (el) el.textContent = alphaStrategy;
      setAlphaStatus('idle', 'Study complete — ready to trade');
    }
    if (heliusKey) {
      const hk = $('alpha-helius-key');
      if (hk) hk.value = heliusKey;
    }
    // Render saved log on load
    if (alphaBotLog.length > 0) renderAlphaLog();
    // Render alpha bot wallet
    renderAlphaBotWallet();

    // Save state before user leaves
    window.addEventListener('beforeunload', () => {
      saveCurrentSession();
      disconnectPerpsWs();
    });

    window.addEventListener('load', async () => {
      // Wait for Phantom to inject (up to 3s on load)
      const phantom = await waitForPhantom(3000);
      if (phantom) {
        phantom.connect({ onlyIfTrusted: true }).then(resp => {
          walletPubkey = resp.publicKey; walletAddress = resp.publicKey.toString();
          $('wbtn').className = 'wallet-btn on';
          $('wbtn-t').textContent = walletAddress.slice(0, 4) + '...' + walletAddress.slice(-4);
          $('lbtn').className = 'lbtn ready'; $('lbtn').textContent = '🚀 LAUNCH TOKEN';
          $('ph-stat').style.background = 'var(--green-dim)'; $('ph-stat').style.color = 'var(--green)'; $('ph-stat').textContent = 'CONNECTED';
          $('tr-buy-btn').disabled = false;
          $('tr-sell-btn').disabled = false;
          getWorkingConnection().then(conn =>
            conn.getBalance(resp.publicKey)
              .then(b => { walletBalance = b / 1e9; updateWalletPanel(); })
              .catch(() => { walletBalance = '—'; updateWalletPanel(); })
          ).catch(() => { walletBalance = '—'; updateWalletPanel(); });
          setTimeout(refreshPositions, 500);
        }).catch(() => {});
      }
    });

    $('input').focus();
  </script>
</body>
</html>
